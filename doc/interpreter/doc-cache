# doc-cache created by Octave 3.8.2, Wed Aug 06 15:18:20 2014 EDT
# name: cache
# type: cell
# rows: 3
# columns: 1611
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
@ftp/ascii


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 318
 -- Function File: ascii (F)
     Set the FTP connection F to use ASCII mode for transfers.  ASCII
     mode is only appropriate for text files as it will convert the
     remote host's newline representation to the local host's newline
     representation.

     F is an FTP object returned by the 'ftp' function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Set the FTP connection F to use ASCII mode for transfers.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
@ftp/binary


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 275
 -- Function File: binary (F)
     Set the FTP connection F to use binary mode for transfers.  In
     binary mode there is no conversion of newlines from the remote
     representation to the local representation.

     F is an FTP object returned by the 'ftp' function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Set the FTP connection F to use binary mode for transfers.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
@ftp/cd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 471
 -- Function File: cd (F)
 -- Function File: cd (F, PATH)
     Get or set the remote directory on the FTP connection F.

     F is an FTP object returned by the 'ftp' function.

     If PATH is not specified, return the remote current working
     directory.  Otherwise, set the remote directory to PATH and return
     the new remote working directory.

     If the directory does not exist, an error message is printed and
     the working directory is not changed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Get or set the remote directory on the FTP connection F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
@ftp/close


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
 -- Function File: close (F)
     Close the FTP connection represented by the FTP object F.

     F is an FTP object returned by the 'ftp' function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Close the FTP connection represented by the FTP object F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
@ftp/delete


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 156
 -- Function File: delete (F, FILE)
     Delete the remote file FILE over the FTP connection F.

     F is an FTP object returned by the 'ftp' function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Delete the remote file FILE over the FTP connection F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
@ftp/dir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 172
 -- Function File: LST = dir (F)
     List the current directory in verbose form for the FTP connection
     F.

     F is an FTP object returned by the 'ftp' function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
List the current directory in verbose form for the FTP connection  F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
@ftp/ftp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1028
 -- Function File: F = ftp (HOST)
 -- Function File: F = ftp (HOST, USERNAME, PASSWORD)
     Connect to the FTP server HOST with USERNAME and PASSWORD.  If
     USERNAME and PASSWORD are not specified, user "anonymous" with no
     password is used.  The returned FTP object F represents the
     established FTP connection.

     The list of actions for an FTP object are shown below.  All
     functions require an FTP object as the first argument.

     Method      Description
     -----------------------------------------------------------------------
     ascii       Set transfer type to ascii
     binary      Set transfer type to binary
     cd          Change remote working directory
     close       Close FTP connection
     delete      Delete remote file
     dir         List remote directory contents
     mget        Download remote files
     mkdir       Create remote directory
     mput        Upload local files
     rename      Rename remote file or directory
     rmdir       Remove remote directory

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Connect to the FTP server HOST with USERNAME and PASSWORD.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
@ftp/mget


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 593
 -- Function File: mget (F, FILE)
 -- Function File: mget (F, DIR)
 -- Function File: mget (F, REMOTE_NAME, TARGET)
     Download a remote file FILE or directory DIR to the local directory
     on the FTP connection F.  F is an FTP object returned by the 'ftp'
     function.

     The arguments FILE and DIR can include wildcards and any files or
     directories on the remote server that match will be downloaded.

     If a third argument TARGET is given, then a single file or
     directory will be downloaded to the local directory and the local
     name will be changed to TARGET.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Download a remote file FILE or directory DIR to the local directory  on the FTP connection F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
@ftp/mkdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 161
 -- Function File: mkdir (F, PATH)
     Create the remote directory PATH, over the FTP connection F.

     F is an FTP object returned by the 'ftp' function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Create the remote directory PATH, over the FTP connection F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
@ftp/mput


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 315
 -- Function File: mput (F, FILE)
     Upload the local file FILE into the current remote directory on the
     FTP connection F.  F is an FTP object returned by the ftp function.

     The argument FILE is passed through the 'glob' function and any
     files that match the wildcards in FILE will be uploaded.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Upload the local file FILE into the current remote directory on the  FTP connection F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
@ftp/rename


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 207
 -- Function File: rename (F, OLDNAME, NEWNAME)
     Rename or move the remote file or directory OLDNAME to NEWNAME,
     over the FTP connection F.

     F is an FTP object returned by the ftp function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
Rename or move the remote file or directory OLDNAME to NEWNAME,  over the FTP connection F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
@ftp/rmdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 161
 -- Function File: rmdir (F, PATH)
     Remove the remote directory PATH, over the FTP connection F.

     F is an FTP object returned by the 'ftp' function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Remove the remote directory PATH, over the FTP connection F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
lin2mu


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 385
 -- Function File: lin2mu (X, N)
     Convert audio data from linear to mu-law.  Mu-law values use 8-bit
     unsigned integers.  Linear values use N-bit signed integers or
     floating point values in the range -1 <= X <= 1 if N is 0.

     If N is not specified it defaults to 0, 8, or 16 depending on the
     range of values in X.

     See also: mu2lin, loadaudio, saveaudio.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Convert audio data from linear to mu-law.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
loadaudio


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 526
 -- Function File: loadaudio (NAME, EXT, BPS)
     Load audio data from the file 'NAME.EXT' into the vector X.

     The extension EXT determines how the data in the audio file is
     interpreted; the extensions 'lin' (default) and 'raw' correspond to
     linear, the extensions 'au', 'mu', or 'snd' to mu-law encoding.

     The argument BPS can be either 8 (default) or 16, and specifies the
     number of bits per sample used in the audio file.

     See also: lin2mu, mu2lin, saveaudio, playaudio, setaudio, record.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Load audio data from the file 'NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mu2lin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 328
 -- Function File: mu2lin (X, N)
     Convert audio data from mu-law to linear.  Mu-law values are 8-bit
     unsigned integers.  Linear values use N-bit signed integers or
     floating point values in the range -1<=y<=1 if N is 0.

     If N is not specified it defaults to 0.

     See also: lin2mu, loadaudio, saveaudio.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Convert audio data from mu-law to linear.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
playaudio


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 232
 -- Function File: playaudio (NAME, EXT)
 -- Function File: playaudio (X)
     Play the audio file 'NAME.EXT' or the audio data stored in the
     vector X.

     See also: lin2mu, mu2lin, loadaudio, saveaudio, setaudio, record.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Play the audio file 'NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
record


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 362
 -- Function File: record (SEC, SAMPLING_RATE)
     Record SEC seconds of audio input into the vector X.  The default
     value for SAMPLING_RATE is 8000 samples per second, or 8kHz.  The
     program waits until the user types <RET> and then immediately
     starts to record.

     See also: lin2mu, mu2lin, loadaudio, saveaudio, playaudio,
     setaudio.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Record SEC seconds of audio input into the vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
saveaudio


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 374
 -- Function File: saveaudio (NAME, X, EXT, BPS)
     Save a vector X of audio data to the file 'NAME.EXT'.  The optional
     parameters EXT and BPS determine the encoding and the number of
     bits per sample used in the audio file (see 'loadaudio'); defaults
     are 'lin' and 8, respectively.

     See also: lin2mu, mu2lin, loadaudio, playaudio, setaudio, record.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Save a vector X of audio data to the file 'NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
setaudio


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 211
 -- Function File: setaudio ()
 -- Function File: setaudio (W_TYPE)
 -- Function File: setaudio (W_TYPE, VALUE)
     Execute the shell command 'mixer', possibly with optional arguments
     W_TYPE and VALUE.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Execute the shell command 'mixer', possibly with optional arguments  W_TYPE and VALUE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
wavread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 973
 -- Function File: Y = wavread (FILENAME)
 -- Function File: [Y, FS, BPS] = wavread (FILENAME)
 -- Function File: [...] = wavread (FILENAME, N)
 -- Function File: [...] = wavread (FILENAME, [N1 N2])
 -- Function File: [SAMPLES, CHANNELS] = wavread (FILENAME, "size")

     Load the RIFF/WAVE sound file FILENAME, and return the samples in
     vector Y.  If the file contains multichannel data, then Y is a
     matrix with the channels represented as columns.

     '[Y, FS, BPS] = wavread (FILENAME)'

     Additionally return the sample rate (FS) in Hz and the number of
     bits per sample (BPS).

     '[...] = wavread (FILENAME, N)'

     Read only the first N samples from each channel.

     'wavread (FILENAME, [N1 N2])'

     Read only samples N1 through N2 from each channel.

     '[SAMPLES, CHANNELS] = wavread (FILENAME, "size")'

     Return the number of samples (N) and number of channels (CH)
     instead of the audio data.

     See also: wavwrite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Load the RIFF/WAVE sound file FILENAME, and return the samples in  vector Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
wavwrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 493
 -- Function File: wavwrite (Y, FILENAME)
 -- Function File: wavwrite (Y, FS, FILENAME)
 -- Function File: wavwrite (Y, FS, BPS, FILENAME)
     Write Y to the canonical RIFF/WAVE sound file FILENAME with sample
     rate FS and bits per sample BPS.  The default sample rate is 8000
     Hz with 16-bits per sample.  Each column of the data represents a
     separate channel.  If Y is either a row vector or a column vector,
     it is written as a single channel.

     See also: wavread.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
Write Y to the canonical RIFF/WAVE sound file FILENAME with sample  rate FS and bits per sample BPS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
cor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 174
 -- Function File: cor (X)
 -- Function File: cor (X, Y)
     Compute matrix of correlation coefficients.

     This is an alias for 'corrcoef'.

     See also: corrcoef.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Compute matrix of correlation coefficients.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
corrcoef


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 518
 -- Function File: corrcoef (X)
 -- Function File: corrcoef (X, Y)
     Compute matrix of correlation coefficients.

     If each row of X and Y is an observation and each column is a
     variable, then the (I, J)-th entry of 'corrcoef (X, Y)' is the
     correlation between the I-th variable in X and the J-th variable in
     Y.

          corrcoef(x,y) = cov(x,y)/(std(x)*std(y))

     If called with one argument, compute 'corrcoef (X, X)', the
     correlation between the columns of X.

     See also: cov.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Compute matrix of correlation coefficients.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
cut


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 569
 -- Function File: cut (X, BREAKS)
     Create categorical data from numerical or continuous data by
     cutting into intervals.

     If BREAKS is a scalar, the data is cut into that many equal-width
     intervals.  If BREAKS is a vector of break points, the category has
     'length (BREAKS) - 1' groups.

     The returned value is a vector of the same size as X telling which
     group each point in X belongs to.  Groups are labelled from 1 to
     the number of groups; points outside the range of BREAKS are
     labelled by 'NaN'.

     See also: histc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
Create categorical data from numerical or continuous data by  cutting into intervals.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
default_save_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 303
 -- Built-in Function: VAL = default_save_options ()
 -- Built-in Function: OLD_VAL = default_save_options (NEW_VAL)
 -- Built-in Function: default_save_options (NEW_VAL, "local")
     This function has been deprecated.  Use 'save_default_options'
     instead.

     See also: save_default_options.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
This function has been deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
error_text


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 154
 -- Built-in Function: [MSG, MSGID] = error_text (MSG, MSGID)
     This function has been deprecated.  Use 'lasterr' instead.

     See also: lasterr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
This function has been deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
gen_doc_cache


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 165
 -- Function File: gen_doc_cache (OUT_FILE, DIRECTORY)
     This function has been deprecated.  Use 'doc_cache_create' instead.

     See also: doc_cache_create.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
This function has been deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
interp1q


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 806
 -- Function File: YI = interp1q (X, Y, XI)
     One-dimensional linear interpolation without error checking.
     Interpolates Y, defined at the points X, at the points XI.  The
     sample points X must be a strictly monotonically increasing column
     vector.  If Y is a matrix or an N-dimensional array, the
     interpolation is performed on each column of Y.  If Y is a vector,
     it must be a column vector of the same length as X.

     Values of XI beyond the endpoints of the interpolation result in NA
     being returned.

     Note that the error checking is only a significant portion of the
     execution time of this 'interp1' if the size of the input arguments
     is relatively small.  Therefore, the benefit of using 'interp1q' is
     relatively small.

     See also: interp1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
One-dimensional linear interpolation without error checking.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
isequalwithequalnans


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 148
 -- Function File: isequalwithequalnans (X1, X2, ...)
     This function has been deprecated.  Use 'isequaln' instead.

     See also: isequaln.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
This function has been deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
isstr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
 -- Function File: isstr (A)
     This function has been deprecated.  Use ischar instead.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
This function has been deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
java_convert_matrix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 656
 -- Built-in Function: VAL = java_convert_matrix ()
 -- Built-in Function: OLD_VAL = java_convert_matrix (NEW_VAL)
 -- Built-in Function: java_convert_matrix (NEW_VAL, "local")
     Query or set the internal variable that controls whether Java
     arrays are automatically converted to Octave matrices.  The default
     value is false.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: java_matrix_autoconversion, java_unsigned_conversion,
     java_debug.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
Query or set the internal variable that controls whether Java  arrays are automatically converted to Octave matrices.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
java_debug


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 639
 -- Built-in Function: VAL = java_debug ()
 -- Built-in Function: OLD_VAL = java_debug (NEW_VAL)
 -- Built-in Function: java_debug (NEW_VAL, "local")
     Query or set the internal variable that determines whether extra
     debugging information regarding the initialization of the JVM and
     any Java exceptions is printed.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: debug_java, java_convert_matrix,
     java_unsigned_conversion.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
Query or set the internal variable that determines whether extra  debugging information regarding the initialization of the JVM and  any Java exceptions is printed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
java_invoke


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 714
 -- Built-in Function: RET = java_invoke (OBJ, METHODNAME)
 -- Built-in Function: RET = java_invoke (OBJ, METHODNAME, ARG1, ...)
     Invoke the method METHODNAME on the Java object OBJ with the
     arguments ARG1, ... For static methods, OBJ can be a string
     representing the fully qualified name of the corresponding class.
     The function returns the result of the method invocation.

     When OBJ is a regular Java object, structure-like indexing can be
     used as a shortcut syntax.  For instance, the two following
     statements are equivalent

            ret = java_invoke (x, "method1", 1.0, "a string")
            ret = x.method1 (1.0, "a string")

     See also: javaMethod, javaObject.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Invoke the method METHODNAME on the Java object OBJ with the  arguments ARG1, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
java_new


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 375
 -- Loadable Function: OBJ = java_new (NAME)
 -- Loadable Function: OBJ = java_new (NAME, ARG1, ...)
     Create a Java object of class NAME, by calling the class
     constructor with the arguments ARG1, ...

            x = java_new ("java.lang.StringBuffer")
            x = java_new ("java.lang.StringBuffer", "Initial string")

     See also: javaObject, javaMethod.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Create a Java object of class NAME, by calling the class  constructor with the arguments ARG1, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
java_unsigned_conversion


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 770
 -- Built-in Function: VAL = java_unsigned_conversion ()
 -- Built-in Function: OLD_VAL = java_unsigned_conversion (NEW_VAL)
 -- Built-in Function: java_unsigned_conversion (NEW_VAL, "local")
     Query or set the internal variable that controls how integer
     classes are converted when Java matrix autoconversion is enabled.
     When enabled, Java arrays of class Byte or Integer are converted to
     matrices of class uint8 or uint32 respectively.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: java_unsigned_autoconversion, java_convert_matrix,
     debug_java.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
Query or set the internal variable that controls how integer  classes are converted when Java matrix autoconversion is enabled.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
javafields


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 357
 -- Function File: javafields (JAVAOBJ)
 -- Function File: javafields ("CLASSNAME")
 -- Function File: FLD_NAMES = javafields (...)
     Return the fields of a Java object or Java class in the form of a
     cell array of strings.  If no output is requested, print the result
     to the standard output.

     See also: fieldnames, methods, javaObject.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
Return the fields of a Java object or Java class in the form of a  cell array of strings.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
javamethods


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 373
 -- Function File: javamethods (JAVAOBJ)
 -- Function File: javamethods ("CLASSNAME")
 -- Function File: MTD_NAMES = javamethods (...)
     Return the methods of a Java object or Java class in the form of a
     cell array of strings.  If no output is requested, print the result
     to the standard output.

     See also: methods, fieldnames, javaMethod, javaObject.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Return the methods of a Java object or Java class in the form of a  cell array of strings.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
polyderiv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 605
 -- Function File: polyderiv (P)
 -- Function File: [K] = polyderiv (A, B)
 -- Function File: [Q, D] = polyderiv (B, A)
     Return the coefficients of the derivative of the polynomial whose
     coefficients are given by the vector P.  If a pair of polynomials
     is given, return the derivative of the product A*B.  If two inputs
     and two outputs are given, return the derivative of the polynomial
     quotient B/A.  The quotient numerator is in Q and the denominator
     in D.

     See also: poly, polyint, polyreduce, roots, conv, deconv, residue,
     filter, polygcd, polyval, polyvalm.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 106
Return the coefficients of the derivative of the polynomial whose  coefficients are given by the vector P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
re_read_readline_init_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 189
 -- Built-in Function: re_read_readline_init_file (FILE)
     This function has been deprecated.  Use
     'readline_re_read_init_file' instead.

     See also: readline_read_init_file.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
This function has been deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
read_readline_init_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 183
 -- Built-in Function: read_readline_init_file (FILE)
     This function has been deprecated.  Use 'readline_read_init_file'
     instead.

     See also: readline_read_init_file.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
This function has been deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
saving_history


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 264
 -- Built-in Function: VAL = saving_history ()
 -- Built-in Function: OLD_VAL = saving_history (NEW_VAL)
 -- Built-in Function: saving_history (NEW_VAL, "local")
     This function has been deprecated.  Use 'history_save' instead.

     See also: history_save.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
This function has been deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
shell_cmd "


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1570
 -- Built-in Function: shell_cmd (STRING)
 -- Built-in Function: shell_cmd (STRING, RETURN_OUTPUT)
 -- Built-in Function: shell_cmd (STRING, RETURN_OUTPUT, TYPE)
 -- Built-in Function: [STATUS, OUTPUT] = shell_cmd (...)
 -- Built-in Function: [STATUS, OUTPUT] = shell_cmd (STRING,
          RETURN_OUTPUT, TYPE)
     Execute a shell command specified by STRING.  If the optional
     argument TYPE is "async", the process is started in the background
     and the process id of the child process is returned immediately.
     Otherwise, the process is started and Octave waits until it exits.
     If the TYPE argument is omitted, it defaults to a value of "sync".

     If the optional argument RETURN_OUTPUT is true and the subprocess
     is started synchronously, or if SHELL_CMD is called with one input
     argument and one or more output arguments, then the output from the
     command is returned.  Otherwise, if the subprocess is executed
     synchronously, its output is sent to the standard output.

     The 'shell_cmd' function can return two values.  The first is the
     exit status of the command and the second is any output from the
     command that was written to the standard output stream.  For
     example,

          [status, output] = shell_cmd ("echo foo; exit 2");

     will set the variable 'output' to the string 'foo', and the
     variable 'status' to the integer '2'.

     For commands run asynchronously, STATUS is the process id of the
     command shell that is started to run the command.

     See also: system, unix, dos.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
RETURN_OUTPUT, TYPE)  Execute a shell command specified by STRING.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
studentize


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 342
 -- Function File: studentize (X)
 -- Function File: studentize (X, DIM)
     If X is a vector, subtract its mean and divide by its standard
     deviation.

     If X is a matrix, do the above along the first non-singleton
     dimension.  If the optional argument DIM is given, operate along
     this dimension.

     See also: center.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
If X is a vector, subtract its mean and divide by its standard  deviation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
sylvester_matrix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 128
 -- Function File: sylvester_matrix (K)
     Return the Sylvester matrix of order n = 2^K.

     See also: toeplitz, hankel.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Return the Sylvester matrix of order n = 2^K.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
acosd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
 -- Function File: acosd (X)
     Compute the inverse cosine in degrees for each element of X.

     See also: cosd, acos.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Compute the inverse cosine in degrees for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
acot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 131
 -- Mapping Function: acot (X)
     Compute the inverse cotangent in radians for each element of X.

     See also: cot, acotd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Compute the inverse cotangent in radians for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
acotd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
 -- Function File: acotd (X)
     Compute the inverse cotangent in degrees for each element of X.

     See also: cotd, acot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Compute the inverse cotangent in degrees for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
acoth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
 -- Mapping Function: acoth (X)
     Compute the inverse hyperbolic cotangent of each element of X.

     See also: coth.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Compute the inverse hyperbolic cotangent of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
acsc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 130
 -- Mapping Function: acsc (X)
     Compute the inverse cosecant in radians for each element of X.

     See also: csc, acscd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Compute the inverse cosecant in radians for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
acscd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 128
 -- Function File: acscd (X)
     Compute the inverse cosecant in degrees for each element of X.

     See also: cscd, acsc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Compute the inverse cosecant in degrees for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
acsch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
 -- Mapping Function: acsch (X)
     Compute the inverse hyperbolic cosecant of each element of X.

     See also: csch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Compute the inverse hyperbolic cosecant of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
asec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 128
 -- Mapping Function: asec (X)
     Compute the inverse secant in radians for each element of X.

     See also: sec, asecd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Compute the inverse secant in radians for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
asecd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
 -- Function File: asecd (X)
     Compute the inverse secant in degrees for each element of X.

     See also: secd, asec.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Compute the inverse secant in degrees for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
asech


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 122
 -- Mapping Function: asech (X)
     Compute the inverse hyperbolic secant of each element of X.

     See also: sech.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Compute the inverse hyperbolic secant of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
asind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
 -- Function File: asind (X)
     Compute the inverse sine in degrees for each element of X.

     See also: sind, asin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Compute the inverse sine in degrees for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
atan2d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 149
 -- Function File: atan2d (Y, X)
     Compute atan2 (Y / X) in degrees for corresponding elements from Y
     and X.

     See also: tand, atan2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Compute atan2 (Y / X) in degrees for corresponding elements from Y  and X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
atand


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
 -- Function File: atand (X)
     Compute the inverse tangent in degrees for each element of X.

     See also: tand, atan.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Compute the inverse tangent in degrees for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cosd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 183
 -- Function File: cosd (X)
     Compute the cosine for each element of X in degrees.  Returns zero
     for elements where '(X-90)/180' is an integer.

     See also: acosd, cos.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute the cosine for each element of X in degrees.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
cot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 128
 -- Mapping Function: cot (X)
     Compute the cotangent for each element of X in radians.

     See also: acot, cotd, coth.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Compute the cotangent for each element of X in radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cotd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 120
 -- Function File: cotd (X)
     Compute the cotangent for each element of X in degrees.

     See also: acotd, cot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Compute the cotangent for each element of X in degrees.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
coth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
 -- Mapping Function: coth (X)
     Compute the hyperbolic cotangent of each element of X.

     See also: acoth.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Compute the hyperbolic cotangent of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
csc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
 -- Mapping Function: csc (X)
     Compute the cosecant for each element of X in radians.

     See also: acsc, cscd, csch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Compute the cosecant for each element of X in radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cscd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 119
 -- Function File: cscd (X)
     Compute the cosecant for each element of X in degrees.

     See also: acscd, csc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Compute the cosecant for each element of X in degrees.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
csch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
 -- Mapping Function: csch (X)
     Compute the hyperbolic cosecant of each element of X.

     See also: acsch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute the hyperbolic cosecant of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
sec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
 -- Mapping Function: sec (X)
     Compute the secant for each element of X in radians.

     See also: asec, secd, sech.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute the secant for each element of X in radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
secd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
 -- Function File: secd (X)
     Compute the secant for each element of X in degrees.

     See also: asecd, sec.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute the secant for each element of X in degrees.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sech


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
 -- Mapping Function: sech (X)
     Compute the hyperbolic secant of each element of X.

     See also: asech.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Compute the hyperbolic secant of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 176
 -- Function File: sind (X)
     Compute the sine for each element of X in degrees.  Returns zero
     for elements where 'X/180' is an integer.

     See also: asind, sin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute the sine for each element of X in degrees.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
tand


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 240
 -- Function File: tand (X)
     Compute the tangent for each element of X in degrees.  Returns zero
     for elements where 'X/180' is an integer and 'Inf' for elements
     where '(X-90)/180' is an integer.

     See also: atand, tan.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute the tangent for each element of X in degrees.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
accumarray


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4101
 -- Function File: accumarray (SUBS, VALS, SZ, FUNC, FILLVAL, ISSPARSE)
 -- Function File: accumarray (SUBS, VALS, ...)

     Create an array by accumulating the elements of a vector into the
     positions defined by their subscripts.  The subscripts are defined
     by the rows of the matrix SUBS and the values by VALS.  Each row of
     SUBS corresponds to one of the values in VALS.  If VALS is a
     scalar, it will be used for each of the row of SUBS.  If SUBS is a
     cell array of vectors, all vectors must be of the same length, and
     the subscripts in the Kth vector must correspond to the Kth
     dimension of the result.

     The size of the matrix will be determined by the subscripts
     themselves.  However, if SZ is defined it determines the matrix
     size.  The length of SZ must correspond to the number of columns in
     SUBS.  An exception is if SUBS has only one column, in which case
     SZ may be the dimensions of a vector and the subscripts of SUBS are
     taken as the indices into it.

     The default action of 'accumarray' is to sum the elements with the
     same subscripts.  This behavior can be modified by defining the
     FUNC function.  This should be a function or function handle that
     accepts a column vector and returns a scalar.  The result of the
     function should not depend on the order of the subscripts.

     The elements of the returned array that have no subscripts
     associated with them are set to zero.  Defining FILLVAL to some
     other value allows these values to be defined.  This behavior
     changes, however, for certain values of FUNC.  If FUNC is 'min'
     (respectively, 'max') then the result will be filled with the
     minimum (respectively, maximum) integer if VALS is of integral
     type, logical false (respectively, logical true) if VALS is of
     logical type, zero if FILLVAL is zero and all values are
     non-positive (respectively, non-negative), and NaN otherwise.

     By default 'accumarray' returns a full matrix.  If ISSPARSE is
     logically true, then a sparse matrix is returned instead.

     The following 'accumarray' example constructs a frequency table
     that in the first column counts how many occurrences each number in
     the second column has, taken from the vector X.  Note the usage of
     'unique' for assigning to all repeated elements of X the same index
     (*note unique: XREFunique.).

          X = [91, 92, 90, 92, 90, 89, 91, 89, 90, 100, 100, 100];
          [U, ~, J] = unique (X);
          [accumarray(J', 1), U']
            =>  2    89
                3    90
                2    91
                2    92
                3   100

     Another example, where the result is a multi-dimensional 3-D array
     and the default value (zero) appears in the output:

          accumarray ([1, 1, 1;
                       2, 1, 2;
                       2, 3, 2;
                       2, 1, 2;
                       2, 3, 2], 101:105)
          => ans(:,:,1) = [101, 0, 0; 0, 0, 0]
          => ans(:,:,2) = [0, 0, 0; 206, 0, 208]

     The sparse option can be used as an alternative to the 'sparse'
     constructor (*note sparse: XREFsparse.).  Thus

          sparse (I, J, SV)

     can be written with 'accumarray' as

          accumarray ([I, J], SV', [], [], 0, true)

     For repeated indices, 'sparse' adds the corresponding value.  To
     take the minimum instead, use 'min' as an accumulator function:

          accumarray ([I, J], SV', [], @min, 0, true)

     The complexity of accumarray in general for the non-sparse case is
     generally O(M+N), where N is the number of subscripts and M is the
     maximum subscript (linearized in multi-dimensional case).  If FUNC
     is one of '@sum' (default), '@max', '@min' or '@(x) {x}', an
     optimized code path is used.  Note that for general reduction
     function the interpreter overhead can play a major part and it may
     be more efficient to do multiple accumarray calls and compute the
     results in a vectorized manner.

     See also: accumdim, unique, sparse.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
Create an array by accumulating the elements of a vector into the  positions defined by their subscripts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
accumdim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1650
 -- Function File: accumdim (SUBS, VALS, DIM, N, FUNC, FILLVAL)
     Create an array by accumulating the slices of an array into the
     positions defined by their subscripts along a specified dimension.
     The subscripts are defined by the index vector SUBS.  The dimension
     is specified by DIM.  If not given, it defaults to the first
     non-singleton dimension.  The length of SUBS must be equal to 'size
     (VALS, DIM)'.

     The extent of the result matrix in the working dimension will be
     determined by the subscripts themselves.  However, if N is defined
     it determines this extent.

     The default action of 'accumdim' is to sum the subarrays with the
     same subscripts.  This behavior can be modified by defining the
     FUNC function.  This should be a function or function handle that
     accepts an array and a dimension, and reduces the array along this
     dimension.  As a special exception, the built-in 'min' and 'max'
     functions can be used directly, and 'accumdim' accounts for the
     middle empty argument that is used in their calling.

     The slices of the returned array that have no subscripts associated
     with them are set to zero.  Defining FILLVAL to some other value
     allows these values to be defined.

     An example of the use of 'accumdim' is:

          accumdim ([1, 2, 1, 2, 1], [ 7, -10,   4;
                                      -5, -12,   8;
                                     -12,   2,   8;
                                     -10,   9,  -3;
                                      -5,  -3, -13])
          => [-10,-11,-1;-15,-3,5]

     See also: accumarray.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 131
Create an array by accumulating the slices of an array into the  positions defined by their subscripts along a specified dimension.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bicubic


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 356
 -- Function File: ZI = bicubic (X, Y, Z, XI, YI, EXTRAPVAL)

     Return a matrix ZI corresponding to the bicubic interpolations at
     XI and YI of the data supplied as X, Y and Z.  Points outside the
     grid are set to EXTRAPVAL.

     See <http://wiki.woodpecker.org.cn/moin/Octave/Bicubic> for further
     information.

     See also: interp2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Return a matrix ZI corresponding to the bicubic interpolations at  XI and YI of the data supplied as X, Y and Z.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
bincoeff


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 512
 -- Mapping Function: bincoeff (N, K)
     Return the binomial coefficient of N and K, defined as

           /   \
           | n |    n (n-1) (n-2) ... (n-k+1)
           |   |  = -------------------------
           | k |               k!
           \   /

     For example:

          bincoeff (5, 2)
             => 10

     In most cases, the 'nchoosek' function is faster for small scalar
     integer arguments.  It also warns about loss of precision for big
     arguments.

     See also: nchoosek.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Return the binomial coefficient of N and K, defined as 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bitcmp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 372
 -- Function File: bitcmp (A, K)
     Return the K-bit complement of integers in A.  If K is omitted 'k =
     log2 (bitmax) + 1' is assumed.

          bitcmp (7,4)
            => 8
          dec2bin (11)
            => 1011
          dec2bin (bitcmp (11, 6))
            => 110100

     See also: bitand, bitor, bitxor, bitset, bitget, bitcmp, bitshift,
     bitmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Return the K-bit complement of integers in A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bitget


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 284
 -- Function File: C = bitget (A, N)
     Return the status of bit(s) N of unsigned integers in A the lowest
     significant bit is N = 1.

          bitget (100, 8:-1:1)
          => 0  1  1  0  0  1  0  0

     See also: bitand, bitor, bitxor, bitset, bitcmp, bitshift, bitmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Return the status of bit(s) N of unsigned integers in A the lowest  significant bit is N = 1.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bitset


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 405
 -- Function File: C = bitset (A, N)
 -- Function File: C = bitset (A, N, VAL)
     Set or reset bit(s) N of unsigned integers in A.  VAL = 0 resets
     and VAL = 1 sets the bits.  The lowest significant bit is: N = 1.
     All variables must be the same size or scalars.

          dec2bin (bitset (10, 1))
            => 1011

     See also: bitand, bitor, bitxor, bitget, bitcmp, bitshift, bitmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Set or reset bit(s) N of unsigned integers in A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
blkdiag


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 303
 -- Function File: blkdiag (A, B, C, ...)
     Build a block diagonal matrix from A, B, C, ... All the arguments
     must be numeric and are two-dimensional matrices or scalars.  If
     any argument is of type sparse, the output will also be sparse.

     See also: diag, horzcat, vertcat, sparse.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Build a block diagonal matrix from A, B, C, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cart2pol


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 801
 -- Function File: [THETA, R] = cart2pol (X, Y)
 -- Function File: [THETA, R, Z] = cart2pol (X, Y, Z)
 -- Function File: [THETA, R] = cart2pol (C)
 -- Function File: [THETA, R, Z] = cart2pol (C)
 -- Function File: P = cart2pol (...)

     Transform Cartesian to polar or cylindrical coordinates.

     THETA describes the angle relative to the positive x-axis.  R is
     the distance to the z-axis (0, 0, z).  X, Y (, and Z) must be the
     same shape, or scalar.  If called with a single matrix argument
     then each row of C represents the Cartesian coordinate (X, Y (,
     Z)).

     If only a single return argument is requested then return a matrix
     P where each row represents one polar/(cylindrical) coordinate
     (THETA, PHI (, Z)).

     See also: pol2cart, cart2sph, sph2cart.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Transform Cartesian to polar or cylindrical coordinates.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cart2sph


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 724
 -- Function File: [THETA, PHI, R] = cart2sph (X, Y, Z)
 -- Function File: [THETA, PHI, R] = cart2sph (C)
 -- Function File: S = cart2sph (...)
     Transform Cartesian to spherical coordinates.

     THETA describes the angle relative to the positive x-axis.  PHI is
     the angle relative to the xy-plane.  R is the distance to the
     origin (0, 0, 0).  X, Y, and Z must be the same shape, or scalar.
     If called with a single matrix argument then each row of C
     represents the Cartesian coordinate (X, Y, Z).

     If only a single return argument is requested then return a matrix
     S where each row represents one spherical coordinate (THETA, PHI,
     R).

     See also: sph2cart, cart2pol, pol2cart.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Transform Cartesian to spherical coordinates.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cell2mat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 332
 -- Function File: M = cell2mat (C)
     Convert the cell array C into a matrix by concatenating all
     elements of C into a hyperrectangle.  Elements of C must be
     numeric, logical, or char matrices; or cell arrays; or structs; and
     'cat' must be able to concatenate them together.

     See also: mat2cell, num2cell.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Convert the cell array C into a matrix by concatenating all  elements of C into a hyperrectangle.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
celldisp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 557
 -- Function File: celldisp (C)
 -- Function File: celldisp (C, NAME)
     Recursively display the contents of a cell array.  By default the
     values are displayed with the name of the variable C.  However,
     this name can be replaced with the variable NAME.  For example:

          c = {1, 2, {31, 32}};
          celldisp (c, "b")
             =>
                b{1} =
                 1
                b{2} =
                 2
                b{3}{1} =
                 31
                b{3}{2} =
                 32

     See also: disp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Recursively display the contents of a cell array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
chop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 339
 -- Function File: chop (X, NDIGITS, BASE)
     Truncate elements of X to a length of NDIGITS such that the
     resulting numbers are exactly divisible by BASE.  If BASE is not
     specified it defaults to 10.

          chop (-pi, 5, 10)
             => -3.14200000000000
          chop (-pi, 5, 5)
             => -3.14150000000000
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
Truncate elements of X to a length of NDIGITS such that the  resulting numbers are exactly divisible by BASE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
circshift


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 791
 -- Function File: Y = circshift (X, N)
     Circularly shift the values of the array X.  N must be a vector of
     integers no longer than the number of dimensions in X.  The values
     of N can be either positive or negative, which determines the
     direction in which the values or X are shifted.  If an element of N
     is zero, then the corresponding dimension of X will not be shifted.
     For example:

          x = [1, 2, 3; 4, 5, 6; 7, 8, 9];
          circshift (x, 1)
          =>  7, 8, 9
              1, 2, 3
              4, 5, 6
          circshift (x, -2)
          =>  7, 8, 9
              1, 2, 3
              4, 5, 6
          circshift (x, [0,1])
          =>  3, 1, 2
              6, 4, 5
              9, 7, 8

     See also: permute, ipermute, shiftdim.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Circularly shift the values of the array X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
common_size


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 644
 -- Function File: [ERR, Y1, ...] = common_size (X1, ...)
     Determine if all input arguments are either scalar or of common
     size.  If so, ERR is zero, and YI is a matrix of the common size
     with all entries equal to XI if this is a scalar or XI otherwise.
     If the inputs cannot be brought to a common size, ERR is 1, and YI
     is XI.  For example:

          [errorcode, a, b] = common_size ([1 2; 3 4], 5)
               => errorcode = 0
               => a = [ 1, 2; 3, 4 ]
               => b = [ 5, 5; 5, 5 ]

     This is useful for implementing functions where arguments can
     either be scalars or of common size.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Determine if all input arguments are either scalar or of common  size.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cplxpair


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 959
 -- Function File: cplxpair (Z)
 -- Function File: cplxpair (Z, TOL)
 -- Function File: cplxpair (Z, TOL, DIM)
     Sort the numbers Z into complex conjugate pairs ordered by
     increasing real part.  Place the negative imaginary complex number
     first within each pair.  Place all the real numbers (those with
     'abs (imag (Z) / Z) < TOL)') after the complex pairs.

     If TOL is unspecified the default value is 100*'eps'.

     By default the complex pairs are sorted along the first
     non-singleton dimension of Z.  If DIM is specified, then the
     complex pairs are sorted along this dimension.

     Signal an error if some complex numbers could not be paired.
     Signal an error if all complex numbers are not exact conjugates (to
     within TOL).  Note that there is no defined order for pairs with
     identical real parts but differing imaginary parts.

          cplxpair (exp(2i*pi*[0:4]'/5)) == exp(2i*pi*[3; 2; 4; 1; 0]/5)
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 81
Sort the numbers Z into complex conjugate pairs ordered by  increasing real part.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cumtrapz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 987
 -- Function File: Q = cumtrapz (Y)
 -- Function File: Q = cumtrapz (X, Y)
 -- Function File: Q = cumtrapz (..., DIM)

     Cumulative numerical integration of points Y using the trapezoidal
     method.  'cumtrapz (Y)' computes the cumulative integral of Y along
     the first non-singleton dimension.  Where 'trapz' reports only the
     overall integral sum, 'cumtrapz' reports the current partial sum
     value at each point of Y.  When the argument X is omitted an
     equally spaced X vector with unit spacing (1) is assumed.
     'cumtrapz (X, Y)' evaluates the integral with respect to the
     spacing in X and the values in Y.  This is useful if the points in
     Y have been sampled unevenly.  If the optional DIM argument is
     given, operate along this dimension.

     If X is not specified then unit spacing will be used.  To scale the
     integral to the correct value you must multiply by the actual
     spacing value (deltaX).

     See also: trapz, cumsum.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Cumulative numerical integration of points Y using the trapezoidal  method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
curl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1017
 -- Function File: [CX, CY, CZ, V] = curl (X, Y, Z, FX, FY, FZ)
 -- Function File: [CZ, V] = curl (X, Y, FX, FY)
 -- Function File: [...] = curl (FX, FY, FZ)
 -- Function File: [...] = curl (FX, FY)
 -- Function File: V = curl (...)
     Calculate curl of vector field given by the arrays FX, FY, and FZ
     or FX, FY respectively.

                            / d         d       d         d       d         d     \
          curl F(x,y,z)  =  | -- Fz  -  -- Fy,  -- Fx  -  -- Fz,  -- Fy  -  -- Fx |
                            \ dy        dz      dz        dx      dx        dy    /

     The coordinates of the vector field can be given by the arguments
     X, Y, Z or X, Y respectively.  V calculates the scalar component of
     the angular velocity vector in direction of the z-axis for
     two-dimensional input.  For three-dimensional input the scalar
     rotation is calculated at each grid point in direction of the
     vector field at that point.

     See also: divergence, gradient, del2, cross.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Calculate curl of vector field given by the arrays FX, FY, and FZ  or FX, FY respectively.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dblquad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1248
 -- Function File: dblquad (F, XA, XB, YA, YB)
 -- Function File: dblquad (F, XA, XB, YA, YB, TOL)
 -- Function File: dblquad (F, XA, XB, YA, YB, TOL, QUADF)
 -- Function File: dblquad (F, XA, XB, YA, YB, TOL, QUADF, ...)
     Numerically evaluate the double integral of F.  F is a function
     handle, inline function, or string containing the name of the
     function to evaluate.  The function F must have the form z = f(x,y)
     where X is a vector and Y is a scalar.  It should return a vector
     of the same length and orientation as X.

     XA, YA and XB, YB are the lower and upper limits of integration for
     x and y respectively.  The underlying integrator determines whether
     infinite bounds are accepted.

     The optional argument TOL defines the absolute tolerance used to
     integrate each sub-integral.  The default value is 1e^{-6}.

     The optional argument QUADF specifies which underlying integrator
     function to use.  Any choice but 'quad' is available and the
     default is 'quadcc'.

     Additional arguments, are passed directly to F.  To use the default
     value for TOL or QUADF one may pass ':' or an empty matrix ([]).

     See also: triplequad, quad, quadv, quadl, quadgk, quadcc, trapz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Numerically evaluate the double integral of F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
deal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 507
 -- Function File: [R1, R2, ..., RN] = deal (A)
 -- Function File: [R1, R2, ..., RN] = deal (A1, A2, ..., AN)

     Copy the input parameters into the corresponding output parameters.
     If only one input parameter is supplied, its value is copied to
     each of the outputs.

     For example,

          [a, b, c] = deal (x, y, z);

     is equivalent to

          a = x;
          b = y;
          c = z;

     and

          [a, b, c] = deal (x);

     is equivalent to

          a = b = c = x;
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Copy the input parameters into the corresponding output parameters.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
del2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1187
 -- Function File: D = del2 (M)
 -- Function File: D = del2 (M, H)
 -- Function File: D = del2 (M, DX, DY, ...)

     Calculate the discrete Laplace operator.  For a 2-dimensional
     matrix M this is defined as

                1    / d^2            d^2         \
          D  = --- * | ---  M(x,y) +  ---  M(x,y) |
                4    \ dx^2           dy^2        /

     For N-dimensional arrays the sum in parentheses is expanded to
     include second derivatives over the additional higher dimensions.

     The spacing between evaluation points may be defined by H, which is
     a scalar defining the equidistant spacing in all dimensions.
     Alternatively, the spacing in each dimension may be defined
     separately by DX, DY, etc.  A scalar spacing argument defines
     equidistant spacing, whereas a vector argument can be used to
     specify variable spacing.  The length of the spacing vectors must
     match the respective dimension of M.  The default spacing value is
     1.

     At least 3 data points are needed for each dimension.  Boundary
     points are calculated from the linear extrapolation of interior
     points.

     See also: gradient, diff.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Calculate the discrete Laplace operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
display


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 326
 -- Function File: display (A)
     Display the contents of an object.  If A is an object of the class
     "myclass", then 'display' is called in a case like

          myclass (...)

     where Octave is required to display the contents of a variable of
     the type "myclass".

     See also: class, subsref, subsasgn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Display the contents of an object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
divergence


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 662
 -- Function File: DIV = divergence (X, Y, Z, FX, FY, FZ)
 -- Function File: DIV = divergence (FX, FY, FZ)
 -- Function File: DIV = divergence (X, Y, FX, FY)
 -- Function File: DIV = divergence (FX, FY)
     Calculate divergence of a vector field given by the arrays FX, FY,
     and FZ or FX, FY respectively.

                            d               d               d
          div F(x,y,z)  =   -- F(x,y,z)  +  -- F(x,y,z)  +  -- F(x,y,z)
                            dx              dy              dz

     The coordinates of the vector field can be given by the arguments
     X, Y, Z or X, Y respectively.

     See also: curl, gradient, del2, dot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Calculate divergence of a vector field given by the arrays FX, FY,  and FZ or FX, FY respectively.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
fieldnames


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 696
 -- Function File: NAMES = fieldnames (STRUCT)
 -- Function File: NAMES = fieldnames (OBJ)
 -- Function File: NAMES = fieldnames (JAVAOBJ)
 -- Function File: NAMES = fieldnames ("JCLASSNAME")
     Return a cell array of strings with the names of the fields in the
     specified input.

     When the input is a structure STRUCT, the names are the elements of
     the structure.

     When the input is an Octave object OBJ, the names are the public
     properties of the object.

     When the input is a Java object JAVAOBJ or Java classname
     JCLASSNAME the name are the public data elements of the object or
     class.

     See also: nfields, isfield, orderfields, struct, methods.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Return a cell array of strings with the names of the fields in the  specified input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
flipdim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 332
 -- Function File: flipdim (X)
 -- Function File: flipdim (X, DIM)
     Return a copy of X flipped about the dimension DIM.  DIM defaults
     to the first non-singleton dimension.  For example:

          flipdim ([1, 2; 3, 4], 2)
                =>  2  1
                    4  3

     See also: fliplr, flipud, rot90, rotdim.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return a copy of X flipped about the dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fliplr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 418
 -- Function File: fliplr (X)
     Return a copy of X with the order of the columns reversed.  In
     other words, X is flipped left-to-right about a vertical axis.  For
     example:

          fliplr ([1, 2; 3, 4])
               =>  2  1
                   4  3

     Note that 'fliplr' only works with 2-D arrays.  To flip N-D arrays
     use 'flipdim' instead.

     See also: flipud, flipdim, rot90, rotdim.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Return a copy of X with the order of the columns reversed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
flipud


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 415
 -- Function File: flipud (X)
     Return a copy of X with the order of the rows reversed.  In other
     words, X is flipped upside-down about a horizontal axis.  For
     example:

          flipud ([1, 2; 3, 4])
               =>  3  4
                   1  2

     Note that 'flipud' only works with 2-D arrays.  To flip N-D arrays
     use 'flipdim' instead.

     See also: fliplr, flipdim, rot90, rotdim.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Return a copy of X with the order of the rows reversed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
gradient


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1879
 -- Function File: DX = gradient (M)
 -- Function File: [DX, DY, DZ, ...] = gradient (M)
 -- Function File: [...] = gradient (M, S)
 -- Function File: [...] = gradient (M, X, Y, Z, ...)
 -- Function File: [...] = gradient (F, X0)
 -- Function File: [...] = gradient (F, X0, S)
 -- Function File: [...] = gradient (F, X0, X, Y, ...)

     Calculate the gradient of sampled data or a function.  If M is a
     vector, calculate the one-dimensional gradient of M.  If M is a
     matrix the gradient is calculated for each dimension.

     '[DX, DY] = gradient (M)' calculates the one dimensional gradient
     for X and Y direction if M is a matrix.  Additional return
     arguments can be use for multi-dimensional matrices.

     A constant spacing between two points can be provided by the S
     parameter.  If S is a scalar, it is assumed to be the spacing for
     all dimensions.  Otherwise, separate values of the spacing can be
     supplied by the X, ... arguments.  Scalar values specify an
     equidistant spacing.  Vector values for the X, ... arguments
     specify the coordinate for that dimension.  The length must match
     their respective dimension of M.

     At boundary points a linear extrapolation is applied.  Interior
     points are calculated with the first approximation of the numerical
     gradient

          y'(i) = 1/(x(i+1)-x(i-1)) * (y(i-1)-y(i+1)).

     If the first argument F is a function handle, the gradient of the
     function at the points in X0 is approximated using central
     difference.  For example, 'gradient (@cos, 0)' approximates the
     gradient of the cosine function in the point x0 = 0.  As with
     sampled data, the spacing values between the points from which the
     gradient is estimated can be set via the S or DX, DY, ...
     arguments.  By default a spacing of 1 is used.

     See also: diff, del2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Calculate the gradient of sampled data or a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
idivide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1387
 -- Function File: idivide (X, Y, OP)
     Integer division with different rounding rules.

     The standard behavior of integer division such as 'A ./ B' is to
     round the result to the nearest integer.  This is not always the
     desired behavior and 'idivide' permits integer element-by-element
     division to be performed with different treatment for the
     fractional part of the division as determined by the OP flag.  OP
     is a string with one of the values:

     "fix"
          Calculate 'A ./ B' with the fractional part rounded towards
          zero.

     "round"
          Calculate 'A ./ B' with the fractional part rounded towards
          the nearest integer.

     "floor"
          Calculate 'A ./ B' with the fractional part rounded towards
          negative infinity.

     "ceil"
          Calculate 'A ./ B' with the fractional part rounded towards
          positive infinity.

     If OP is not given it defaults to "fix".  An example demonstrating
     these rounding rules is

          idivide (int8 ([-3, 3]), int8 (4), "fix")
            => int8 ([0, 0])
          idivide (int8 ([-3, 3]), int8 (4), "round")
            => int8 ([-1, 1])
          idivide (int8 ([-3, 3]), int8 (4), "floor")
            => int8 ([-1, 0])
          idivide (int8 ([-3, 3]), int8 (4), "ceil")
            => int8 ([0, 1])

     See also: ldivide, rdivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Integer division with different rounding rules.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
int2str


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 707
 -- Function File: int2str (N)
     Convert an integer (or array of integers) to a string (or a
     character array).

          int2str (123)
               => "123"

          s = int2str ([1, 2, 3; 4, 5, 6])
               => s =
                  1  2  3
                  4  5  6

          whos s
               =>
                Attr Name        Size                     Bytes  Class
                ==== ====        ====                     =====  =====
                     s           2x7                         14  char

     This function is not very flexible.  For better control over the
     results, use 'sprintf' (*note Formatted Output::).

     See also: sprintf, num2str, mat2str.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Convert an integer (or array of integers) to a string (or a  character array).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
interp1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3061
 -- Function File: YI = interp1 (X, Y, XI)
 -- Function File: YI = interp1 (Y, XI)
 -- Function File: YI = interp1 (..., METHOD)
 -- Function File: YI = interp1 (..., EXTRAP)
 -- Function File: YI = interp1 (..., "left")
 -- Function File: YI = interp1 (..., "right")
 -- Function File: PP = interp1 (..., "pp")

     One-dimensional interpolation.

     Interpolate input data to determine the value of YI at the points
     XI.  If not specified, X is taken to be the indices of Y.  If Y is
     a matrix or an N-dimensional array, the interpolation is performed
     on each column of Y.

     Method is one of:

     "nearest"
          Return the nearest neighbor

     "linear"
          Linear interpolation from nearest neighbors

     "pchip"
          Piecewise cubic Hermite interpolating polynomial

     "cubic"
          Cubic interpolation (same as 'pchip')

     "spline"
          Cubic spline interpolation--smooth first and second
          derivatives throughout the curve

     Adding '*' to the start of any method above forces 'interp1' to
     assume that X is uniformly spaced, and only 'X(1)' and 'X(2)' are
     referenced.  This is usually faster, and is never slower.  The
     default method is "linear".

     If EXTRAP is the string "extrap", then extrapolate values beyond
     the endpoints using the current METHOD.  If EXTRAP is a number,
     then replace values beyond the endpoints with that number.  When
     unspecified, EXTRAP defaults to NA.

     If the string argument "pp" is specified, then XI should not be
     supplied and 'interp1' returns a piecewise polynomial object.  This
     object can later be used with 'ppval' to evaluate the
     interpolation.  There is an equivalence, such that 'ppval (interp1
     (X, Y, METHOD, "pp"), XI) == interp1 (X, Y, XI, METHOD, "extrap")'.

     Duplicate points in X specify a discontinuous interpolant.  There
     may be at most 2 consecutive points with the same value.  If X is
     increasing, the default discontinuous interpolant is
     right-continuous.  If X is decreasing, the default discontinuous
     interpolant is left-continuous.  The continuity condition of the
     interpolant may be specified by using the options, "left" or
     "right", to select a left-continuous or right-continuous
     interpolant, respectively.  Discontinuous interpolation is only
     allowed for "nearest" and "linear" methods; in all other cases, the
     X-values must be unique.

     An example of the use of 'interp1' is

          xf = [0:0.05:10];
          yf = sin (2*pi*xf/5);
          xp = [0:10];
          yp = sin (2*pi*xp/5);
          lin = interp1 (xp, yp, xf);
          spl = interp1 (xp, yp, xf, "spline");
          cub = interp1 (xp, yp, xf, "cubic");
          near = interp1 (xp, yp, xf, "nearest");
          plot (xf, yf, "r", xf, lin, "g", xf, spl, "b",
                xf, cub, "c", xf, near, "m", xp, yp, "r*");
          legend ("original", "linear", "spline", "cubic", "nearest");

     See also: interpft, interp2, interp3, interpn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
One-dimensional interpolation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
interp2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1831
 -- Function File: ZI = interp2 (X, Y, Z, XI, YI)
 -- Function File: ZI = interp2 (Z, XI, YI)
 -- Function File: ZI = interp2 (Z, N)
 -- Function File: ZI = interp2 (..., METHOD)
 -- Function File: ZI = interp2 (..., METHOD, EXTRAPVAL)

     Two-dimensional interpolation.  X, Y and Z describe a surface
     function.  If X and Y are vectors their length must correspondent
     to the size of Z.  X and Y must be monotonic.  If they are matrices
     they must have the 'meshgrid' format.

     'interp2 (X, Y, Z, XI, YI, ...)'
          Returns a matrix corresponding to the points described by the
          matrices XI, YI.

          If the last argument is a string, the interpolation method can
          be specified.  The method can be "linear", "nearest" or
          "cubic".  If it is omitted "linear" interpolation is assumed.

     'interp2 (Z, XI, YI)'
          Assumes 'X = 1:rows (Z)' and 'Y = 1:columns (Z)'

     'interp2 (Z, N)'
          Interleaves the matrix Z n-times.  If N is omitted a value of
          'N = 1' is assumed.

     The variable METHOD defines the method to use for the
     interpolation.  It can take one of the following values

     "nearest"
          Return the nearest neighbor.

     "linear"
          Linear interpolation from nearest neighbors.

     "pchip"
          Piecewise cubic Hermite interpolating polynomial.

     "cubic"
          Cubic interpolation from four nearest neighbors.

     "spline"
          Cubic spline interpolation--smooth first and second
          derivatives throughout the curve.

     If a scalar value EXTRAPVAL is defined as the final value, then
     values outside the mesh as set to this value.  Note that in this
     case METHOD must be defined as well.  If EXTRAPVAL is not defined
     then NA is assumed.

     See also: interp1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Two-dimensional interpolation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
interp3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1748
 -- Function File: VI = interp3 (X, Y, Z, V, XI, YI, ZI)
 -- Function File: VI = interp3 (V, XI, YI, ZI)
 -- Function File: VI = interp3 (V, M)
 -- Function File: VI = interp3 (V)
 -- Function File: VI = interp3 (..., METHOD)
 -- Function File: VI = interp3 (..., METHOD, EXTRAPVAL)

     Perform 3-dimensional interpolation.  Each element of the
     3-dimensional array V represents a value at a location given by the
     parameters X, Y, and Z.  The parameters X, X, and Z are either
     3-dimensional arrays of the same size as the array V in the
     "meshgrid" format or vectors.  The parameters XI, etc.  respect a
     similar format to X, etc., and they represent the points at which
     the array VI is interpolated.

     If X, Y, Z are omitted, they are assumed to be 'x = 1 : size (V,
     2)', 'y = 1 : size (V, 1)' and 'z = 1 : size (V, 3)'.  If M is
     specified, then the interpolation adds a point half way between
     each of the interpolation points.  This process is performed M
     times.  If only V is specified, then M is assumed to be '1'.

     Method is one of:

     "nearest"
          Return the nearest neighbor.

     "linear"
          Linear interpolation from nearest neighbors.

     "cubic"
          Cubic interpolation from four nearest neighbors (not
          implemented yet).

     "spline"
          Cubic spline interpolation--smooth first and second
          derivatives throughout the curve.

     The default method is "linear".

     If EXTRAP is the string "extrap", then extrapolate values beyond
     the endpoints.  If EXTRAP is a number, replace values beyond the
     endpoints with that number.  If EXTRAP is missing, assume NA.

     See also: interp1, interp2, spline, meshgrid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Perform 3-dimensional interpolation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
interpn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1692
 -- Function File: VI = interpn (X1, X2, ..., V, Y1, Y2, ...)
 -- Function File: VI = interpn (V, Y1, Y2, ...)
 -- Function File: VI = interpn (V, M)
 -- Function File: VI = interpn (V)
 -- Function File: VI = interpn (..., METHOD)
 -- Function File: VI = interpn (..., METHOD, EXTRAPVAL)

     Perform N-dimensional interpolation, where N is at least two.  Each
     element of the N-dimensional array V represents a value at a
     location given by the parameters X1, X2, ..., XN.  The parameters
     X1, X2, ..., XN are either N-dimensional arrays of the same size as
     the array V in the "ndgrid" format or vectors.  The parameters Y1,
     etc.  respect a similar format to X1, etc., and they represent the
     points at which the array VI is interpolated.

     If X1, ..., XN are omitted, they are assumed to be 'x1 = 1 : size
     (V, 1)', etc.  If M is specified, then the interpolation adds a
     point half way between each of the interpolation points.  This
     process is performed M times.  If only V is specified, then M is
     assumed to be '1'.

     Method is one of:

     "nearest"
          Return the nearest neighbor.

     "linear"
          Linear interpolation from nearest neighbors.

     "cubic"
          Cubic interpolation from four nearest neighbors (not
          implemented yet).

     "spline"
          Cubic spline interpolation--smooth first and second
          derivatives throughout the curve.

     The default method is "linear".

     If EXTRAPVAL is the scalar value, use it to replace the values
     beyond the endpoints with that number.  If EXTRAPVAL is missing,
     assume NA.

     See also: interp1, interp2, spline, ndgrid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Perform N-dimensional interpolation, where N is at least two.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
interpft


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 555
 -- Function File: interpft (X, N)
 -- Function File: interpft (X, N, DIM)

     Fourier interpolation.  If X is a vector, then X is resampled with
     N points.  The data in X is assumed to be equispaced.  If X is a
     matrix or an N-dimensional array, the interpolation is performed on
     each column of X.  If DIM is specified, then interpolate along the
     dimension DIM.

     'interpft' assumes that the interpolated function is periodic, and
     so assumptions are made about the endpoints of the interpolation.

     See also: interp1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Fourier interpolation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
isa


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 504
 -- Function File: isa (OBJ, CLASSNAME)
     Return true if OBJ is an object from the class CLASSNAME.

     CLASSNAME may also be one of the following class categories:

     "float"
          Floating point value comprising classes "double" and "single".

     "integer"
          Integer value comprising classes (u)int8, (u)int16, (u)int32,
          (u)int64.

     "numeric"
          Numeric value comprising either a floating point or integer
          value.

     See also: class, typeinfo.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Return true if OBJ is an object from the class CLASSNAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
iscolumn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 130
 -- Function File: iscolumn (X)
     Return true if X is a column vector.

     See also: isrow, isscalar, isvector, ismatrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Return true if X is a column vector.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
isdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 155
 -- Function File: isdir (F)
     Return true if F is a directory.

     See also: exist, stat, is_absolute_filename,
     is_rooted_relative_filename.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Return true if F is a directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isequal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 120
 -- Function File: isequal (X1, X2, ...)
     Return true if all of X1, X2, ... are equal.

     See also: isequaln.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Return true if all of X1, X2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isequaln


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 225
 -- Function File: isequaln (X1, X2, ...)
     Return true if all of X1, X2, ... are equal under the additional
     assumption that NaN == NaN (no comparison of NaN placeholders in
     dataset).

     See also: isequal.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Return true if all of X1, X2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
isrow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
 -- Function File: isrow (X)
     Return true if X is a row vector.

     See also: iscolumn, isscalar, isvector, ismatrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Return true if X is a row vector.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isscalar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 106
 -- Function File: isscalar (X)
     Return true if X is a scalar.

     See also: isvector, ismatrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Return true if X is a scalar.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
issquare


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
 -- Function File: issquare (X)
     Return true if X is a square matrix.

     See also: isscalar, isvector, ismatrix, size.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Return true if X is a square matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isvector


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 273
 -- Function File: isvector (X)
     Return true if X is a vector.  A vector is a 2-D array where one of
     the dimensions is equal to 1.  As a consequence a 1x1 array, or
     scalar, is also a vector.

     See also: isscalar, ismatrix, size, rows, columns, length.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Return true if X is a vector.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
loadobj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 500
 -- Function File: B = loadobj (A)
     Method of a class to manipulate an object after loading it from a
     file.  The function 'loadobj' is called when the object A is loaded
     using the 'load' function.  An example of the use of 'saveobj'
     might be to add fields to an object that don't make sense to be
     saved.  For example:

          function b = loadobj (a)
            b = a;
            b.addmissingfield = addfield (b);
          endfunction

     See also: saveobj, class.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Method of a class to manipulate an object after loading it from a  file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
logspace


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 546
 -- Function File: logspace (A, B)
 -- Function File: logspace (A, B, N)
 -- Function File: logspace (A, pi, N)
     Return a row vector with N elements logarithmically spaced from
     10^A to 10^B.  If N is unspecified it defaults to 50.

     If B is equal to pi, the points are between 10^A and pi, _not_ 10^A
     and 10^pi, in order to be compatible with the corresponding MATLAB
     function.

     Also for compatibility with MATLAB, return the second argument B if
     fewer than two values are requested.

     See also: linspace.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Return a row vector with N elements logarithmically spaced from  10^A to 10^B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
methods


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 319
 -- Function File: methods (OBJ)
 -- Function File: methods ("CLASSNAME")
 -- Function File: MTDS = methods (...)

     Return a cell array containing the names of the methods for the
     object OBJ or the named class CLASSNAME.  OBJ may be an Octave
     class object or a Java object.

     See also: fieldnames.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
Return a cell array containing the names of the methods for the  object OBJ or the named class CLASSNAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nargchk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 534
 -- Function File: MSGSTR = nargchk (MINARGS, MAXARGS, NARGS)
 -- Function File: MSGSTR = nargchk (MINARGS, MAXARGS, NARGS, "string")
 -- Function File: MSGSTRUCT = nargchk (MINARGS, MAXARGS, NARGS,
          "struct")
     Return an appropriate error message string (or structure) if the
     number of inputs requested is invalid.

     This is useful for checking to see that the number of input
     arguments supplied to a function is within an acceptable range.

     See also: nargoutchk, narginchk, error, nargin, nargout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
"struct")  Return an appropriate error message string (or structure) if the  number of inputs requested is invalid.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
narginchk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 536
 -- Function File: narginchk (MINARGS, MAXARGS)
     Check for correct number of arguments or generate an error message
     if the number of arguments in the calling function is outside the
     range MINARGS and MAXARGS.  Otherwise, do nothing.

     Both MINARGS and MAXARGS need to be scalar numeric values.  Zero,
     Inf and negative values are all allowed, and MINARGS and MAXARGS
     may be equal.

     Note that this function evaluates 'nargin' on the caller.

     See also: nargchk, nargoutchk, error, nargout, nargin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 161
Check for correct number of arguments or generate an error message  if the number of arguments in the calling function is outside the  range MINARGS and MAXARGS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
nargoutchk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1148
 -- Function File: nargoutchk (MINARGS, MAXARGS)
 -- Function File: MSGSTR = nargoutchk (MINARGS, MAXARGS, NARGS)
 -- Function File: MSGSTR = nargoutchk (MINARGS, MAXARGS, NARGS,
          "string")
 -- Function File: MSGSTRUCT = nargoutchk (MINARGS, MAXARGS, NARGS,
          "struct")
     Check for correct number of output arguments.

     On the first form, returns an error unless the number of arguments
     in its caller is between the values of MINARGS and MAXARGS.  It
     does nothing otherwise.  Note that this function evaluates the
     value of 'nargout' on the caller so its value must have not been
     tampered with.

     Both MINARGS and MAXARGS need to be a numeric scalar.  Zero, Inf
     and negative are all valid, and they can have the same value.

     For backward compatibility reasons, the other forms return an
     appropriate error message string (or structure) if the number of
     outputs requested is invalid.

     This is useful for checking to see that the number of output
     arguments supplied to a function is within an acceptable range.

     See also: nargchk, narginchk, error, nargout, nargin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
"string")  "struct")  Check for correct number of output arguments.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
nthargout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1272
 -- Function File: nthargout (N, FUNC, ...)
 -- Function File: nthargout (N, NTOT, FUNC, ...)
     Return the Nth output argument of function given by the function
     handle or string FUNC.  Any arguments after FUNC are passed to
     FUNC.  The total number of arguments to call FUNC with can be
     passed in NTOT; by default NTOT is N.  The input N can also be a
     vector of indices of the output, in which case the output will be a
     cell array of the requested output arguments.

     The intended use 'nthargout' is to avoid intermediate variables.
     For example, when finding the indices of the maximum entry of a
     matrix, the following two compositions of nthargout

          M = magic (5);
          cell2mat (nthargout ([1, 2], @ind2sub, size (M),
                               nthargout (2, @max, M(:))))
          => 5   3

     are completely equivalent to the following lines:

          M = magic (5);
          [~, idx] = max (M(:));
          [i, j] = ind2sub (size (M), idx);
          [i, j]
          => 5   3

     It can also be helpful to have all output arguments in a single
     cell in the following manner:

          USV = nthargout ([1:3], @svd, hilb (5));

     See also: nargin, nargout, varargin, varargout, isargout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
Return the Nth output argument of function given by the function  handle or string FUNC.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
nextpow2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 200
 -- Function File: nextpow2 (X)
     If X is a scalar, return the first integer N such that 2^n >= abs
     (x).

     If X is a vector, return 'nextpow2 (length (X))'.

     See also: pow2, log2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
If X is a scalar, return the first integer N such that 2^n >= abs  (x).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
num2str


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1466
 -- Function File: num2str (X)
 -- Function File: num2str (X, PRECISION)
 -- Function File: num2str (X, FORMAT)
     Convert a number (or array) to a string (or a character array).
     The optional second argument may either give the number of
     significant digits (PRECISION) to be used in the output or a format
     template string (FORMAT) as in 'sprintf' (*note Formatted
     Output::).  'num2str' can also handle complex numbers.

     Examples:

          num2str (123.456)
               => "123.46"

          num2str (123.456, 4)
               => "123.5"

          s = num2str ([1, 1.34; 3, 3.56], "%5.1f")
               => s =
                  1.0  1.3
                  3.0  3.6
          whos s
               =>
                Attr Name        Size                     Bytes  Class
                ==== ====        ====                     =====  =====
                     s           2x8                         16  char

          num2str (1.234 + 27.3i)
               => "1.234+27.3i"

     Notes:

     For MATLAB compatibility, leading spaces are stripped before
     returning the string.

     The 'num2str' function is not very flexible.  For better control
     over the results, use 'sprintf' (*note Formatted Output::).

     For complex X, the format string may only contain one output
     conversion specification and nothing else.  Otherwise, results will
     be unpredictable.

     See also: sprintf, int2str, mat2str.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Convert a number (or array) to a string (or a character array).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
pol2cart


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 788
 -- Function File: [X, Y] = pol2cart (THETA, R)
 -- Function File: [X, Y, Z] = pol2cart (THETA, R, Z)
 -- Function File: [X, Y] = pol2cart (P)
 -- Function File: [X, Y, Z] = pol2cart (P)
 -- Function File: C = pol2cart (...)
     Transform polar or cylindrical to Cartesian coordinates.

     THETA, R, (and Z) must be the same shape, or scalar.  THETA
     describes the angle relative to the positive x-axis.  R is the
     distance to the z-axis (0, 0, z).  If called with a single matrix
     argument then each row of P represents the polar/(cylindrical)
     coordinate (THETA, R (, Z)).

     If only a single return argument is requested then return a matrix
     C where each row represents one Cartesian coordinate (X, Y (, Z)).

     See also: cart2pol, sph2cart, cart2sph.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Transform polar or cylindrical to Cartesian coordinates.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
polyarea


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 498
 -- Function File: polyarea (X, Y)
 -- Function File: polyarea (X, Y, DIM)

     Determine area of a polygon by triangle method.  The variables X
     and Y define the vertex pairs, and must therefore have the same
     shape.  They can be either vectors or arrays.  If they are arrays
     then the columns of X and Y are treated separately and an area
     returned for each.

     If the optional DIM argument is given, then 'polyarea' works along
     this dimension of the arrays X and Y.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Determine area of a polygon by triangle method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
postpad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 534
 -- Function File: postpad (X, L)
 -- Function File: postpad (X, L, C)
 -- Function File: postpad (X, L, C, DIM)
     Append the scalar value C to the vector X until it is of length L.
     If C is not given, a value of 0 is used.

     If 'length (X) > L', elements from the end of X are removed until a
     vector of length L is obtained.

     If X is a matrix, elements are appended or removed from each row.

     If the optional argument DIM is given, operate along this
     dimension.

     See also: prepad, cat, resize.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Append the scalar value C to the vector X until it is of length L.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
prepad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 540
 -- Function File: prepad (X, L)
 -- Function File: prepad (X, L, C)
 -- Function File: prepad (X, L, C, DIM)
     Prepend the scalar value C to the vector X until it is of length L.
     If C is not given, a value of 0 is used.

     If 'length (X) > L', elements from the beginning of X are removed
     until a vector of length L is obtained.

     If X is a matrix, elements are prepended or removed from each row.

     If the optional argument DIM is given, operate along this
     dimension.

     See also: postpad, cat, resize.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Prepend the scalar value C to the vector X until it is of length L.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
profexplore


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 480
 -- Function File: profexplore ()
 -- Function File: profexplore (DATA)
     Interactively explore hierarchical profiler output.

     Assuming DATA is the structure with profile data returned by
     'profile ("info")', this command opens an interactive prompt that
     can be used to explore the call-tree.  Type 'help' to get a list of
     possible commands.  If DATA is omitted, 'profile ("info")' is
     called and used in its place.

     See also: profile, profshow.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Interactively explore hierarchical profiler output.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
profile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1660
 -- Command: profile on
 -- Command: profile off
 -- Command: profile resume
 -- Command: profile clear
 -- Function File: S = profile ("status")
 -- Function File: T = profile ("info")
     Control the built-in profiler.

     'profile on'
          Start the profiler, clearing all previously collected data if
          there is any.

     'profile off'
          Stop profiling.  The collected data can later be retrieved and
          examined with calls like 'S = profile ("info")'.

     'profile clear'
          Clear all collected profiler data.

     'profile resume'
          Restart profiling without cleaning up the old data and instead
          all newly collected statistics are added to the already
          existing ones.

     'S = profile ("status")'
          Return a structure filled with certain information about the
          current status of the profiler.  At the moment, the only field
          is 'ProfilerStatus' which is either "on" or "off".

     'T = profile ("info")'
          Return the collected profiling statistics in the structure T.
          The flat profile is returned in the field 'FunctionTable'
          which is an array of structures, each entry corresponding to a
          function which was called and for which profiling statistics
          are present.  Furthermore, the field 'Hierarchical' contains
          the hierarchical call-tree.  Each node has an index into the
          'FunctionTable' identifying the function it corresponds to as
          well as data fields for number of calls and time spent at this
          level in the call-tree.

          See also: profshow, profexplore.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Control the built-in profiler.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
profshow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 621
 -- Function File: profshow (DATA)
 -- Function File: profshow (DATA, N)
     Show flat profiler results.

     This command prints out profiler data as a flat profile.  DATA is
     the structure returned by 'profile ("info")'.  If N is given, it
     specifies the number of functions to show in the profile; functions
     are sorted in descending order by total time spent in them.  If
     there are more than N included in the profile, those will not be
     shown.  N defaults to 20.

     The attribute column shows 'R' for recursive functions and nothing
     otherwise.

     See also: profexplore, profile.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Show flat profiler results.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
quadgk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4216
 -- Function File: Q = quadgk (F, A, B)
 -- Function File: Q = quadgk (F, A, B, ABSTOL)
 -- Function File: Q = quadgk (F, A, B, ABSTOL, TRACE)
 -- Function File: Q = quadgk (F, A, B, PROP, VAL, ...)
 -- Function File: [Q, ERR] = quadgk (...)

     Numerically evaluate the integral of F from A to B using adaptive
     Gauss-Konrod quadrature.  F is a function handle, inline function,
     or string containing the name of the function to evaluate.  The
     formulation is based on a proposal by L.F. Shampine, '"Vectorized
     adaptive quadrature in MATLAB", Journal of Computational and
     Applied Mathematics, pp131-140, Vol 211, Issue 2, Feb 2008' where
     all function evaluations at an iteration are calculated with a
     single call to F.  Therefore, the function F must be vectorized and
     must accept a vector of input values X and return an output vector
     representing the function evaluations at the given values of X.

     A and B are the lower and upper limits of integration.  Either or
     both limits may be infinite or contain weak end singularities.
     Variable transformation will be used to treat any infinite
     intervals and weaken the singularities.  For example:

          quadgk (@(x) 1 ./ (sqrt (x) .* (x + 1)), 0, Inf)

     Note that the formulation of the integrand uses the
     element-by-element operator './' and all user functions to 'quadgk'
     should do the same.

     The optional argument TOL defines the absolute tolerance used to
     stop the integration procedure.  The default value is 1e^{-10}.

     The algorithm used by 'quadgk' involves subdividing the integration
     interval and evaluating each subinterval.  If TRACE is true then
     after computing each of these partial integrals display: (1) the
     number of subintervals at this step, (2) the current estimate of
     the error ERR, (3) the current estimate for the integral Q.

     Alternatively, properties of 'quadgk' can be passed to the function
     as pairs "PROP", VAL.  Valid properties are

     'AbsTol'
          Define the absolute error tolerance for the quadrature.  The
          default absolute tolerance is 1e-10.

     'RelTol'
          Define the relative error tolerance for the quadrature.  The
          default relative tolerance is 1e-5.

     'MaxIntervalCount'
          'quadgk' initially subdivides the interval on which to perform
          the quadrature into 10 intervals.  Subintervals that have an
          unacceptable error are subdivided and re-evaluated.  If the
          number of subintervals exceeds 650 subintervals at any point
          then a poor convergence is signaled and the current estimate
          of the integral is returned.  The property "MaxIntervalCount"
          can be used to alter the number of subintervals that can exist
          before exiting.

     'WayPoints'
          Discontinuities in the first derivative of the function to
          integrate can be flagged with the "WayPoints" property.  This
          forces the ends of a subinterval to fall on the breakpoints of
          the function and can result in significantly improved
          estimation of the error in the integral, faster computation,
          or both.  For example,

               quadgk (@(x) abs (1 - x.^2), 0, 2, "Waypoints", 1)

          signals the breakpoint in the integrand at 'X = 1'.

     'Trace'
          If logically true 'quadgk' prints information on the
          convergence of the quadrature at each iteration.

     If any of A, B, or WAYPOINTS is complex then the quadrature is
     treated as a contour integral along a piecewise continuous path
     defined by the above.  In this case the integral is assumed to have
     no edge singularities.  For example,

          quadgk (@(z) log (z), 1+1i, 1+1i, "WayPoints",
                  [1-1i, -1,-1i, -1+1i])

     integrates 'log (z)' along the square defined by '[1+1i, 1-1i,
     -1-1i, -1+1i]'

     The result of the integration is returned in Q.  ERR is an
     approximate bound on the error in the integral 'abs (Q - I)', where
     I is the exact value of the integral.

     See also: quad, quadv, quadl, quadcc, trapz, dblquad, triplequad.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
Numerically evaluate the integral of F from A to B using adaptive  Gauss-Konrod quadrature.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
quadl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1465
 -- Function File: Q = quadl (F, A, B)
 -- Function File: Q = quadl (F, A, B, TOL)
 -- Function File: Q = quadl (F, A, B, TOL, TRACE)
 -- Function File: Q = quadl (F, A, B, TOL, TRACE, P1, P2, ...)

     Numerically evaluate the integral of F from A to B using an
     adaptive Lobatto rule.  F is a function handle, inline function, or
     string containing the name of the function to evaluate.  The
     function F must be vectorized and return a vector of output values
     if given a vector of input values.

     A and B are the lower and upper limits of integration.  Both limits
     must be finite.

     The optional argument TOL defines the relative tolerance with which
     to perform the integration.  The default value is 'eps'.

     The algorithm used by 'quadl' involves recursively subdividing the
     integration interval.  If TRACE is defined then for each
     subinterval display: (1) the left end of the subinterval, (2) the
     length of the subinterval, (3) the approximation of the integral
     over the subinterval.

     Additional arguments P1, etc., are passed directly to the function
     F.  To use default values for TOL and TRACE, one may pass empty
     matrices ([]).

     Reference: W. Gander and W. Gautschi, 'Adaptive Quadrature -
     Revisited', BIT Vol.  40, No.  1, March 2000, pp.  84-101.
     <http://www.inf.ethz.ch/personal/gander/>

     See also: quad, quadv, quadgk, quadcc, trapz, dblquad, triplequad.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
Numerically evaluate the integral of F from A to B using an  adaptive Lobatto rule.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
quadv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1806
 -- Function File: Q = quadv (F, A, B)
 -- Function File: Q = quadv (F, A, B, TOL)
 -- Function File: Q = quadv (F, A, B, TOL, TRACE)
 -- Function File: Q = quadv (F, A, B, TOL, TRACE, P1, P2, ...)
 -- Function File: [Q, NFUN] = quadv (...)

     Numerically evaluate the integral of F from A to B using an
     adaptive Simpson's rule.  F is a function handle, inline function,
     or string containing the name of the function to evaluate.  'quadv'
     is a vectorized version of 'quad' and the function defined by F
     must accept a scalar or vector as input and return a scalar,
     vector, or array as output.

     A and B are the lower and upper limits of integration.  Both limits
     must be finite.

     The optional argument TOL defines the tolerance used to stop the
     adaptation procedure.  The default value is 1e^{-6}.

     The algorithm used by 'quadv' involves recursively subdividing the
     integration interval and applying Simpson's rule on each
     subinterval.  If TRACE is true then after computing each of these
     partial integrals display: (1) the total number of function
     evaluations, (2) the left end of the subinterval, (3) the length of
     the subinterval, (4) the approximation of the integral over the
     subinterval.

     Additional arguments P1, etc., are passed directly to the function
     F.  To use default values for TOL and TRACE, one may pass empty
     matrices ([]).

     The result of the integration is returned in Q.  NFUN indicates the
     number of function evaluations that were made.

     Note: 'quadv' is written in Octave's scripting language and can be
     used recursively in 'dblquad' and 'triplequad', unlike the similar
     'quad' function.

     See also: quad, quadl, quadgk, quadcc, trapz, dblquad, triplequad.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
Numerically evaluate the integral of F from A to B using an  adaptive Simpson's rule.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
randi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1280
 -- Function File: randi (IMAX)
 -- Function File: randi (IMAX, N)
 -- Function File: randi (IMAX, M, N, ...)
 -- Function File: randi ([IMIN IMAX], ...)
 -- Function File: randi (..., "CLASS")
     Return random integers in the range 1:IMAX.

     Additional arguments determine the shape of the return matrix.
     When no arguments are specified a single random integer is
     returned.  If one argument N is specified then a square matrix (N x N)
     is returned.  Two or more arguments will return a multi-dimensional
     matrix (M x N x ...).

     The integer range may optionally be described by a two element
     matrix with a lower and upper bound in which case the returned
     integers will be on the interval [IMIN, IMAX].

     The optional argument CLASS will return a matrix of the requested
     type.  The default is "double".

     The following example returns 150 integers in the range 1-10.

          ri = randi (10, 150, 1)

     Implementation Note: 'randi' relies internally on 'rand' which uses
     class "double" to represent numbers.  This limits the maximum
     integer (IMAX) and range (IMAX - IMIN) to the value returned by the
     'bitmax' function.  For IEEE floating point numbers this value is
     2^{53} - 1.

     See also: rand.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Return random integers in the range 1:IMAX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
rat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 482
 -- Function File: S = rat (X, TOL)
 -- Function File: [N, D] = rat (X, TOL)

     Find a rational approximation to X within the tolerance defined by
     TOL using a continued fraction expansion.  For example:

          rat (pi) = 3 + 1/(7 + 1/16) = 355/113
          rat (e) = 3 + 1/(-4 + 1/(2 + 1/(5 + 1/(-2 + 1/(-7)))))
                  = 1457/536

     Called with two arguments returns the numerator and denominator
     separately as two matrices.

     See also: rats.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
Find a rational approximation to X within the tolerance defined by  TOL using a continued fraction expansion.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
repmat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 486
 -- Function File: repmat (A, M)
 -- Function File: repmat (A, M, N)
 -- Function File: repmat (A, [M N])
 -- Function File: repmat (A, [M N P ...])
     Form a block matrix of size M by N, with a copy of matrix A as each
     element.  If N is not specified, form an M by M block matrix.  For
     copying along more than two dimensions, specify the number of times
     to copy across each dimension M, N, P, ..., in a vector in the
     second argument.

     See also: repelems.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Form a block matrix of size M by N, with a copy of matrix A as each  element.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
rot90


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 820
 -- Function File: rot90 (A)
 -- Function File: rot90 (A, K)
     Return a copy of A with the elements rotated counterclockwise in
     90-degree increments.  The second argument is optional, and
     specifies how many 90-degree rotations are to be applied (the
     default value is 1).  Negative values of K rotate the matrix in a
     clockwise direction.  For example,

          rot90 ([1, 2; 3, 4], -1)
              =>  3  1
                  4  2

     rotates the given matrix clockwise by 90 degrees.  The following
     are all equivalent statements:

          rot90 ([1, 2; 3, 4], -1)
          rot90 ([1, 2; 3, 4], 3)
          rot90 ([1, 2; 3, 4], 7)

     Note that 'rot90' only works with 2-D arrays.  To rotate N-D arrays
     use 'rotdim' instead.

     See also: rotdim, flipud, fliplr, flipdim.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Return a copy of A with the elements rotated counterclockwise in  90-degree increments.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rotdim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1074
 -- Function File: rotdim (X)
 -- Function File: rotdim (X, N)
 -- Function File: rotdim (X, N, PLANE)
     Return a copy of X with the elements rotated counterclockwise in
     90-degree increments.  The second argument N is optional, and
     specifies how many 90-degree rotations are to be applied (the
     default value is 1).  The third argument is also optional and
     defines the plane of the rotation.  If present, PLANE is a two
     element vector containing two different valid dimensions of the
     matrix.  When PLANE is not given the first two non-singleton
     dimensions are used.

     Negative values of N rotate the matrix in a clockwise direction.
     For example,

          rotdim ([1, 2; 3, 4], -1, [1, 2])
               =>  3  1
                   4  2

     rotates the given matrix clockwise by 90 degrees.  The following
     are all equivalent statements:

          rotdim ([1, 2; 3, 4], -1, [1, 2])
          rotdim ([1, 2; 3, 4], 3, [1, 2])
          rotdim ([1, 2; 3, 4], 7, [1, 2])

     See also: rot90, flipud, fliplr, flipdim.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Return a copy of X with the elements rotated counterclockwise in  90-degree increments.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
saveobj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 662
 -- Function File: B = saveobj (A)
     Method of a class to manipulate an object prior to saving it to a
     file.  The function 'saveobj' is called when the object A is saved
     using the 'save' function.  An example of the use of 'saveobj'
     might be to remove fields of the object that don't make sense to be
     saved or it might be used to ensure that certain fields of the
     object are initialized before the object is saved.  For example:

          function b = saveobj (a)
            b = a;
            if (isempty (b.field))
               b.field = initfield (b);
            endif
          endfunction

     See also: loadobj, class.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Method of a class to manipulate an object prior to saving it to a  file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
shift


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 292
 -- Function File: shift (X, B)
 -- Function File: shift (X, B, DIM)
     If X is a vector, perform a circular shift of length B of the
     elements of X.

     If X is a matrix, do the same for each column of X.  If the
     optional DIM argument is given, operate along this dimension.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
If X is a vector, perform a circular shift of length B of the  elements of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
shiftdim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 911
 -- Function File: Y = shiftdim (X, N)
 -- Function File: [Y, NS] = shiftdim (X)
     Shift the dimensions of X by N, where N must be an integer scalar.
     When N is positive, the dimensions of X are shifted to the left,
     with the leading dimensions circulated to the end.  If N is
     negative, then the dimensions of X are shifted to the right, with N
     leading singleton dimensions added.

     Called with a single argument, 'shiftdim', removes the leading
     singleton dimensions, returning the number of dimensions removed in
     the second output argument NS.

     For example:

          x = ones (1, 2, 3);
          size (shiftdim (x, -1))
             => [1, 1, 2, 3]
          size (shiftdim (x, 1))
             => [2, 3]
          [b, ns] = shiftdim (x)
             => b = [1, 1, 1; 1, 1, 1]
             => ns = 1

     See also: reshape, permute, ipermute, circshift, squeeze.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Shift the dimensions of X by N, where N must be an integer scalar.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
sortrows


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 403
 -- Function File: [S, I] = sortrows (A)
 -- Function File: [S, I] = sortrows (A, C)
     Sort the rows of the matrix A according to the order of the columns
     specified in C.  If C is omitted, a lexicographical sort is used.
     By default ascending order is used however if elements of C are
     negative then the corresponding column is sorted in descending
     order.

     See also: sort.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Sort the rows of the matrix A according to the order of the columns  specified in C.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
sph2cart


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 720
 -- Function File: [X, Y, Z] = sph2cart (THETA, PHI, R)
 -- Function File: [X, Y, Z] = sph2cart (S)
 -- Function File: C = sph2cart (...)
     Transform spherical to Cartesian coordinates.

     THETA describes the angle relative to the positive x-axis.  PHI is
     the angle relative to the xy-plane.  R is the distance to the
     origin (0, 0, 0).  THETA, PHI, and R must be the same shape, or
     scalar.  If called with a single matrix argument then each row of S
     represents the spherical coordinate (THETA, PHI, R).

     If only a single return argument is requested then return a matrix
     C where each row represents one Cartesian coordinate (X, Y, Z).

     See also: cart2sph, pol2cart, cart2pol.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Transform spherical to Cartesian coordinates.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
structfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1979
 -- Function File: structfun (FUNC, S)
 -- Function File: [A, ...] = structfun (...)
 -- Function File: structfun (..., "ErrorHandler", ERRFUNC)
 -- Function File: structfun (..., "UniformOutput", VAL)

     Evaluate the function named NAME on the fields of the structure S.
     The fields of S are passed to the function FUNC individually.

     'structfun' accepts an arbitrary function FUNC in the form of an
     inline function, function handle, or the name of a function (in a
     character string).  In the case of a character string argument, the
     function must accept a single argument named X, and it must return
     a string value.  If the function returns more than one argument,
     they are returned as separate output variables.

     If the parameter "UniformOutput" is set to true (the default), then
     the function must return a single element which will be
     concatenated into the return value.  If "UniformOutput" is false,
     the outputs are placed into a structure with the same fieldnames as
     the input structure.

          s.name1 = "John Smith";
          s.name2 = "Jill Jones";
          structfun (@(x) regexp (x, '(\w+)$', "matches"){1}, s,
                     "UniformOutput", false)
          =>
             {
               name1 = Smith
               name2 = Jones
             }

     Given the parameter "ErrorHandler", ERRFUNC defines a function to
     call in case FUNC generates an error.  The form of the function is

          function [...] = errfunc (SE, ...)

     where there is an additional input argument to ERRFUNC relative to
     FUNC, given by SE.  This is a structure with the elements
     "identifier", "message" and "index", giving respectively the error
     identifier, the error message, and the index into the input
     arguments of the element that caused the error.  For an example on
     how to use an error handler, *note cellfun: XREFcellfun.

     See also: cellfun, arrayfun, spfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Evaluate the function named NAME on the fields of the structure S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
subsindex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 849
 -- Function File: IDX = subsindex (A)
     Convert an object to an index vector.  When A is a class object
     defined with a class constructor, then 'subsindex' is the
     overloading method that allows the conversion of this class object
     to a valid indexing vector.  It is important to note that
     'subsindex' must return a zero-based real integer vector of the
     class "double".  For example, if the class constructor

          function b = myclass (a)
            b = class (struct ("a", a), "myclass");
          endfunction

     then the 'subsindex' function

          function idx = subsindex (a)
            idx = double (a.a) - 1.0;
          endfunction

     can then be used as follows

          a = myclass (1:4);
          b = 1:10;
          b(a)
          => 1  2  3  4

     See also: class, subsref, subsasgn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Convert an object to an index vector.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
triplequad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1354
 -- Function File: triplequad (F, XA, XB, YA, YB, ZA, ZB)
 -- Function File: triplequad (F, XA, XB, YA, YB, ZA, ZB, TOL)
 -- Function File: triplequad (F, XA, XB, YA, YB, ZA, ZB, TOL, QUADF)
 -- Function File: triplequad (F, XA, XB, YA, YB, ZA, ZB, TOL, QUADF,
          ...)
     Numerically evaluate the triple integral of F.  F is a function
     handle, inline function, or string containing the name of the
     function to evaluate.  The function F must have the form w =
     f(x,y,z) where either X or Y is a vector and the remaining inputs
     are scalars.  It should return a vector of the same length and
     orientation as X or Y.

     XA, YA, ZA and XB, YB, ZB are the lower and upper limits of
     integration for x, y, and z respectively.  The underlying
     integrator determines whether infinite bounds are accepted.

     The optional argument TOL defines the absolute tolerance used to
     integrate each sub-integral.  The default value is 1e^{-6}.

     The optional argument QUADF specifies which underlying integrator
     function to use.  Any choice but 'quad' is available and the
     default is 'quadcc'.

     Additional arguments, are passed directly to F.  To use the default
     value for TOL or QUADF one may pass ':' or an empty matrix ([]).

     See also: dblquad, quad, quadv, quadl, quadgk, quadcc, trapz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
trapz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1266
 -- Function File: Q = trapz (Y)
 -- Function File: Q = trapz (X, Y)
 -- Function File: Q = trapz (..., DIM)

     Numerically evaluate the integral of points Y using the trapezoidal
     method.  'trapz (Y)' computes the integral of Y along the first
     non-singleton dimension.  When the argument X is omitted an equally
     spaced X vector with unit spacing (1) is assumed.  'trapz (X, Y)'
     evaluates the integral with respect to the spacing in X and the
     values in Y.  This is useful if the points in Y have been sampled
     unevenly.  If the optional DIM argument is given, operate along
     this dimension.

     If X is not specified then unit spacing will be used.  To scale the
     integral to the correct value you must multiply by the actual
     spacing value (deltaX). As an example, the integral of x^3 over the
     range [0, 1] is x^4/4 or 0.25.  The following code uses 'trapz' to
     calculate the integral in three different ways.

          x = 0:0.1:1;
          y = x.^3;
          q = trapz (y)
            => q = 2.525   # No scaling
          q * 0.1
            => q = 0.2525  # Approximation to integral by scaling
          trapz (x, y)
            => q = 0.2525  # Same result by specifying X

     See also: cumtrapz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Numerically evaluate the integral of points Y using the trapezoidal  method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
convhull


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 926
 -- Function File: H = convhull (X, Y)
 -- Function File: H = convhull (X, Y, OPTIONS)
     Compute the convex hull of the set of points defined by the arrays
     X and Y.  The hull H is an index vector into the set of points and
     specifies which points form the enclosing hull.

     An optional third argument, which must be a string or cell array of
     strings, contains options passed to the underlying qhull command.
     See the documentation for the Qhull library for details
     <http://www.qhull.org/html/qh-quick.htm#options>.  The default
     option is '{"Qt"}'.

     If OPTIONS is not present or '[]' then the default arguments are
     used.  Otherwise, OPTIONS replaces the default argument list.  To
     append user options to the defaults it is necessary to repeat the
     default arguments in OPTIONS.  Use a null string to pass no
     arguments.

     See also: convhulln, delaunay, voronoi.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Compute the convex hull of the set of points defined by the arrays  X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
delaunay3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1362
 -- Function File: TETR = delaunay3 (X, Y, Z)
 -- Function File: TETR = delaunay3 (X, Y, Z, OPTIONS)
     Compute the Delaunay triangulation for a 3-D set of points.  The
     return value TETR is a set of tetrahedrons which satisfies the
     Delaunay circum-circle criterion, i.e., only a single data point
     from [X, Y, Z] is within the circum-circle of the defining
     tetrahedron.

     The set of tetrahedrons TETR is a matrix of size [n, 4].  Each row
     defines a tetrahedron and the four columns are the four vertices of
     the tetrahedron.  The value of 'TETR(i,j)' is an index into X, Y, Z
     for the location of the j-th vertex of the i-th tetrahedron.

     An optional fourth argument, which must be a string or cell array
     of strings, contains options passed to the underlying qhull
     command.  See the documentation for the Qhull library for details
     <http://www.qhull.org/html/qh-quick.htm#options>.  The default
     options are '{"Qt", "Qbb", "Qc", "Qz"}'.

     If OPTIONS is not present or '[]' then the default arguments are
     used.  Otherwise, OPTIONS replaces the default argument list.  To
     append user options to the defaults it is necessary to repeat the
     default arguments in OPTIONS.  Use a null string to pass no
     arguments.

     See also: delaunay, delaunayn, convhull, voronoi, tetramesh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Compute the Delaunay triangulation for a 3-D set of points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
delaunayn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1545
 -- Function File: T = delaunayn (PTS)
 -- Function File: T = delaunayn (PTS, OPTIONS)
     Compute the Delaunay triangulation for an N-dimensional set of
     points.  The Delaunay triangulation is a tessellation of the convex
     hull of a set of points such that no N-sphere defined by the
     N-triangles contains any other points from the set.

     The input matrix PTS of size [n, dim] contains n points in a space
     of dimension dim.  The return matrix T has size [m, dim+1].  Each
     row of T contains a set of indices back into the original set of
     points PTS which describes a simplex of dimension dim.  For
     example, a 2-D simplex is a triangle and 3-D simplex is a
     tetrahedron.

     An optional second argument, which must be a string or cell array
     of strings, contains options passed to the underlying qhull
     command.  See the documentation for the Qhull library for details
     <http://www.qhull.org/html/qh-quick.htm#options>.  The default
     options depend on the dimension of the input:

        * 2-D and 3-D: OPTIONS = '{"Qt", "Qbb", "Qc", "Qz"}'

        * 4-D and higher: OPTIONS = '{"Qt", "Qbb", "Qc", "Qx"}'

     If OPTIONS is not present or '[]' then the default arguments are
     used.  Otherwise, OPTIONS replaces the default argument list.  To
     append user options to the defaults it is necessary to repeat the
     default arguments in OPTIONS.  Use a null string to pass no
     arguments.

     See also: delaunay, delaunay3, convhulln, voronoin, trimesh,
     tetramesh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Compute the Delaunay triangulation for an N-dimensional set of  points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
delaunay


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1944
 -- Function File: delaunay (X, Y)
 -- Function File: delaunay (X)
 -- Function File: delaunay (..., OPTIONS)
 -- Function File: TRI = delaunay (...)
     Compute the Delaunay triangulation for a 2-D set of points.  The
     return value TRI is a set of triangles which satisfies the Delaunay
     circum-circle criterion, i.e., only a single data point from [X, Y]
     is within the circum-circle of the defining triangle.  The input X
     may also be a matrix with two columns where the first column
     contains x-data and the second y-data.

     The set of triangles TRI is a matrix of size [n, 3].  Each row
     defines a triangle and the three columns are the three vertices of
     the triangle.  The value of 'TRI(i,j)' is an index into X and Y for
     the location of the j-th vertex of the i-th triangle.

     The optional last argument, which must be a string or cell array of
     strings, contains options passed to the underlying qhull command.
     See the documentation for the Qhull library for details
     <http://www.qhull.org/html/qh-quick.htm#options>.  The default
     options are '{"Qt", "Qbb", "Qc", "Qz"}'.

     If OPTIONS is not present or '[]' then the default arguments are
     used.  Otherwise, OPTIONS replaces the default argument list.  To
     append user options to the defaults it is necessary to repeat the
     default arguments in OPTIONS.  Use a null string to pass no
     arguments.

     If no output argument is specified the resulting Delaunay
     triangulation is plotted along with the original set of points.

          x = rand (1, 10);
          y = rand (1, 10);
          T = delaunay (x, y);
          VX = [ x(T(:,1)); x(T(:,2)); x(T(:,3)); x(T(:,1)) ];
          VY = [ y(T(:,1)); y(T(:,2)); y(T(:,3)); y(T(:,1)) ];
          axis ([0,1,0,1]);
          plot (VX, VY, "b", x, y, "r*");

     See also: delaunay3, delaunayn, convhull, voronoi, triplot,
     trimesh, trisurf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Compute the Delaunay triangulation for a 2-D set of points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dsearch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 310
 -- Function File: IDX = dsearch (X, Y, TRI, XI, YI)
 -- Function File: IDX = dsearch (X, Y, TRI, XI, YI, S)
     Return the index IDX or the closest point in 'X, Y' to the elements
     '[XI(:), YI(:)]'.  The variable S is accepted for compatibility but
     is ignored.

     See also: dsearchn, tsearch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Return the index IDX or the closest point in 'X, Y' to the elements  '[XI(:), YI(:)]'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
dsearchn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 482
 -- Function File: IDX = dsearchn (X, TRI, XI)
 -- Function File: IDX = dsearchn (X, TRI, XI, OUTVAL)
 -- Function File: IDX = dsearchn (X, XI)
 -- Function File: [IDX, D] = dsearchn (...)
     Return the index IDX or the closest point in X to the elements XI.
     If OUTVAL is supplied, then the values of XI that are not contained
     within one of the simplices TRI are set to OUTVAL.  Generally, TRI
     is returned from 'delaunayn (X)'.

     See also: dsearch, tsearch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Return the index IDX or the closest point in X to the elements XI.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
griddata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 661
 -- Function File: ZI = griddata (X, Y, Z, XI, YI)
 -- Function File: ZI = griddata (X, Y, Z, XI, YI, METHOD)
 -- Function File: [XI, YI, ZI] = griddata (...)

     Generate a regular mesh from irregular data using interpolation.
     The function is defined by 'Z = f (X, Y)'.  Inputs 'X, Y, Z' are
     vectors of the same length or 'X, Y' are vectors and 'Z' is matrix.

     The interpolation points are all '(XI, YI)'.  If XI, YI are vectors
     then they are made into a 2-D mesh.

     The interpolation method can be "nearest", "cubic" or "linear".  If
     method is omitted it defaults to "linear".

     See also: griddata3, griddatan, delaunay.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Generate a regular mesh from irregular data using interpolation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
griddata3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 786
 -- Function File: VI = griddata3 (X, Y, Z, V, XI, YI, ZI)
 -- Function File: VI = griddata3 (X, Y, Z, V, XI, YI, ZI, METHOD)
 -- Function File: VI = griddata3 (X, Y, Z, V, XI, YI, ZI, METHOD,
          OPTIONS)

     Generate a regular mesh from irregular data using interpolation.
     The function is defined by 'V = f (X, Y, Z)'.  The interpolation
     points are specified by XI, YI, ZI.

     The interpolation method can be "nearest" or "linear".  If method
     is omitted it defaults to "linear".

     The optional argument OPTIONS is passed directly to Qhull when
     computing the Delaunay triangulation used for interpolation.  See
     'delaunayn' for information on the defaults and how to pass
     different values.

     See also: griddata, griddatan, delaunayn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
OPTIONS) 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
griddatan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 711
 -- Function File: YI = griddatan (X, Y, XI)
 -- Function File: YI = griddatan (X, Y, XI, METHOD)
 -- Function File: YI = griddatan (X, Y, XI, METHOD, OPTIONS)

     Generate a regular mesh from irregular data using interpolation.
     The function is defined by 'Y = f (X)'.  The interpolation points
     are all XI.

     The interpolation method can be "nearest" or "linear".  If method
     is omitted it defaults to "linear".

     The optional argument OPTIONS is passed directly to Qhull when
     computing the Delaunay triangulation used for interpolation.  See
     'delaunayn' for information on the defaults and how to pass
     different values.

     See also: griddata, griddata3, delaunayn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Generate a regular mesh from irregular data using interpolation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
inpolygon


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 316
 -- Function File: [IN, ON] = inpolygon (X, Y, XV, YV)

     For a polygon defined by vertex points '(XV, YV)', determine if the
     points '(X, Y)' are inside or outside the polygon.  The variables
     X, Y, must have the same dimension.  The optional output ON gives
     the points that are on the polygon.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 119
For a polygon defined by vertex points '(XV, YV)', determine if the  points '(X, Y)' are inside or outside the polygon.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rectint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 457
 -- Function File: AREA = rectint (A, B)

     Compute the area of intersection of rectangles in A and rectangles
     in B.  Rectangles are defined as [x y width height] where x and y
     are the minimum values of the two orthogonal dimensions.

     If A or B are matrices, then the output, AREA, is a matrix where
     the i-th row corresponds to the i-th row of a and the j-th column
     corresponds to the j-th row of b.

     See also: polyarea.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Compute the area of intersection of rectangles in A and rectangles  in B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
tsearchn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 374
 -- Function File: [IDX, P] = tsearchn (X, T, XI)
     Search for the enclosing Delaunay convex hull.  For 'T = delaunayn
     (X)', finds the index in T containing the points XI.  For points
     outside the convex hull, IDX is NaN. If requested 'tsearchn' also
     returns the Barycentric coordinates P of the enclosing triangles.

     See also: delaunay, delaunayn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Search for the enclosing Delaunay convex hull.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
voronoi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1356
 -- Function File: voronoi (X, Y)
 -- Function File: voronoi (X, Y, OPTIONS)
 -- Function File: voronoi (..., "linespec")
 -- Function File: voronoi (HAX, ...)
 -- Function File: H = voronoi (...)
 -- Function File: [VX, VY] = voronoi (...)
     Plot the Voronoi diagram of points '(X, Y)'.  The Voronoi facets
     with points at infinity are not drawn.

     If "linespec" is given it is used to set the color and line style
     of the plot.  If an axis graphics handle HAX is supplied then the
     Voronoi diagram is drawn on the specified axis rather than in a new
     figure.

     The OPTIONS argument, which must be a string or cell array of
     strings, contains options passed to the underlying qhull command.
     See the documentation for the Qhull library for details
     <http://www.qhull.org/html/qh-quick.htm#options>.

     If a single output argument is requested then the Voronoi diagram
     will be plotted and a graphics handle H to the plot is returned.
     [VX, VY] = voronoi (...) returns the Voronoi vertices instead of
     plotting the diagram.

          x = rand (10, 1);
          y = rand (size (x));
          h = convhull (x, y);
          [vx, vy] = voronoi (x, y);
          plot (vx, vy, "-b", x, y, "o", x(h), y(h), "-g");
          legend ("", "points", "hull");

     See also: voronoin, delaunay, convhull.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Plot the Voronoi diagram of points '(X, Y)'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
voronoin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1126
 -- Function File: [C, F] = voronoin (PTS)
 -- Function File: [C, F] = voronoin (PTS, OPTIONS)
     Compute N-dimensional Voronoi facets.  The input matrix PTS of size
     [n, dim] contains n points in a space of dimension dim.  C contains
     the points of the Voronoi facets.  The list F contains, for each
     facet, the indices of the Voronoi points.

     An optional second argument, which must be a string or cell array
     of strings, contains options passed to the underlying qhull
     command.  See the documentation for the Qhull library for details
     <http://www.qhull.org/html/qh-quick.htm#options>.

     The default options depend on the dimension of the input:

        * 2-D and 3-D: OPTIONS = '{"Qbb"}'

        * 4-D and higher: OPTIONS = '{"Qbb", "Qx"}'

     If OPTIONS is not present or '[]' then the default arguments are
     used.  Otherwise, OPTIONS replaces the default argument list.  To
     append user options to the defaults it is necessary to repeat the
     default arguments in OPTIONS.  Use a null string to pass no
     arguments.

     See also: voronoi, convhulln, delaunayn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Compute N-dimensional Voronoi facets.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
errordlg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 517
 -- Function File: H = errordlg (MSG)
 -- Function File: H = errordlg (MSG, TITLE)
     Display MSG using an error dialog box.

     The message may have multiple lines separated by newline characters
     ("\n"), or it may be a cellstr array with one element for each
     line.  The optional input TITLE (character string) can be used to
     set the dialog caption.  The default title is "Error Dialog".

     The return value is always 1.

     See also: helpdlg, inputdlg, listdlg, msgbox, questdlg, warndlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Display MSG using an error dialog box.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
guidata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 517
 -- Function File: DATA = guidata (H)
 -- Function File: guidata (H, DATA)
     Query or set user-custom GUI data.

     The GUI data is stored in the figure handle H.  If H is not a
     figure handle then it's parent figure will be used for storage.

     DATA must be a single object which means it is usually preferable
     for it to be a data container such as a cell array or struct so
     that additional data items can be added easily.

     See also: getappdata, setappdata, get, set, getpref, setpref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Query or set user-custom GUI data.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
guihandles


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 695
 -- Function File: HDATA = guihandles (H)
 -- Function File: HDATA = guihandles
     Return a structure of object handles for the figure associated with
     handle H.

     If no handle is specified the current figure returned by 'gcf' is
     used.

     The fieldname for each entry of HDATA is taken from the "tag"
     property of the graphic object.  If the tag is empty then the
     handle is not returned.  If there are multiple graphic objects with
     the same tag then the entry in HDATA will be a vector of handles.
     'guihandles' includes all possible handles, including those for
     which "HandleVisibility" is "off".

     See also: guidata, findobj, findall, allchild.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Return a structure of object handles for the figure associated with  handle H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
helpdlg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 510
 -- Function File: H = helpdlg (MSG)
 -- Function File: H = helpdlg (MSG, TITLE)
     Display MSG in a help dialog box.

     The message may have multiple lines separated by newline characters
     ("\n"), or it may be a cellstr array with one element for each
     line.  The optional input TITLE (character string) can be used to
     set the dialog caption.  The default title is "Help Dialog".

     The return value is always 1.

     See also: errordlg, inputdlg, listdlg, msgbox, questdlg, warndlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Display MSG in a help dialog box.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
inputdlg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1504
 -- Function File: CSTR = inputdlg (PROMPT)
 -- Function File: CSTR = inputdlg (PROMPT, TITLE)
 -- Function File: CSTR = inputdlg (PROMPT, TITLE, ROWSCOLS)
 -- Function File: CSTR = inputdlg (PROMPT, TITLE, ROWSCOLS, DEFAULTS)
     Return user input from a multi-textfield dialog box in a cell array
     of strings, or an empty cell array if the dialog is closed by the
     Cancel button.

     Inputs:

     PROMPT
          A cell array with strings labeling each text field.  This
          input is required.

     TITLE
          String to use for the caption of the dialog.  The default is
          "Input Dialog".

     ROWSCOLS
          Specifies the size of the text fields and can take three
          forms:

            1. a scalar value which defines the number of rows used for
               each text field.

            2. a vector which defines the individual number of rows used
               for each text field.

            3. a matrix which defines the individual number of rows and
               columns used for each text field.  In the matrix each row
               describes a single text field.  The first column
               specifies the number of input rows to use and the second
               column specifies the text field width.

     DEFAULTS
          A list of default values to place in each text fields.  It
          must be a cell array of strings with the same size as PROMPT.

     See also: errordlg, helpdlg, listdlg, msgbox, questdlg, warndlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
Return user input from a multi-textfield dialog box in a cell array  of strings, or an empty cell array if the dialog is closed by the  Cancel button.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
listdlg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1721
 -- Function File: [SEL, OK] = listdlg (KEY, VALUE, ...)
     Return user inputs from a list dialog box in a vector of selection
     indices SEL and a flag OK indicating how the user closed the dialog
     box.  The value of OK is 1 if the user closed the box with the OK
     button, otherwise it is 0 and SEL is empty.

     The indices in SEL are 1-based.

     The arguments are specified in form of KEY, VALUE pairs.  The
     "ListString" argument pair must be specified.

     Valid KEY and VALUE pairs are:

     "ListString"
          a cell array of strings comprising the content of the list.

     "SelectionMode"
          can be either "Single" or "Multiple" (default).

     "ListSize"
          a vector with two elements WIDTH and HEIGHT defining the size
          of the list field in pixels.  Default is [160 300].

     "InitialValue"
          a vector containing 1-based indices of preselected elements.
          Default is 1 (first item).

     "Name"
          a string to be used as the dialog caption.  Default is "".

     "PromptString"
          a cell array of strings to be displayed above the list field.
          Default is {}.

     "OKString"
          a string used to label the OK button.  Default is "OK".

     "CancelString"
          a string used to label the Cancel button.  Default is
          "Cancel".

     Example:

          [sel, ok] = listdlg ("ListString", {"An item", "another", "yet another"},
                               "SelectionMode", "Multiple");
          if (ok == 1)
            for i = 1:numel (sel)
              disp (sel(i));
            endfor
          endif

     See also: menu, errordlg, helpdlg, inputdlg, msgbox, questdlg,
     warndlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 141
Return user inputs from a list dialog box in a vector of selection  indices SEL and a flag OK indicating how the user closed the dialog  box.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
msgbox


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 657
 -- Function File: H = msgbox (MSG)
 -- Function File: H = msgbox (MSG, TITLE)
 -- Function File: H = msgbox (MSG, TITLE, ICON)
     Display MSG using a message dialog box.

     The message may have multiple lines separated by newline characters
     ("\n"), or it may be a cellstr array with one element for each
     line.  The optional input TITLE (character string) can be used to
     decorate the dialog caption.

     The optional argument ICON selects a dialog icon.  It can be one of
     "none" (default), "error", "help", or "warn".

     The return value is always 1.

     See also: errordlg, helpdlg, inputdlg, listdlg, questdlg, warndlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Display MSG using a message dialog box.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
questdlg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1204
 -- Function File: BTN = questdlg (MSG)
 -- Function File: BTN = questdlg (MSG, TITLE)
 -- Function File: BTN = questdlg (MSG, TITLE, DEFAULT)
 -- Function File: BTN = questdlg (MSG, TITLE, BTN1, BTN2, DEFAULT)
 -- Function File: BTN = questdlg (MSG, TITLE, BTN1, BTN2, BTN3,
          DEFAULT)
     Display MSG using a question dialog box and return the caption of
     the activated button.

     The dialog may contain two or three buttons which will all close
     the dialog.

     The message may have multiple lines separated by newline characters
     ("\n"), or it may be a cellstr array with one element for each
     line.  The optional TITLE (character string) can be used to
     decorate the dialog caption.

     The string DEFAULT identifies the default button, which is
     activated by pressing the <ENTER> key.  It must match one of the
     strings given in BTN1, BTN2, or BTN3.

     If only MSG and TITLE are specified, three buttons with the default
     captions "Yes", "No", and "Cancel" are used.

     If only two button captions, BTN1 and BTN2, are specified the
     dialog will have only these two buttons.

     See also: errordlg, helpdlg, inputdlg, listdlg, warndlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
DEFAULT)  Display MSG using a question dialog box and return the caption of  the activated button.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
uicontextmenu


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
 -- Function File: HANDLE = uicontextmenu ("Name", value, ...)
   


# name: <cell-element>
# type: sq_string
# elements: 0



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
uicontrol


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 167
 -- Function File: HANDLE = uicontrol ("Name", value, ...)
 -- Function File: HANDLE = uicontrol (PARENT, "Name", value, ...)
 -- Function File: uicontrol (HANDLE)
   


# name: <cell-element>
# type: sq_string
# elements: 0



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
uigetdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 377
 -- Function File: DIRNAME = uigetdir ()
 -- Function File: DIRNAME = uigetdir (INIT_PATH)
 -- Function File: DIRNAME = uigetdir (INIT_PATH, DIALOG_NAME)
     Open a GUI dialog for selecting a directory.  If INIT_PATH is not
     given the current working directory is used.  DIALOG_NAME may be
     used to customize the dialog title.

     See also: uigetfile, uiputfile.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Open a GUI dialog for selecting a directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
uigetfile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1899
 -- Function File: [FNAME, FPATH, FLTIDX] = uigetfile ()
 -- Function File: [...] = uigetfile (FLT)
 -- Function File: [...] = uigetfile (FLT, DIALOG_NAME)
 -- Function File: [...] = uigetfile (FLT, DIALOG_NAME, DEFAULT_FILE)
 -- Function File: [...] = uigetfile (..., "Position", [PX PY])
 -- Function File: [...] = uigetfile (..., "MultiSelect", MODE)

     Open a GUI dialog for selecting a file and return the filename
     FNAME, the path to this file FPATH, and the filter index FLTIDX.
     FLT contains a (list of) file filter string(s) in one of the
     following formats:

     "/path/to/filename.ext"
          If a filename is given then the file extension is extracted
          and used as filter.  In addition, the path is selected as
          current path and the filename is selected as default file.
          Example: 'uigetfile ("myfun.m")'

     A single file extension "*.ext"
          Example: 'uigetfile ("*.ext")'

     A 2-column cell array
          containing a file extension in the first column and a brief
          description in the second column.  Example: 'uigetfile
          ({"*.ext", "My Description";"*.xyz", "XYZ-Format"})'

          The filter string can also contain a semicolon separated list
          of filter extensions.  Example: 'uigetfile
          ({"*.gif;*.png;*.jpg", "Supported Picture Formats"})'

     DIALOG_NAME can be used to customize the dialog title.  If
     DEFAULT_FILE is given then it will be selected in the GUI dialog.
     If, in addition, a path is given it is also used as current path.

     The screen position of the GUI dialog can be set using the
     "Position" key and a 2-element vector containing the pixel
     coordinates.  Two or more files can be selected when setting the
     "MultiSelect" key to "on".  In that case FNAME is a cell array
     containing the files.

     See also: uiputfile, uigetdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 128
Open a GUI dialog for selecting a file and return the filename  FNAME, the path to this file FPATH, and the filter index FLTIDX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
uimenu


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2075
 -- Function File: uimenu (PROPERTY, VALUE, ...)
 -- Function File: uimenu (H, PROPERTY, VALUE, ...)
     Create a uimenu object and return a handle to it.  If H is omitted
     then a top-level menu for the current figure is created.  If H is
     given then a submenu relative to H is created.

     uimenu objects have the following specific properties:

     "accelerator"
          A string containing the key combination together with CTRL to
          execute this menu entry (e.g., "x" for CTRL+x).

     "callback"
          Is the function called when this menu entry is executed.  It
          can be either a function string (e.g., "myfun"), a function
          handle (e.g., @myfun) or a cell array containing the function
          handle and arguments for the callback function (e.g., {@myfun,
          arg1, arg2}).

     "checked"
          Can be set "on" or "off".  Sets a mark at this menu entry.

     "enable"
          Can be set "on" or "off".  If disabled the menu entry cannot
          be selected and it is grayed out.

     "foregroundcolor"
          A color value setting the text color for this menu entry.

     "label"
          A string containing the label for this menu entry.  A
          "&"-symbol can be used to mark the "accelerator" character
          (e.g., "E&xit")

     "position"
          An scalar value containing the relative menu position.  The
          entry with the lowest value is at the first position starting
          from left or top.

     "separator"
          Can be set "on" or "off".  If enabled it draws a separator
          line above the current position.  It is ignored for top level
          entries.

     Examples:

          f = uimenu ("label", "&File", "accelerator", "f");
          e = uimenu ("label", "&Edit", "accelerator", "e");
          uimenu (f, "label", "Close", "accelerator", "q", ...
                     "callback", "close (gcf)");
          uimenu (e, "label", "Toggle &Grid", "accelerator", "g", ...
                     "callback", "grid (gca)");

     See also: figure.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Create a uimenu object and return a handle to it.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
uipanel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
 -- Function File: HANDLE = uipanel ("Name", value, ...)
 -- Function File: HANDLE = uipanel (PARENT, "Name", value, ...)
   


# name: <cell-element>
# type: sq_string
# elements: 0



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
uipushtool


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 131
 -- Function File: HANDLE = uipushtool ("Name", value, ...)
 -- Function File: HANDLE = uipushtool (PARENT, "Name", value, ...)
   


# name: <cell-element>
# type: sq_string
# elements: 0



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
uiputfile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1442
 -- Function File: [FNAME, FPATH, FLTIDX] = uiputfile ()
 -- Function File: [FNAME, FPATH, FLTIDX] = uiputfile (FLT)
 -- Function File: [FNAME, FPATH, FLTIDX] = uiputfile (FLT, DIALOG_NAME)
 -- Function File: [FNAME, FPATH, FLTIDX] = uiputfile (FLT, DIALOG_NAME,
          DEFAULT_FILE)
     Open a GUI dialog for selecting a file.  FLT contains a (list of)
     file filter string(s) in one of the following formats:

     "/path/to/filename.ext"
          If a filename is given the file extension is extracted and
          used as filter.  In addition the path is selected as current
          path and the filename is selected as default file.  Example:
          'uiputfile ("myfun.m")'

     "*.ext"
          A single file extension.  Example: 'uiputfile ("*.ext")'

     '{"*.ext", "My Description"}'
          A 2-column cell array containing the file extension in the 1st
          column and a brief description in the 2nd column.  Example:
          'uiputfile ({"*.ext","My Description";"*.xyz", "XYZ-Format"})'

     The filter string can also contain a semicolon separated list of
     filter extensions.  Example: 'uiputfile ({"*.gif;*.png;*.jpg",
     "Supported Picture Formats"})'

     DIALOG_NAME can be used to customize the dialog title.  If
     DEFAULT_FILE is given it is preselected in the GUI dialog.  If, in
     addition, a path is given it is also used as current path.

     See also: uigetfile, uigetdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
DEFAULT_FILE)  Open a GUI dialog for selecting a file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
uiresume


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 314
 -- Function File: uiresume (H)
     Resume program execution suspended with 'uiwait'.  The handle H
     must be the same as the on specified in 'uiwait'.  If the handle is
     invalid or there is no 'uiwait' call pending for the figure with
     handle H, this function does nothing.

     See also: uiwait.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Resume program execution suspended with 'uiwait'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
uitoggletool


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
 -- Function File: HANDLE = uitoggletool ("Name", value, ...)
 -- Function File: HANDLE = uitoggletool (PARENT, "Name", value, ...)
   


# name: <cell-element>
# type: sq_string
# elements: 0



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
uitoolbar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
 -- Function File: HANDLE = uitoolbar ("Name", value, ...)
 -- Function File: HANDLE = uitoolbar (PARENT, "Name", value, ...)
   


# name: <cell-element>
# type: sq_string
# elements: 0



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
uiwait


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 847
 -- Function File: uiwait
 -- Function File: uiwait (H)
 -- Function File: uiwait (H, TIMEOUT)
     Suspend program execution until the figure with handle H is deleted
     or 'uiresume' is called.  When no figure handle is specified, this
     function uses the current figure.

     If the figure handle is invalid or there is no current figure, this
     functions returns immediately.

     When specified, TIMEOUT defines the number of seconds to wait for
     the figure deletion or the 'uiresume' call.  The timeout value must
     be at least 1.  If a smaller value is specified, a warning is
     issued and a timeout value of 1 is used instead.  If a non-integer
     value is specified, it is truncated towards 0.  If TIMEOUT is not
     specified, the program execution is suspended indefinitely.

     See also: uiresume, waitfor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Suspend program execution until the figure with handle H is deleted  or 'uiresume' is called.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
waitbar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 862
 -- Function File: H = waitbar (FRAC)
 -- Function File: H = waitbar (FRAC, MSG)
 -- Function File: H = waitbar (..., "FigureProperty", "Value", ...)
 -- Function File: waitbar (FRAC)
 -- Function File: waitbar (FRAC, HWBAR)
 -- Function File: waitbar (FRAC, HWBAR, MSG)
     Return a handle H to a new waitbar object.

     The waitbar is filled to fraction FRAC which must be in the range
     [0, 1].  The optional message MSG is centered and displayed above
     the waitbar.  The appearance of the waitbar figure window can be
     configured by passing property/value pairs to the function.

     When called with a single input the current waitbar, if it exists,
     is updated to the new value FRAC.  If there are multiple
     outstanding waitbars they can be updated individually by passing
     the handle HWBAR of the specific waitbar to modify.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Return a handle H to a new waitbar object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
waitforbuttonpress


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 295
 -- Function File: waitforbuttonpress ()
 -- Function File: B = waitforbuttonpress ()
     Wait for mouse click or key press over the current figure window.

     The return value of B is 0 if a mouse button was pressed or 1 if a
     key was pressed.

     See also: waitfor, ginput, kbhit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Wait for mouse click or key press over the current figure window.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
warndlg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 465
 -- Function File: H = warndlg (MSG)
 -- Function File: H = warndlg (MSG, TITLE)
     Display MSG using a warning dialog box.

     The message may have multiple lines separated by newline characters
     ("\n"), or it may be a cellstr array with one element for each
     line.  The optional input TITLE (character string) can be used to
     set the dialog caption.  The default title is "Warning Dialog".

     See also: helpdlg, inputdlg, listdlg, questdlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Display MSG using a warning dialog box.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
message_dialog


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
 -- Function File: H = message_dialog (CALLER, MSG, TITLE, ICON)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
doc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 523
 -- Command: doc FUNCTION_NAME
     Display documentation for the function FUNCTION_NAME directly from
     an online version of the printed manual, using the GNU Info
     browser.  If invoked without any arguments, the manual is shown
     from the beginning.

     For example, the command 'doc rand' starts the GNU Info browser at
     the 'rand' node in the online version of the manual.

     Once the GNU Info browser is running, help for using it is
     available using the command 'C-h'.

     See also: help.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 137
Display documentation for the function FUNCTION_NAME directly from  an online version of the printed manual, using the GNU Info  browser.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
doc_cache_create


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 481
 -- Function File: doc_cache_create (OUT_FILE, DIRECTORY)
     Generate documentation caches for all functions in a given
     directory.

     A documentation cache is generated for all functions in DIRECTORY.
     The resulting cache is saved in the file OUT_FILE.  The cache is
     used to speed up 'lookfor'.

     If no directory is given (or it is the empty matrix), a cache for
     built-in operators, etc.  is generated.

     See also: doc_cache_file, lookfor, path.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Generate documentation caches for all functions in a given  directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
get_first_help_sentence


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 866
 -- Function File: [TEXT, STATUS] = get_first_help_sentence (NAME)
 -- Function File: [TEXT, STATUS] = get_first_help_sentence (NAME,
          MAX_LEN)
     Return the first sentence of a function's help text.

     The first sentence is defined as the text after the function
     declaration until either the first period (".")  or the first
     appearance of two consecutive newlines ("\n\n").  The text is
     truncated to a maximum length of MAX_LEN, which defaults to 80.

     The optional output argument STATUS returns the status reported by
     'makeinfo'.  If only one output argument is requested, and STATUS
     is non-zero, a warning is displayed.

     As an example, the first sentence of this help text is

          get_first_help_sentence ("get_first_help_sentence")
          -| ans = Return the first sentence of a function's help text.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
MAX_LEN)  Return the first sentence of a function's help text.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
help


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 855
 -- Command: help NAME
 -- Command: help '--list'
 -- Command: help '.'
     Display the help text for NAME.  For example, the command 'help
     help' prints a short message describing the 'help' command.

     Given the single argument '--list', list all operators, keywords,
     built-in functions, and loadable functions available in the current
     session of Octave.

     Given the single argument '.', list all operators available in the
     current session of Octave.

     If invoked without any arguments, 'help' display instructions on
     how to access help from the command line.

     The help command can give you information about operators, but not
     the comma and semicolons that are used as command separators.  To
     get help for those, you must type 'help comma' or 'help semicolon'.

     See also: doc, lookfor, which.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Display the help text for NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
lookfor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1226
 -- Command: lookfor STR
 -- Command: lookfor -all STR
 -- Function File: [FUNC, HELPSTRING] = lookfor (STR)
 -- Function File: [FUNC, HELPSTRING] = lookfor ("-all", STR)
     Search for the string STR in all functions found in the current
     function search path.  By default, 'lookfor' searches for STR in
     the first sentence of the help string of each function found.  The
     entire help text of each function can be searched if the "-all"
     argument is supplied.  All searches are case insensitive.

     Called with no output arguments, 'lookfor' prints the list of
     matching functions to the terminal.  Otherwise, the output
     arguments FUNC and HELPSTRING define the matching functions and the
     first sentence of each of their help strings.

     The ability of 'lookfor' to correctly identify the first sentence
     of the help text is dependent on the format of the function's help.
     All Octave core functions are correctly formatted, but the same can
     not be guaranteed for external packages and user-supplied
     functions.  Therefore, the use of the "-all" argument may be
     necessary to find related functions that are not a part of Octave.

     See also: help, doc, which.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Search for the string STR in all functions found in the current  function search path.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
print_usage


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 280
 -- Function File: print_usage ()
 -- Function File: print_usage (NAME)
     Print the usage message for a function.  When called with no input
     arguments the 'print_usage' function displays the usage message of
     the currently executing function.

     See also: help.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Print the usage message for a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
type


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 582
 -- Command: type NAME ...
 -- Command: type -q NAME ...
 -- Function File: text = type ("NAME", ...)
     Display the contents of NAME which may be a file, function
     (m-file), variable, operator, or keyword.

     'type' normally prepends a header line describing the category of
     NAME such as function or variable; The '-q' option suppresses this
     behavior.

     If no output variable is used the contents are displayed on screen.
     Otherwise, a cell array of strings is returned, where each element
     corresponds to the contents of each requested function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
Display the contents of NAME which may be a file, function  (m-file), variable, operator, or keyword.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
which


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 190
 -- Command: which name ...
     Display the type of each NAME.  If NAME is defined from a function
     file, the full name of the file is also displayed.

     See also: help, lookfor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Display the type of each NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
autumn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 298
 -- Function File: MAP = autumn ()
 -- Function File: MAP = autumn (N)
     Create color colormap.  This colormap ranges from red through
     orange to yellow.  The argument N must be a scalar.  If
     unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
bone


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 302
 -- Function File: MAP = bone ()
 -- Function File: MAP = bone (N)
     Create color colormap.  This colormap varies from black to white
     with gray-blue shades.  The argument N must be a scalar.  If
     unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
brighten


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 684
 -- Function File: MAP_OUT = brighten (MAP, BETA)
 -- Function File: MAP_OUT = brighten (BETA)
 -- Function File: MAP_OUT = brighten (H, BETA)
     Brighten or darken a colormap.  If the MAP argument is omitted, the
     function is applied to the current colormap.  The first argument
     can also be a valid graphics handle H, in which case 'brighten' is
     applied to the colormap associated with this handle.

     The argument BETA must be a scalar between -1 and 1, where a
     negative value darkens and a positive value brightens the colormap.

     If no output is specified then the result is written to the current
     colormap.

     See also: colormap, contrast.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Brighten or darken a colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
cmpermute


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 619
 -- Function File: [Y, NEWMAP] = cmpermute (X, MAP)
 -- Function File: [Y, NEWMAP] = cmpermute (X, MAP, INDEX)
     Reorder colors in a colormap.

     When called with only two arguments, 'cmpermute' randomly
     rearranges the colormap MAP and returns a new colormap NEWMAP.  It
     also returns the indexed image Y which is the equivalent of the
     original input image X when displayed using NEWMAP.

     When called with an optional third argument the order of colors in
     the new colormap is defined by INDEX.

     *Caution:* 'index' should not have repeated elements or the
     function will fail.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Reorder colors in a colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cmunique


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1451
 -- Function File: [Y, NEWMAP] = cmunique (X, MAP)
 -- Function File: [Y, NEWMAP] = cmunique (RGB)
 -- Function File: [Y, NEWMAP] = cmunique (I)
     Convert an input image X to an ouput indexed image Y which uses the
     smallest colormap possible NEWMAP.

     When the input is an indexed image (X with colormap MAP) the output
     is a colormap NEWMAP from which any repeated rows have been
     eliminated.  The output image, Y, is the original input image with
     the indices adjusted to match the new, possibly smaller, colormap.

     When the input is an RGB image (an MxNx3 array), the output
     colormap will contain one entry for every unique color in the
     original image.  In the worst case the new map could have as many
     rows as the number of pixels in the original image.

     When the input is a grayscale image I, the output colormap will
     contain one entry for every unique intensity value in the original
     image.  In the worst case the new map could have as many rows as
     the number of pixels in the original image.

     Implementation Details:

     NEWMAP is always an Mx3 matrix, even if the input image is an
     intensity grayscale image I (all three RGB planes are assigned the
     same value).

     The output image is of class uint8 if the size of the new colormap
     is less than or equal to 256.  Otherwise, the output image is of
     class double.

     See also: rgb2ind, gray2ind.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Convert an input image X to an ouput indexed image Y which uses the  smallest colormap possible NEWMAP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
colorcube


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 526
 -- Function File: MAP = colorcube ()
 -- Function File: MAP = colorcube (N)
     Create color colormap.  This colormap is composed of as many
     equally spaced colors (not grays) in the RGB color space as
     possible.  If there are not a perfect number N of regularly spaced
     colors then the remaining entries in the colormap are gradients of
     pure red, green, blue, and gray.  The argument N must be a scalar.
     If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
colormap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1487
 -- Function File: CMAP = colormap ()
 -- Function File: CMAP = colormap (MAP)
 -- Function File: CMAP = colormap ("default")
 -- Function File: CMAP = colormap ("MAP_NAME")
 -- Function File: CMAP = colormap (HAX, ...)
 -- Command: colormap MAP_NAME
 -- Function File: CMAPS = colormap ("list")
 -- Function File: colormap ("register", "NAME")
 -- Function File: colormap ("unregister", "NAME")
     Query or set the current colormap.

     With no input arguments, 'colormap' returns the current color map.

     'colormap (MAP)' sets the current colormap to MAP.  The colormap
     should be an N row by 3 column matrix.  The columns contain red,
     green, and blue intensities respectively.  All entries must be
     between 0 and 1 inclusive.  The new colormap is returned.

     'colormap ("default")' restores the default colormap (the 'jet' map
     with 64 entries).  The default colormap is returned.

     The map may also be specified by a string, "MAP_NAME", where
     MAP_NAME is the name of a function that returns a colormap.

     If the first argument HAX is an axes handle, then the colormap for
     the parent figure of HAX is queried or set.

     For convenience, it is also possible to use this function with the
     command form, 'colormap MAP_NAME'.

     'colormap ("list")' returns a cell array with all of the available
     colormaps.  The options "register" and "unregister" add or remove
     the colormap NAME from this list.

     See also: jet.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Query or set the current colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
contrast


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 307
 -- Function File: CMAP = contrast (X)
 -- Function File: CMAP = contrast (X, N)
     Return a gray colormap that maximizes the contrast in an image.
     The returned colormap will have N rows.  If N is not defined then
     the size of the current colormap is used.

     See also: colormap, brighten.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return a gray colormap that maximizes the contrast in an image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cool


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 279
 -- Function File: MAP = cool ()
 -- Function File: MAP = cool (N)
     Create color colormap.  The colormap varies from cyan to magenta.
     The argument N must be a scalar.  If unspecified, the length of the
     current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
copper


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 298
 -- Function File: MAP = copper ()
 -- Function File: MAP = copper (N)
     Create color colormap.  This colormap varies from black to a light
     copper tone.  The argument N must be a scalar.  If unspecified, the
     length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
flag


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 324
 -- Function File: MAP = flag ()
 -- Function File: MAP = flag (N)
     Create color colormap.  This colormap cycles through red, white,
     blue, and black with each index change.  The argument N must be a
     scalar.  If unspecified, the length of the current colormap, or 64,
     is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gmap40


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 492
 -- Function File: MAP = gmap40 ()
 -- Function File: MAP = gmap40 (N)
     Create color colormap.  The colormap consists of red, green, blue,
     yellow, magenta and cyan.  This colormap is specifically designed
     for users of gnuplot 4.0 where these 6 colors are the allowable
     ones for patch objects.  The argument N must be a scalar.  If
     unspecified, a length of 6 is assumed.  Larger values of N result
     in a repetition of the above colors.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
gray


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 299
 -- Function File: MAP = gray ()
 -- Function File: MAP = gray (N)
     Create gray colormap.  This colormap varies from black to white
     with shades of gray.  The argument N must be a scalar.  If
     unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Create gray colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
gray2ind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 606
 -- Function File: IMG = gray2ind (I)
 -- Function File: IMG = gray2ind (I, N)
 -- Function File: IMG = gray2ind (BW)
 -- Function File: IMG = gray2ind (BW, N)
 -- Function File: [IMG, MAP] = gray2ind (...)
     Convert a grayscale or binary intensity image to an indexed image.

     The indexed image will consist of N different intensity values.  If
     not given N defaults to 64 for grayscale images or 2 for binary
     black and white images.

     The output IMG is of class uint8 if N is less than or equal to 256;
     Otherwise the return class is uint16.

     See also: ind2gray, rgb2ind.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Convert a grayscale or binary intensity image to an indexed image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
hot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 322
 -- Function File: MAP = hot ()
 -- Function File: MAP = hot (N)
     Create color colormap.  This colormap ranges from black through
     dark red, red, orange, yellow, to white.  The argument N must be a
     scalar.  If unspecified, the length of the current colormap, or 64,
     is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
hsv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 575
 -- Function File: hsv (N)
     Create color colormap.  This colormap begins with red, changes
     through yellow, green, cyan, blue, and magenta, before returning to
     red.  It is useful for displaying periodic functions.  The map is
     obtained by linearly varying the hue through all possible values
     while keeping constant maximum saturation and value.  The
     equivalent code is 'hsv2rgb ([(0:N-1)'/N, ones(N,2)])'.

     The argument N must be a scalar.  If unspecified, the length of the
     current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hsv2rgb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 580
 -- Function File: RGB_MAP = hsv2rgb (HSV_MAP)
 -- Function File: RGB_IMG = hsv2rgb (HSV_IMG)
     Transform a colormap or image from hue-saturation-value (HSV) space
     to red-green-blue (RGB) space.

     A color in HSV space is represented by hue, saturation and value
     (brightness) levels.  Value gives the amount of light in the color.
     Hue describes the dominant wavelength.  Saturation is the amount of
     hue mixed into the color.

     A color in the RGB space consists of red, green, and blue
     intensities.

     See also: rgb2hsv, ind2rgb, ntsc2rgb.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
Transform a colormap or image from hue-saturation-value (HSV) space  to red-green-blue (RGB) space.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
iscolormap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 344
 -- Function File: iscolormap (CMAP)
     Return true if CMAP is a colormap.

     A colormap is a real matrix with N rows and 3 columns.  Each row
     represents a single color.  The columns contain red, green, and
     blue intensities respectively.  All entries must be between 0 and 1
     inclusive.

     See also: colormap, rgbplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return true if CMAP is a colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
image


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1982
 -- Function File: image (IMG)
 -- Function File: image (X, Y, IMG)
 -- Function File: image (..., "PROP", VAL, ...)
 -- Function File: image ("PROP1", VAL1, ...)
 -- Function File: H = image (...)
     Display a matrix as an indexed color image.

     The elements of IMG are indices into the current colormap.  X and Y
     are optional 2-element vectors, '[min, max]', which specify the
     range for the axis labels.  If a range is specified as '[max, min]'
     then the image will be reversed along that axis.  For convenience,
     X and Y may be specified as N-element vectors matching the length
     of the data in IMG.  However, only the first and last elements will
     be used to determine the axis limits.  *Warning:* X and Y are
     ignored when using gnuplot 4.0 or earlier.

     Multiple property/value pairs may be specified for the image
     object, but they must appear in pairs.

     The optional return value H is a graphics handle to the image.

     Implementation Note: The origin (0, 0) for images is located in the
     upper left.  For ordinary plots, the origin is located in the lower
     left.  Octave handles this inversion by plotting the data normally,
     and then reversing the direction of the y-axis by setting the
     'ydir' property to "reverse".  This has implications whenever an
     image and an ordinary plot need to be overlaid.  The recommended
     solution is to display the image and then plot the reversed ydata
     using, for example, 'flipud (ydata)'.

     Calling Forms: The 'image' function can be called in two forms:
     High-Level and Low-Level.  When invoked with normal options, the
     High-Level form is used which first calls 'newplot' to prepare the
     graphic figure and axes.  When the only inputs to 'image' are
     property/value pairs the Low-Level form is used which creates a new
     instance of an image object and inserts it in the current axes.

     See also: imshow, imagesc, colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Display a matrix as an indexed color image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
imagesc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1316
 -- Function File: imagesc (IMG)
 -- Function File: imagesc (X, Y, IMG)
 -- Function File: imagesc (..., CLIMITS)
 -- Function File: imagesc (..., "PROP", VAL, ...)
 -- Function File: imagesc ("PROP1", VAL1, ...)
 -- Function File: imagesc (HAX, ...)
 -- Function File: H = imagesc (...)
     Display a scaled version of the matrix IMG as a color image.  The
     colormap is scaled so that the entries of the matrix occupy the
     entire colormap.  If 'CLIMITS = [LO, HI]' is given, then that range
     is set to the "clim" of the current axes.

     The axis values corresponding to the matrix elements are specified
     in X and Y, either as pairs giving the minimum and maximum values
     for the respective axes, or as values for each row and column of
     the matrix IMG.

     The optional return value H is a graphics handle to the image.

     Calling Forms: The 'imagesc' function can be called in two forms:
     High-Level and Low-Level.  When invoked with normal options, the
     High-Level form is used which first calls 'newplot' to prepare the
     graphic figure and axes.  When the only inputs to 'image' are
     property/value pairs the Low-Level form is used which creates a new
     instance of an image object and inserts it in the current axes.

     See also: image, imshow, caxis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Display a scaled version of the matrix IMG as a color image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
imfinfo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4107
 -- Function File: INFO = imfinfo (FILENAME)
 -- Function File: INFO = imfinfo (FILENAME, EXT)
 -- Function File: INFO = imfinfo (URL)
     Read image information from a file.

     'imfinfo' returns a structure containing information about the
     image stored in the file FILENAME.  If there is no file FILENAME,
     and EXT was specified, it will look for a file named FILENAME and
     extension EXT, i.e., a file named FILENAME.EXT.

     The output structure INFO contains the following fields:

     'Filename'
          The full name of the image file.

     'FileModDate'
          Date of last modification to the file.

     'FileSize'
          Number of bytes of the image on disk

     'Format'
          Image format (e.g., "jpeg").

     'Height'
          Image height in pixels.

     'Width'
          Image Width in pixels.

     'BitDepth'
          Number of bits per channel per pixel.

     'ColorType'
          Image type.  Value is "grayscale", "indexed", "truecolor",
          "CMYK", or "undefined".

     'XResolution'
          X resolution of the image.

     'YResolution'
          Y resolution of the image.

     'ResolutionUnit'
          Units of image resolution.  Value is "Inch", "Centimeter", or
          "undefined".

     'DelayTime'
          Time in 1/100ths of a second (0 to 65535) which must expire
          before displaying the next image in an animated sequence.

     'LoopCount'
          Number of iterations to loop an animation.

     'ByteOrder'
          Endian option for formats that support it.  Value is
          "little-endian", "big-endian", or "undefined".

     'Gamma'
          Gamma level of the image.  The same color image displayed on
          two different workstations may look different due to
          differences in the display monitor.

     'Quality'
          JPEG/MIFF/PNG compression level.  Value is an integer in the
          range [0 100].

     'DisposalMethod'
          Only valid for GIF images, control how successive frames are
          rendered (how the preceding frame is disposed of) when
          creating a GIF animation.  Values can be "doNotSpecify",
          "leaveInPlace", "restoreBG", or "restorePrevious".  For
          non-GIF files, value is an empty string.

     'Chromaticities'
          Value is a 1x8 Matrix with the x,y chromaticity values for
          white, red, green, and blue points, in that order.

     'Comment'
          Image comment.

     'Compression'
          Compression type.  Value can be "none", "bzip", "fax3",
          "fax4", "jpeg", "lzw", "rle", "deflate", "lzma", "jpeg2000",
          "jbig2", "jbig2", or "undefined".

     'Colormap'
          Colormap for each image.

     'Orientation'
          The orientation of the image with respect to the rows and
          columns.  Value is an integer between 1 and 8 as defined in
          the TIFF 6 specifications, and for MATLAB compatibility.

     'Software'
          Name and version of the software or firmware of the camera or
          image input device used to generate the image.

     'Make'
          The manufacturer of the recording equipment.  This is the
          manufacture of the DSC, scanner, video digitizer or other
          equipment that generated the image.

     'Model'
          The model name or model number of the recording equipment as
          mentioned on the field "Make".

     'DateTime'
          The date and time of image creation as defined by the Exif
          standard, i.e., it is the date and time the file was changed.

     'ImageDescription'
          The title of the image as defined by the Exif standard.

     'Artist'
          Name of the camera owner, photographer or image creator.

     'Copyright'
          Copyright notice of the person or organization claiming rights
          to the image.

     'DigitalCamera'
          A struct with information retrieved from the Exif tag.

     'GPSInfo'
          A struct with geotagging information retrieved from the Exif
          tag.

     See also: imread, imwrite, imshow, imformats.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Read image information from a file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
imformats


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1836
 -- Function File: imformats ()
 -- Function File: FORMATS = imformats (EXT)
 -- Function File: FORMATS = imformats (FORMAT)
 -- Function File: FORMATS = imformats ("add", FORMAT)
 -- Function File: FORMATS = imformats ("remove", EXT)
 -- Function File: FORMATS = imformats ("update", EXT, FORMAT)
 -- Function File: FORMATS = imformats ("factory")
     Manage supported image formats.

     FORMATS is a structure with information about each supported file
     format, or from a specific format EXT, the value displayed on the
     field 'ext'.  It contains the following fields:

     ext
          The name of the file format.  This may match the file
          extension but Octave will automatically detect the file
          format.

     description
          A long description of the file format.

     isa
          A function handle to confirm if a file is of the specified
          format.

     write
          A function handle to write if a file is of the specified
          format.

     read
          A function handle to open files the specified format.

     info
          A function handle to obtain image information of the specified
          format.

     alpha
          Logical value if format supports alpha channel (transparency
          or matte).

     multipage
          Logical value if format supports multipage (multiple images
          per file).

     It is possible to change the way Octave manages file formats with
     the options "add", "remove", and "update", and supplying a
     structure FORMAT with the required fields.  The option "factory"
     resets the configuration to the default.

     This can be used by Octave packages to extend the image reading
     capabilities Octave, through use of the PKG_ADD and PKG_DEL
     commands.

     See also: imfinfo, imread, imwrite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Manage supported image formats.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
imread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2483
 -- Function File: [IMG, MAP, ALPHA] = imread (FILENAME)
 -- Function File: [...] = imread (FILENAME, EXT)
 -- Function File: [...] = imread (URL)
 -- Function File: [...] = imread (..., IDX)
 -- Function File: [...] = imread (..., PARAM1, VAL1, ...)
     Read images from various file formats.

     Reads an image as a matrix from the file FILENAME.  If there is no
     file FILENAME, and EXT was specified, it will look for a file named
     FILENAME and extension EXT, i.e., a file named FILENAME.EXT.

     The size and class of the output depends on the format of the
     image.  A color image is returned as an MxNx3 matrix.  Gray-level
     and black-and-white images are of size MxN. Multipage images will
     have an additional 4th dimension.

     The bit depth of the image determines the class of the output:
     "uint8", "uint16" or "single" for gray and color, and "logical" for
     black and white.  Note that indexed images always return the
     indexes for a colormap, independent if MAP is a requested output.
     To obtain the actual RGB image, use 'ind2rgb'.  When more than one
     indexed image is being read, MAP is obtained from the first.  In
     some rare cases this may be incorrect and 'imfinfo' can be used to
     obtain the colormap of each image.

     See the Octave manual for more information in representing images.

     Some file formats, such as TIFF and GIF, are able to store multiple
     images in a single file.  IDX can be a scalar or vector specifying
     the index of the images to read.  By default, Octave will only read
     the first page.

     Depending on the file format, it is possible to configure the
     reading of images with PARAM, VAL pairs.  The following options are
     supported:

     '"Frames" or "Index"'
          This is an alternative method to specify IDX.  When specifying
          it in this way, its value can also be the string "all".

     '"Info"'
          This option exists for MATLAB compatibility and has no effect.
          For maximum performance while reading multiple images from a
          single file, use the Index option.

     '"PixelRegion"'
          Controls the image region that is read.  Takes as value a cell
          array with two arrays of 3 elements '{ROWS COLS}'.  The
          elements in the array are the start, increment and end pixel
          to be read.  If the increment value is omitted, defaults to 1.

     See also: imwrite, imfinfo, imformats.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Read images from various file formats.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
imshow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1730
 -- Function File: imshow (IM)
 -- Function File: imshow (IM, LIMITS)
 -- Function File: imshow (IM, MAP)
 -- Function File: imshow (RGB, ...)
 -- Function File: imshow (FILENAME)
 -- Function File: imshow (..., STRING_PARAM1, VALUE1, ...)
 -- Function File: H = imshow (...)
     Display the image IM, where IM can be a 2-dimensional (grayscale
     image) or a 3-dimensional (RGB image) matrix.

     If LIMITS is a 2-element vector '[LOW, HIGH]', the image is shown
     using a display range between LOW and HIGH.  If an empty matrix is
     passed for LIMITS, the display range is computed as the range
     between the minimal and the maximal value in the image.

     If MAP is a valid color map, the image will be shown as an indexed
     image using the supplied color map.

     If a file name is given instead of an image, the file will be read
     and shown.

     If given, the parameter STRING_PARAM1 has value VALUE1.
     STRING_PARAM1 can be any of the following:

     "displayrange"
          VALUE1 is the display range as described above.

     "xdata"
          If VALUE1 is a two element vector, it must contain horizontal
          axis limits in the form [xmin xmax]; Otherwise VALUE1 must be
          a vector and only the first and last elements will be used for
          xmin and xmax respectively.

     "ydata"
          If VALUE1 is a two element vector, it must contain vertical
          axis limits in the form [ymin ymax]; Otherwise VALUE1 must be
          a vector and only the first and last elements will be used for
          ymin and ymax respectively.

     The optional return value H is a graphics handle to the image.

     See also: image, imagesc, colormap, gray2ind, rgb2ind.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
Display the image IM, where IM can be a 2-dimensional (grayscale  image) or a 3-dimensional (RGB image) matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
imwrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3635
 -- Function File: imwrite (IMG, FILENAME)
 -- Function File: imwrite (IMG, FILENAME, EXT)
 -- Function File: imwrite (IMG, MAP, FILENAME)
 -- Function File: imwrite (..., PARAM1, VAL1, ...)
     Write images in various file formats.

     The image IMG can be a binary, grayscale, RGB, or multi-dimensional
     image.  The size and class of IMG should be the same as what should
     be expected when reading it with 'imread': the 3rd and 4th
     dimensions reserved for color space, and multiple pages
     respectively.  If it's an indexed image, the colormap MAP must also
     be specified.

     If EXT is not supplied, the file extension of FILENAME is used to
     determine the format.  The actual supported formats are dependent
     on options made during the build of Octave.  Use 'imformats' to
     check the support of the different image formats.

     Depending on the file format, it is possible to configure the
     writing of images with PARAM, VAL pairs.  The following options are
     supported:

     'Alpha'
          Alpha (transparency) channel for the image.  This must be a
          matrix with same class, and number of rows and columns of IMG.
          In case of a multipage image, the size of the 4th dimension
          must also match and the third dimension must be a singleton.
          By default, image will be completely opaque.

     'DelayTime'
          For formats that accept animations (such as GIF), controls for
          how long a frame is displayed until it moves to the next one.
          The value must be scalar (which will applied to all frames in
          IMG), or a vector of length equal to the number of frames in
          IM.  The value is in seconds, must be between 0 and 655.35,
          and defaults to 0.5.

     'DisposalMethod'
          For formats that accept animations (such as GIF), controls
          what happens to a frame before drawing the next one.  Its
          value can be one of the following strings: "doNotSpecify"
          (default); "leaveInPlace"; "restoreBG"; and "restorePrevious",
          or a cell array of those string with length equal to the
          number of frames in IMG.

     'LoopCount'
          For formats that accept animations (such as GIF), controls how
          many times the sequence is repeated.  A value of Inf means an
          infinite loop (default), a value of 0 or 1 that the sequence
          is played only once (loops zero times), while a value of 2 or
          above loops that number of times (looping twice means it plays
          the complete sequence 3 times).  This option is ignored when
          there is only a single image at the end of writing the file.

     'Quality'
          Set the quality of the compression.  The value should be an
          integer between 0 and 100, with larger values indicating
          higher visual quality and lower compression.  Defaults to 75.

     'WriteMode'
          Some file formats, such as TIFF and GIF, are able to store
          multiple images in a single file.  This option specifies if
          IMG should be appended to the file (if it exists) or if a new
          file should be created for it (possibly overwriting an
          existing file).  The value should be the string "Overwrite"
          (default), or "Append".

          Despite this option, the most efficient method of writing a
          multipage image is to pass a 4 dimensional IMG to 'imwrite',
          the same matrix that could be expected when using 'imread'
          with the option "Index" set to "all".

     See also: imread, imfinfo, imformats.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Write images in various file formats.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ind2gray


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 869
 -- Function File: I = ind2gray (X, MAP)
     Convert a color indexed image to a grayscale intensity image.

     The image X must be an indexed image which will be converted using
     the colormap CMAP.  If CMAP does not contain enough colors for the
     image, pixels in X outside the range are mapped to the last color
     in the map before conversion to grayscale.

     The output I is of the same class as the input X and may be one of
     'uint8', 'uint16', 'single', or 'double'.

     Implementation Note: There are several ways of converting colors to
     grayscale intensities.  This functions uses the luminance value
     obtained from 'rgb2ntsc' which is 'I = 0.299*R + 0.587*G +
     0.114*B'.  Other possibilities include the value component from
     'rgb2hsv' or using a single color channel from 'ind2rgb'.

     See also: gray2ind, ind2rgb.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Convert a color indexed image to a grayscale intensity image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ind2rgb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 802
 -- Function File: RGB = ind2rgb (X, MAP)
 -- Function File: [R, G, B] = ind2rgb (X, MAP)
     Convert an indexed image to red, green, and blue color components.

     The image X must be an indexed image which will be converted using
     the colormap MAP.  If MAP does not contain enough colors for the
     image, pixels in X outside the range are mapped to the last color
     in the map.

     The output may be a single RGB image (MxNx3 matrix where M and N
     are the original image X dimensions, one for each of the red, green
     and blue channels).  Alternatively, the individual red, green, and
     blue color matrices of size MxN may be returned.

     Multi-dimensional indexed images (of size MxNx1xK) are also
     supported.

     See also: rgb2ind, ind2gray, hsv2rgb, ntsc2rgb.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Convert an indexed image to red, green, and blue color components.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
jet


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 330
 -- Function File: MAP = jet ()
 -- Function File: MAP = jet (N)
     Create color colormap.  This colormap ranges from dark blue through
     blue, cyan, green, yellow, red, to dark red.  The argument N must
     be a scalar.  If unspecified, the length of the current colormap,
     or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
lines


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 405
 -- Function File: MAP = lines ()
 -- Function File: MAP = lines (N)
     Create color colormap.  This colormap is composed of the list of
     colors in the current axes "ColorOrder" property.  The default is
     blue, green, red, cyan, pink, yellow, and gray.  The argument N
     must be a scalar.  If unspecified, the length of the current
     colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ntsc2rgb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 530
 -- Function File: RGB_MAP = ntsc2rgb (YIQ_MAP)
 -- Function File: RGB_IMG = ntsc2rgb (YIQ_IMG)
     Transform a colormap or image from luminance-chrominance (NTSC)
     space to red-green-blue (RGB) color space.

     Implementation Note: The conversion matrix is chosen to be the
     inverse of the matrix used for rgb2ntsc such that

          x == ntsc2rgb (rgb2ntsc (x))

     MATLAB uses a slightly different matrix where rounding means the
     equality above does not hold.

     See also: rgb2ntsc, hsv2rgb, ind2rgb.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 107
Transform a colormap or image from luminance-chrominance (NTSC)  space to red-green-blue (RGB) color space.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ocean


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 302
 -- Function File: MAP = ocean ()
 -- Function File: MAP = ocean (N)
     Create color colormap.  This colormap varies from black to white
     with shades of blue.  The argument N must be a scalar.  If
     unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
pink


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 364
 -- Function File: MAP = pink ()
 -- Function File: MAP = pink (N)
     Create color colormap.  This colormap varies from black to white
     with shades of gray-pink.  It gives a sepia tone when used on
     grayscale images.  The argument N must be a scalar.  If
     unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
prism


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 342
 -- Function File: MAP = prism ()
 -- Function File: MAP = prism (N)
     Create color colormap.  This colormap cycles through red, orange,
     yellow, green, blue and violet with each index change.  The
     argument N must be a scalar.  If unspecified, the length of the
     current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rainbow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 327
 -- Function File: MAP = rainbow ()
 -- Function File: MAP = rainbow (N)
     Create color colormap.  This colormap ranges from red through
     orange, yellow, green, blue, to violet.  The argument N must be a
     scalar.  If unspecified, the length of the current colormap, or 64,
     is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rgb2hsv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 573
 -- Function File: HSV_MAP = rgb2hsv (RGB)
 -- Function File: HSV_MAP = rgb2hsv (RGB)
     Transform a colormap or image from red-green-blue (RGB) space to
     hue-saturation-value (HSV) space.

     A color in the RGB space consists of red, green, and blue
     intensities.

     A color in HSV space is represented by hue, saturation, and value
     (brightness) levels.  Value gives the amount of light in the color.
     Hue describes the dominant wavelength.  Saturation is the amount of
     hue mixed into the color.

     See also: hsv2rgb, rgb2ind, rgb2ntsc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
Transform a colormap or image from red-green-blue (RGB) space to  hue-saturation-value (HSV) space.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rgb2ind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 977
 -- Function File: [X, MAP] = rgb2ind (RGB)
 -- Function File: [X, MAP] = rgb2ind (R, G, B)
     Convert an image in red-green-blue (RGB) color space to an indexed
     image.

     The input image RGB can be specified as a single matrix of size
     MxNx3, or as three separate variables, R, G, and B, its three
     colour channels, red, green, and blue.

     It outputs an indexed image X and a colormap MAP to interpret an
     image exactly the same as the input.  No dithering or other form of
     color quantization is performed.  The output class of the indexed
     image X can be uint8, uint16 or double, whichever is required to
     specify the number of unique colors in the image (which will be
     equal to the number of rows in MAP) in order

     Multi-dimensional indexed images (of size MxNx3xK) are also
     supported, both via a single input (RGB) or its three colour
     channels as separate variables.

     See also: ind2rgb, rgb2hsv, rgb2ntsc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Convert an image in red-green-blue (RGB) color space to an indexed  image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
rgb2ntsc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 759
 -- Function File: YIQ_MAP = rgb2ntsc (RGB_MAP)
 -- Function File: YIQ_IMG = rgb2ntsc (RGB_IMG)
     Transform a colormap or image from red-green-blue (RGB) color space
     to luminance-chrominance (NTSC) space.  The input may be of class
     uint8, uint16, single, or double.  The output is of class double.

     Implementation Note: The reference matrix for the transformation is

          /Y\     0.299  0.587  0.114  /R\
          |I|  =  0.596 -0.274 -0.322  |G|
          \Q/     0.211 -0.523  0.312  \B/

     as documented in <http://en.wikipedia.org/wiki/YIQ> and truncated
     to 3 significant figures.  Note: The FCC version of NTSC uses only
     2 significant digits and is slightly different.

     See also: ntsc2rgb, rgb2hsv, rgb2ind.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 107
Transform a colormap or image from red-green-blue (RGB) color space  to luminance-chrominance (NTSC) space.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rgbplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 859
 -- Function File: rgbplot (CMAP)
 -- Function File: rgbplot (CMAP, STYLE)
 -- Function File: H = rgbplot (...)
     Plot the components of a colormap.

     Two different STYLEs are available for displaying the CMAP:

     profile (default)
          Plot the RGB line profile of the colormap for each of the
          channels (red, green and blue) with the plot lines colored
          appropriately.  Each line represents the intensity of each RGB
          components across the colormap.

     composite
          Draw the colormap across the X-axis so that the actual index
          colors are visible rather than the individual color
          components.

     The optional return value H is a graphics handle to the created
     plot.

     Run 'demo rgbplot' to see an example of 'rgbplot' and each style
     option.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Plot the components of a colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
spinmap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 645
 -- Function File: spinmap ()
 -- Function File: spinmap (T)
 -- Function File: spinmap (T, INC)
 -- Function File: spinmap ("inf")
     Cycle the colormap for T seconds with a color increment of INC.
     Both parameters are optional.  The default cycle time is 5 seconds
     and the default increment is 2.  If the option "inf" is given then
     cycle continuously until 'Control-C' is pressed.

     When rotating the original color 1 becomes color 2, color 2 becomes
     color 3, etc.  A positive or negative increment is allowed and a
     higher value of INC will cause faster cycling through the colormap.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Cycle the colormap for T seconds with a color increment of INC.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
spring


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 287
 -- Function File: MAP = spring ()
 -- Function File: MAP = spring (N)
     Create color colormap.  This colormap varies from magenta to
     yellow.  The argument N must be a scalar.  If unspecified, the
     length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
summer


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 284
 -- Function File: MAP = summer ()
 -- Function File: MAP = summer (N)
     Create color colormap.  This colormap varies from green to yellow.
     The argument N must be a scalar.  If unspecified, the length of the
     current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
white


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 280
 -- Function File: MAP = white ()
 -- Function File: MAP = white (N)
     Create color colormap.  This colormap is completely white.  The
     argument N should be a scalar.  If it is omitted, the length of the
     current colormap or 64 is assumed.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
winter


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 282
 -- Function File: MAP = winter ()
 -- Function File: MAP = winter (N)
     Create color colormap.  This colormap varies from blue to green.
     The argument N must be a scalar.  If unspecified, the length of the
     current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
__imfinfo__ This function does al the work of imfinfo.  It exists


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 171
here as private function so that imfinfo can use other functions if
imformats is configured to.  It is also needed so that imformats can
create a function handle for it.  


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
here as private function so that imfinfo can use other functions if imformats is configured to.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
__imread__ This function does all the


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 197
work of imread.  It exists here as private function so that imread can
use other functions if imformats is configured to.  It is also needed so
that imformats can create a function handle for it.  


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
work of imread.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
__imwrite__ This


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 221
function does all the work of imwrite.  It exists here as private
function so that imwrite can use other functions if imformats is
configured to.  It is also needed so that imformats can create a
function handle for it.  


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
function does all the work of imwrite.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
imageIO This function simply connects imread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 874
and imfinfo() to the function to be used based on their format.  It does
it by checking the file extension of the file and redirecting to the
appropriate function after checking with imformats.

   First argument is a function handle for the default imageIO function
(what to use if the file extension for the image file is not listed by
imformats).  Second argument is the fieldname in the struct returned by
imformats with a function handle for the function to use.  Third
argument is a cell array, its first element the filename, and the
second, an optional file extension to add to filename, if filename alone
does not exist.  All the others are the original input arguments passed
to the original imageIO function which will be passed on to the
destination function.

   No input checking whatsoever is performed.  That should be performed
by the function calling it.  


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
and imfinfo() to the function to be used based on their format.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
imwrite_filename The input check for


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 613
imwrite needs to be done twice, once when imwrite is called the first
time to find where the filename is, and a second time by __imwrite__
after imformats decides what function to use.  Because a user can, and
is encouraged to, get a function handle to __imwrite__, the input check
is also done there.  In addition, the input check for imwrite is not
that straightforward in order to support the multiple ways the function
can be called, and interpretations of Matlab documentation.

   Anyway, this will only do the input check until it finds the filename
to be used, the only part that imwrite actually needs.  


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 184
imwrite needs to be done twice, once when imwrite is called the first time to find where the filename is, and a second time by __imwrite__ after imformats decides what function to use.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
ind2x private


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
function for the ind2XXX functions which have a lot of code in common



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
function for the ind2XXX functions which have a lot of code in common 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
beep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 131
 -- Function File: beep ()
     Produce a beep from the speaker (or visual bell).

     See also: puts, fputs, printf, fprintf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Produce a beep from the speaker (or visual bell).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
csvread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 293
 -- Function File: X = csvread (FILENAME)
 -- Function File: X = csvread (FILENAME, DLM_OPTS)
     Read the comma-separated-value file FILENAME into the matrix X.

     This function is equivalent to

          X = dlmread (FILENAME, "," , ...)

     See also: csvwrite, dlmread, dlmwrite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Read the comma-separated-value file FILENAME into the matrix X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
csvwrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 305
 -- Function File: csvwrite (FILENAME, X)
 -- Function File: csvwrite (FILENAME, X, DLM_OPTS)
     Write the matrix X to the file FILENAME in comma-separated-value
     format.

     This function is equivalent to

          dlmwrite (FILENAME, X, ",", ...)

     See also: csvread, dlmwrite, dlmread.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Write the matrix X to the file FILENAME in comma-separated-value  format.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
dlmwrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1656
 -- Function File: dlmwrite (FILE, M)
 -- Function File: dlmwrite (FILE, M, DELIM, R, C)
 -- Function File: dlmwrite (FILE, M, KEY, VAL ...)
 -- Function File: dlmwrite (FILE, M, "-append", ...)
 -- Function File: dlmwrite (FID, ...)
     Write the matrix M to the named file using delimiters.

     FILE should be a file name or writable file ID given by 'fopen'.

     The parameter DELIM specifies the delimiter to use to separate
     values on a row.

     The value of R specifies the number of delimiter-only lines to add
     to the start of the file.

     The value of C specifies the number of delimiters to prepend to
     each line of data.

     If the argument "-append" is given, append to the end of FILE.

     In addition, the following keyword value pairs may appear at the
     end of the argument list:

     "append"
          Either "on" or "off".  See "-append" above.

     "delimiter"
          See DELIM above.

     "newline"
          The character(s) to use to separate each row.  Three special
          cases exist for this option.  "unix" is changed into "\n",
          "pc" is changed into "\r\n", and "mac" is changed into "\r".
          Other values for this option are kept as is.

     "roffset"
          See R above.

     "coffset"
          See C above.

     "precision"
          The precision to use when writing the file.  It can either be
          a format string (as used by fprintf) or a number of
          significant digits.

          dlmwrite ("file.csv", reshape (1:16, 4, 4));

          dlmwrite ("file.tex", a, "delimiter", "&", "newline", "\\n")

     See also: dlmread, csvread, csvwrite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Write the matrix M to the named file using delimiters.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
fileread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 151
 -- Function File: STR = fileread (FILENAME)
     Read the contents of FILENAME and return it as a string.

     See also: fread, textread, sscanf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Read the contents of FILENAME and return it as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
importdata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 987
 -- Function File: A = importdata (FNAME)
 -- Function File: A = importdata (FNAME, DELIMITER)
 -- Function File: A = importdata (FNAME, DELIMITER, HEADER_ROWS)
 -- Function File: [A, DELIMITER] = importdata (...)
 -- Function File: [A, DELIMITER, HEADER_ROWS] = importdata (...)
     Import data from the file FNAME.

     Input parameters:

        * FNAME The name of the file containing data.

        * DELIMITER The character separating columns of data.  Use '\t'
          for tab.  (Only valid for ASCII files)

        * HEADER_ROWS The number of header rows before the data begins.
          (Only valid for ASCII files)

     Different file types are supported:

        * ASCII table

          Import ASCII table using the specified number of header rows
          and the specified delimiter.

        * Image file

        * MATLAB file

        * Spreadsheet files (depending on external software)

        * WAV file

     See also: textscan, dlmread, csvread, load.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Import data from the file FNAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
is_valid_file_id


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
 -- Function File: is_valid_file_id (FID)
     Return true if FID refers to an open file.

     See also: fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Return true if FID refers to an open file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5022
 -- Function File: [A, ...] = strread (STR)
 -- Function File: [A, ...] = strread (STR, FORMAT)
 -- Function File: [A, ...] = strread (STR, FORMAT, FORMAT_REPEAT)
 -- Function File: [A, ...] = strread (STR, FORMAT, PROP1, VALUE1, ...)
 -- Function File: [A, ...] = strread (STR, FORMAT, FORMAT_REPEAT,
          PROP1, VALUE1, ...)
     Read data from a string.

     The string STR is split into words that are repeatedly matched to
     the specifiers in FORMAT.  The first word is matched to the first
     specifier, the second to the second specifier and so forth.  If
     there are more words than specifiers, the process is repeated until
     all words have been processed.

     The string FORMAT describes how the words in STR should be parsed.
     It may contain any combination of the following specifiers:

     '%s'
          The word is parsed as a string.

     '%f'
     '%n'
          The word is parsed as a number and converted to double.

     '%d'
     '%u'
          The word is parsed as a number and converted to int32.

     '%*', '%*f', '%*s'
          The word is skipped.

          For %s and %d, %f, %n, %u and the associated %*s ...
          specifiers an optional width can be specified as %Ns, etc.
          where N is an integer > 1.  For %f, format specifiers like
          %N.Mf are allowed.

     'literals'
          In addition the format may contain literal character strings;
          these will be skipped during reading.

     Parsed word corresponding to the first specifier are returned in
     the first output argument and likewise for the rest of the
     specifiers.

     By default, FORMAT is "%f", meaning that numbers are read from STR.
     This will do if STR contains only numeric fields.

     For example, the string

          STR = "\
          Bunny Bugs   5.5\n\
          Duck Daffy  -7.5e-5\n\
          Penguin Tux   6"

     can be read using

          [A, B, C] = strread (STR, "%s %s %f");

     Optional numeric argument FORMAT_REPEAT can be used for limiting
     the number of items read:

     -1
          (default) read all of the string until the end.

     N
          Read N times NARGOUT items.  0 (zero) is an acceptable value
          for FORMAT_REPEAT.

     The behavior of 'strread' can be changed via property-value pairs.
     The following properties are recognized:

     "commentstyle"
          Parts of STR are considered comments and will be skipped.
          VALUE is the comment style and can be any of the following.

             * "shell" Everything from '#' characters to the nearest
               end-of-line is skipped.

             * "c" Everything between '/*' and '*/' is skipped.

             * "c++" Everything from '//' characters to the nearest
               end-of-line is skipped.

             * "matlab" Everything from '%' characters to the nearest
               end-of-line is skipped.

             * user-supplied.  Two options: (1) One string, or 1x1 cell
               string: Skip everything to the right of it; (2) 2x1 cell
               string array: Everything between the left and right
               strings is skipped.

     "delimiter"
          Any character in VALUE will be used to split STR into words
          (default value = any whitespace).

     "emptyvalue":
          Value to return for empty numeric values in non-whitespace
          delimited data.  The default is NaN.  When the data type does
          not support NaN (int32 for example), then default is zero.

     "multipledelimsasone"
          Treat a series of consecutive delimiters, without whitespace
          in between, as a single delimiter.  Consecutive delimiter
          series need not be vertically "aligned".

     "treatasempty"
          Treat single occurrences (surrounded by delimiters or
          whitespace) of the string(s) in VALUE as missing values.

     "returnonerror"
          If VALUE true (1, default), ignore read errors and return
          normally.  If false (0), return an error.

     "whitespace"
          Any character in VALUE will be interpreted as whitespace and
          trimmed; the string defining whitespace must be enclosed in
          double quotes for proper processing of special characters like
          \t.  The default value for whitespace = " \b\r\n\t" (note the
          space).  Unless whitespace is set to " (empty) AND at least
          one "%s" format conversion specifier is supplied, a space is
          always part of whitespace.

     When the number of words in STR doesn't match an exact multiple of
     the number of format conversion specifiers, strread's behavior
     depends on the last character of STR:

     last character = "\n"
          Data columns are padded with empty fields or Nan so that all
          columns have equal length

     last character is not "\n"
          Data columns are not padded; strread returns columns of
          unequal length

     See also: textscan, textread, load, dlmread, fscanf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
PROP1, VALUE1, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
textscan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2577
 -- Function File: C = textscan (FID, FORMAT)
 -- Function File: C = textscan (FID, FORMAT, N)
 -- Function File: C = textscan (FID, FORMAT, PARAM, VALUE, ...)
 -- Function File: C = textscan (FID, FORMAT, N, PARAM, VALUE, ...)
 -- Function File: C = textscan (STR, ...)
 -- Function File: [C, POSITION] = textscan (FID, ...)
     Read data from a text file or string.

     The string STR or file associated with FID is read from and parsed
     according to FORMAT.  The function behaves like 'strread' except it
     can also read from file instead of a string.  See the documentation
     of 'strread' for details.

     In addition to the options supported by 'strread', this function
     supports a few more:

        * "collectoutput": A value of 1 or true instructs textscan to
          concatenate consecutive columns of the same class in the
          output cell array.  A value of 0 or false (default) leaves
          output in distinct columns.

        * "endofline": Specify "\r", "\n" or "\r\n" (for CR, LF, or
          CRLF). If no value is given, it will be inferred from the
          file.  If set to "" (empty string) EOLs are ignored as
          delimiters and added to whitespace.

        * "headerlines": The first VALUE number of lines of FID are
          skipped.

        * "returnonerror": If set to numerical 1 or true (default),
          return normally when read errors have been encountered.  If
          set to 0 or false, return an error and no data.  As the string
          or file is read by columns rather than by rows, and because
          textscan is fairly forgiving as regards read errors, setting
          this option may have little or no actual effect.

     When reading from a character string, optional input argument N
     specifies the number of times FORMAT should be used (i.e., to limit
     the amount of data read).  When reading from file, N specifies the
     number of data lines to read; in this sense it differs slightly
     from the format repeat count in strread.

     The output C is a cell array whose second dimension is determined
     by the number of format specifiers.

     The second output, POSITION, provides the position, in characters,
     from the beginning of the file.

     If the format string is empty (not: omitted) and the file contains
     only numeric data (excluding headerlines), textscan will return
     data in a number of columns matching the number of numeric fields
     on the first data line of the file.

     See also: dlmread, fscanf, load, strread, textread.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Read data from a text file or string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
textread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1529
 -- Function File: [A, ...] = textread (FILENAME)
 -- Function File: [A, ...] = textread (FILENAME, FORMAT)
 -- Function File: [A, ...] = textread (FILENAME, FORMAT, N)
 -- Function File: [A, ...] = textread (FILENAME, FORMAT, PROP1, VALUE1,
          ...)
 -- Function File: [A, ...] = textread (FILENAME, FORMAT, N, PROP1,
          VALUE1, ...)
     Read data from a text file.

     The file FILENAME is read and parsed according to FORMAT.  The
     function behaves like 'strread' except it works by parsing a file
     instead of a string.  See the documentation of 'strread' for
     details.

     In addition to the options supported by 'strread', this function
     supports two more:

        * "headerlines": The first VALUE number of lines of FILENAME are
          skipped.

        * "endofline": Specify a single character or "\r\n".  If no
          value is given, it will be inferred from the file.  If set to
          "" (empty string) EOLs are ignored as delimiters.

     The optional input N specifies the number of data lines to read; in
     this sense it differs slightly from the format repeat count in
     strread.

     If the format string is empty (not: omitted) and the file contains
     only numeric data (excluding headerlines), textread will return a
     rectangular matrix with the number of columns matching the number
     of numeric fields on the first data line of the file.  Empty fields
     are returned as zero values.

     See also: strread, load, dlmread, fscanf, textscan.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
java_get


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 501
 -- Function File: VAL = java_get (OBJ, NAME)
     Get the value of the field NAME of the Java object OBJ.  For static
     fields, OBJ can be a string representing the fully qualified name
     of the corresponding class.

     When OBJ is a regular Java object, structure-like indexing can be
     used as a shortcut syntax.  For instance, the two following
     statements are equivalent

            java_get (x, "field1")
            x.field1

     See also: java_set, javaMethod, javaObject.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Get the value of the field NAME of the Java object OBJ.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
java_set


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 530
 -- Function File: OBJ = java_set (OBJ, NAME, VAL)
     Set the value of the field NAME of the Java object OBJ to VAL.  For
     static fields, OBJ can be a string representing the fully qualified
     named of the corresponding Java class.

     When OBJ is a regular Java object, structure-like indexing can be
     used as a shortcut syntax.  For instance, the two following
     statements are equivalent

            java_set (x, "field1", val)
            x.field1 = val

     See also: java_get, javaMethod, javaObject.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Set the value of the field NAME of the Java object OBJ to VAL.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
javaArray


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 718
 -- Function File: JARY = javaArray (CLASSNAME, SZ)
 -- Function File: JARY = javaArray (CLASSNAME, M, N, ...)

     Create a Java array of size SZ with elements of class CLASSNAME.
     CLASSNAME may be a Java object representing a class or a string
     containing the fully qualified class name.  The size of the object
     may also be specified with individual integer arguments M, N, etc.

     The generated array is uninitialized.  All elements are set to null
     if CLASSNAME is a reference type, or to a default value (usually 0)
     if CLASSNAME is a primitive type.

     Sample code:

          jary = javaArray ("java.lang.String", 2, 2);
          jary(1,1) = "Hello";

     See also: javaObject.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Create a Java array of size SZ with elements of class CLASSNAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
javaaddpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 402
 -- Function File: javaaddpath (CLSPATH)
 -- Function File: javaaddpath (CLSPATH1, ...)
     Add CLSPATH to the dynamic class path of the Java virtual machine.
     CLSPATH may either be a directory where '.class' files are found,
     or a '.jar' file containing Java classes.  Multiple paths may be
     added at once by specifying additional arguments.

     See also: javarmpath, javaclasspath.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Add CLSPATH to the dynamic class path of the Java virtual machine.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
javaclasspath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1027
 -- Function File: javaclasspath ()
 -- Function File: DPATH = javaclasspath ()
 -- Function File: [DPATH, SPATH] = javaclasspath ()
 -- Function File: CLSPATH = javaclasspath (WHAT)
     Return the class path of the Java virtual machine in the form of a
     cell array of strings.

     If called with no inputs:

        * If no output is requested, the dynamic and static classpaths
          are printed to the standard output.

        * If one output value DPATH is requested, the result is the
          dynamic classpath.

        * If two output valuesDPATH and SPATH are requested, the first
          variable will contain the dynamic classpath and the second
          will be contain the static classpath.

     If called with a single input parameter WHAT:

     "-dynamic"
          Return the dynamic classpath.

     "-static"
          Return the static classpath.

     "-all"
          Return both the static and dynamic classpath in a single
          cellstr.

     See also: javaaddpath, javarmpath.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Return the class path of the Java virtual machine in the form of a  cell array of strings.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
javamem


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1728
 -- Function File: javamem ()
 -- Function File: JMEM = javamem ()
     Show the current memory usage of the Java virtual machine (JVM) and
     run the garbage collector.

     When no return argument is given the info is printed to the screen.
     Otherwise, the output cell array JMEM contains Maximum, Total, and
     Free memory (in bytes).

     All Java-based routines are run in the JVM's shared memory pool, a
     dedicated and separate part of memory claimed by the JVM from your
     computer's total memory (which comprises physical RAM and virtual
     memory / swap space on hard disk).

     The maximum allowable memory usage can be configured using the file
     'java.opts'.  The directory where this file resides is determined
     by the environment variable 'OCTAVE_JAVA_DIR'.  If unset, the
     directory where 'javaaddpath.m' resides is used instead (typically
     'OCTAVE_HOME/share/octave/OCTAVE_VERSION/m/java/'

     'java.opts' is a plain text file with one option per line.  The
     default initial memory size and default maximum memory size (which
     are both system dependent) can be overridden like so:

     -Xms64m

     -Xmx512m

     (in megabytes in this example).  You can adapt these values to your
     own requirements if your system has limited available physical
     memory or if you get Java memory errors.

     "Total memory" is what the operating system has currently assigned
     to the JVM and depends on actual and active memory usage.  "Free
     memory" is self-explanatory.  During operation of Java-based Octave
     functions the amount of Total and Free memory will vary, due to
     Java's own cleaning up and your operating system's memory
     management.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Show the current memory usage of the Java virtual machine (JVM) and  run the garbage collector.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
javarmpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 409
 -- Function File: javarmpath (CLSPATH)
 -- Function File: javarmpath (CLSPATH1, ...)
     Remove CLSPATH from the dynamic class path of the Java virtual
     machine.  CLSPATH may either be a directory where '.class' files
     are found, or a '.jar' file containing Java classes.  Multiple
     paths may be removed at once by specifying additional arguments.

     See also: javaaddpath, javaclasspath.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Remove CLSPATH from the dynamic class path of the Java virtual  machine.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
usejava


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 754
 -- Function File: usejava (FEATURE)
     Return true if the Java element FEATURE is available.

     Possible features are:

     "awt"
          Abstract Window Toolkit for GUIs.

     "desktop"
          Interactive desktop is running.

     "jvm"
          Java Virtual Machine.

     "swing"
          Swing components for lightweight GUIs.

     'usejava' determines if specific Java features are available in an
     Octave session.  This function is provided for scripts which may
     alter their behavior based on the availability of Java.  The
     feature "desktop" always returns 'false' as Octave has no
     Java-based desktop.  Other features may be available if Octave was
     compiled with the Java Interface and Java is installed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return true if the Java element FEATURE is available.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
commutation_matrix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 385
 -- Function File: commutation_matrix (M, N)
     Return the commutation matrix K(m,n) which is the unique M*N by M*N
     matrix such that K(m,n) * vec(A) = vec(A') for all m by n matrices
     A.

     If only one argument M is given, K(m,m) is returned.

     See Magnus and Neudecker (1988), 'Matrix Differential Calculus with
     Applications in Statistics and Econometrics.'
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 139
Return the commutation matrix K(m,n) which is the unique M*N by M*N  matrix such that K(m,n) * vec(A) = vec(A') for all m by n matrices  A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cond


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 939
 -- Function File: cond (A)
 -- Function File: cond (A, P)
     Compute the P-norm condition number of a matrix.

     'cond (A)' is defined as 'norm (A, P) * norm (inv (A), P)'.

     By default, 'P = 2' is used which implies a (relatively slow)
     singular value decomposition.  Other possible selections are 'P =
     1, Inf, "fro"' which are generally faster.  See 'norm' for a full
     discussion of possible P values.

     The condition number of a matrix quantifies the sensitivity of the
     matrix inversion operation when small changes are made to matrix
     elements.  Ideally the condition number will be close to 1.  When
     the number is large this indicates small changes (such as underflow
     or round-off error) will produce large changes in the resulting
     output.  In such cases the solution results from numerical
     computing are not likely to be accurate.

     See also: condest, rcond, norm, svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Compute the P-norm condition number of a matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
condest


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1684
 -- Function File: condest (A)
 -- Function File: condest (A, T)
 -- Function File: [EST, V] = condest (...)
 -- Function File: [EST, V] = condest (A, SOLVE, SOLVE_T, T)
 -- Function File: [EST, V] = condest (APPLY, APPLY_T, SOLVE, SOLVE_T,
          N, T)

     Estimate the 1-norm condition number of a matrix A using T test
     vectors using a randomized 1-norm estimator.  If T exceeds 5, then
     only 5 test vectors are used.

     If the matrix is not explicit, e.g., when estimating the condition
     number of A given an LU factorization, 'condest' uses the following
     functions:

     APPLY
          'A*x' for a matrix 'x' of size N by T.

     APPLY_T
          'A'*x' for a matrix 'x' of size N by T.

     SOLVE
          'A \ b' for a matrix 'b' of size N by T.

     SOLVE_T
          'A' \ b' for a matrix 'b' of size N by T.

     The implicit version requires an explicit dimension N.

     'condest' uses a randomized algorithm to approximate the 1-norms.

     'condest' returns the 1-norm condition estimate EST and a vector V
     satisfying 'norm (A*v, 1) == norm (A, 1) * norm (V, 1) / EST'.
     When EST is large, V is an approximate null vector.

     References:

        * N.J. Higham and F. Tisseur, 'A Block Algorithm for Matrix
          1-Norm Estimation, with an Application to 1-Norm
          Pseudospectra'.  SIMAX vol 21, no 4, pp 1185-1201.
          <http://dx.doi.org/10.1137/S0895479899356080>

        * N.J. Higham and F. Tisseur, 'A Block Algorithm for Matrix
          1-Norm Estimation, with an Application to 1-Norm
          Pseudospectra'.  <http://citeseer.ist.psu.edu/223007.html>

     See also: cond, norm, onenormest.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
N, T) 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
cross


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 472
 -- Function File: cross (X, Y)
 -- Function File: cross (X, Y, DIM)
     Compute the vector cross product of two 3-dimensional vectors X and
     Y.

          cross ([1,1,0], [0,1,1])
               => [ 1; -1; 1 ]

     If X and Y are matrices, the cross product is applied along the
     first dimension with 3 elements.  The optional argument DIM forces
     the cross product to be calculated along the specified dimension.

     See also: dot, curl, divergence.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Compute the vector cross product of two 3-dimensional vectors X and  Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
duplication_matrix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 329
 -- Function File: duplication_matrix (N)
     Return the duplication matrix Dn which is the unique n^2 by
     n*(n+1)/2 matrix such that Dn vech (A) = vec (A) for all symmetric
     n by n matrices A.

     See Magnus and Neudecker (1988), Matrix differential calculus with
     applications in statistics and econometrics.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 147
Return the duplication matrix Dn which is the unique n^2 by  n*(n+1)/2 matrix such that Dn vech (A) = vec (A) for all symmetric  n by n matrices A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
expm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 914
 -- Function File: expm (A)
     Return the exponential of a matrix, defined as the infinite Taylor
     series

          expm (A) = I + A + A^2/2! + A^3/3! + ...

     The Taylor series is _not_ the way to compute the matrix
     exponential; see Moler and Van Loan, 'Nineteen Dubious Ways to
     Compute the Exponential of a Matrix', SIAM Review, 1978.  This
     routine uses Ward's diagonal Pade' approximation method with three
     step preconditioning (SIAM Journal on Numerical Analysis, 1977).
     Diagonal Pade' approximations are rational polynomials of matrices

               -1
          D (A)   N (A)

     whose Taylor series matches the first '2q+1' terms of the Taylor
     series above; direct evaluation of the Taylor series (with the same
     preconditioning steps) may be desirable in lieu of the Pade'
     approximation when 'Dq(A)' is ill-conditioned.

     See also: logm, sqrtm.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return the exponential of a matrix, defined as the infinite Taylor  series 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
housh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 607
 -- Function File: [HOUSV, BETA, ZER] = housh (X, J, Z)
     Compute Householder reflection vector HOUSV to reflect X to be the
     j-th column of identity, i.e.,

          (I - beta*housv*housv')x =  norm (x)*e(j) if x(j) < 0,
          (I - beta*housv*housv')x = -norm (x)*e(j) if x(j) >= 0

     Inputs

     X
          vector

     J
          index into vector

     Z
          threshold for zero (usually should be the number 0)

     Outputs (see Golub and Van Loan):

     BETA
          If beta = 0, then no reflection need be applied (zer set to 0)

     HOUSV
          householder vector
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Compute Householder reflection vector HOUSV to reflect X to be the  j-th column of identity, i.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
isdefinite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 358
 -- Function File: isdefinite (X)
 -- Function File: isdefinite (X, TOL)
     Return 1 if X is symmetric positive definite within the tolerance
     specified by TOL or 0 if X is symmetric positive semidefinite.
     Otherwise, return -1.  If TOL is omitted, use a tolerance of '100 *
     eps * norm (X, "fro")'

     See also: issymmetric, ishermitian.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
Return 1 if X is symmetric positive definite within the tolerance  specified by TOL or 0 if X is symmetric positive semidefinite.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
ishermitian


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 340
 -- Function File: ishermitian (X)
 -- Function File: ishermitian (X, TOL)
     Return true if X is Hermitian within the tolerance specified by
     TOL.  The default tolerance is zero (uses faster code).  Matrix X
     is considered symmetric if 'norm (X - X', Inf) / norm (X, Inf) <
     TOL'.

     See also: issymmetric, isdefinite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Return true if X is Hermitian within the tolerance specified by  TOL.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
issymmetric


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 350
 -- Function File: issymmetric (X)
 -- Function File: issymmetric (X, TOL)
     Return true if X is a symmetric matrix within the tolerance
     specified by TOL.  The default tolerance is zero (uses faster
     code).  Matrix X is considered symmetric if 'norm (X - X.', Inf) /
     norm (X, Inf) < TOL'.

     See also: ishermitian, isdefinite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Return true if X is a symmetric matrix within the tolerance  specified by TOL.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
krylov


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1239
 -- Function File: [U, H, NU] = krylov (A, V, K, EPS1, PFLG)
     Construct an orthogonal basis U of block Krylov subspace

          [v a*v a^2*v ... a^(k+1)*v]

     Using Householder reflections to guard against loss of
     orthogonality.

     If V is a vector, then H contains the Hessenberg matrix such that
     a*u == u*h+rk*ek', in which 'rk = a*u(:,k)-u*h(:,k)', and ek' is
     the vector '[0, 0, ..., 1]' of length 'k'.  Otherwise, H is
     meaningless.

     If V is a vector and K is greater than 'length (A) - 1', then H
     contains the Hessenberg matrix such that 'a*u == u*h'.

     The value of NU is the dimension of the span of the Krylov subspace
     (based on EPS1).

     If B is a vector and K is greater than M-1, then H contains the
     Hessenberg decomposition of A.

     The optional parameter EPS1 is the threshold for zero.  The default
     value is 1e-12.

     If the optional parameter PFLG is nonzero, row pivoting is used to
     improve numerical behavior.  The default value is 0.

     Reference: A. Hodel, P. Misra, 'Partial Pivoting in the Computation
     of Krylov Subspaces of Large Sparse Systems', Proceedings of the
     42nd IEEE Conference on Decision and Control, December 2003.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Construct an orthogonal basis U of block Krylov subspace 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
linsolve


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1686
 -- Function File: X = linsolve (A, B)
 -- Function File: X = linsolve (A, B, OPTS)
 -- Function File: [X, R] = linsolve (...)
     Solve the linear system 'A*x = b'.

     With no options, this function is equivalent to the left division
     operator ('x = A \ b') or the matrix-left-divide function
     ('x = mldivide (A, b)').

     Octave ordinarily examines the properties of the matrix A and
     chooses a solver that best matches the matrix.  By passing a
     structure OPTS to 'linsolve' you can inform Octave directly about
     the matrix A.  In this case Octave will skip the matrix examination
     and proceed directly to solving the linear system.

     *Warning:* If the matrix A does not have the properties listed in
     the OPTS structure then the result will not be accurate AND no
     warning will be given.  When in doubt, let Octave examine the
     matrix and choose the appropriate solver as this step takes little
     time and the result is cached so that it is only done once per
     linear system.

     Possible OPTS fields (set value to true/false):

     LT
          A is lower triangular

     UT
          A is upper triangular

     UHESS
          A is upper Hessenberg (currently makes no difference)

     SYM
          A is symmetric or complex Hermitian (currently makes no
          difference)

     POSDEF
          A is positive definite

     RECT
          A is general rectangular (currently makes no difference)

     TRANSA
          Solve 'A'*x = b' by 'transpose (A) \ b'

     The optional second output R is the inverse condition number of A
     (zero if matrix is singular).

     See also: mldivide, matrix_type, rcond.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Solve the linear system 'A*x = b'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
logm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 520
 -- Function File: S = logm (A)
 -- Function File: S = logm (A, OPT_ITERS)
 -- Function File: [S, ITERS] = logm (...)
     Compute the matrix logarithm of the square matrix A.  The
     implementation utilizes a Pade' approximant and the identity

          logm (A) = 2^k * logm (A^(1 / 2^k))

     The optional argument OPT_ITERS is the maximum number of square
     roots to compute and defaults to 100.  The optional output ITERS is
     the number of square roots actually computed.

     See also: expm, sqrtm.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute the matrix logarithm of the square matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
normest


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 523
 -- Function File: N = normest (A)
 -- Function File: N = normest (A, TOL)
 -- Function File: [N, C] = normest (...)
     Estimate the 2-norm of the matrix A using a power series analysis.
     This is typically used for large matrices, where the cost of
     calculating 'norm (A)' is prohibitive and an approximation to the
     2-norm is acceptable.

     TOL is the tolerance to which the 2-norm is calculated.  By default
     TOL is 1e-6.  C returns the number of iterations needed for
     'normest' to converge.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Estimate the 2-norm of the matrix A using a power series analysis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
null


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 359
 -- Function File: null (A)
 -- Function File: null (A, TOL)
     Return an orthonormal basis of the null space of A.

     The dimension of the null space is taken as the number of singular
     values of A not greater than TOL.  If the argument TOL is missing,
     it is computed as

          max (size (A)) * max (svd (A)) * eps

     See also: orth.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return an orthonormal basis of the null space of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
onenormest


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1332
 -- Function File: [EST, V, W, ITER] = onenormest (A, T)
 -- Function File: [EST, V, W, ITER] = onenormest (APPLY, APPLY_T, N, T)

     Apply Higham and Tisseur's randomized block 1-norm estimator to
     matrix A using T test vectors.  If T exceeds 5, then only 5 test
     vectors are used.

     If the matrix is not explicit, e.g., when estimating the norm of
     'inv (A)' given an LU factorization, 'onenormest' applies A and its
     conjugate transpose through a pair of functions APPLY and APPLY_T,
     respectively, to a dense matrix of size N by T.  The implicit
     version requires an explicit dimension N.

     Returns the norm estimate EST, two vectors V and W related by norm
     '(W, 1) = EST * norm (V, 1)', and the number of iterations ITER.
     The number of iterations is limited to 10 and is at least 2.

     References:

        * N.J. Higham and F. Tisseur, 'A Block Algorithm for Matrix
          1-Norm Estimation, with an Application to 1-Norm
          Pseudospectra'.  SIMAX vol 21, no 4, pp 1185-1201.
          <http://dx.doi.org/10.1137/S0895479899356080>

        * N.J. Higham and F. Tisseur, 'A Block Algorithm for Matrix
          1-Norm Estimation, with an Application to 1-Norm
          Pseudospectra'.  <http://citeseer.ist.psu.edu/223007.html>

     See also: condest, norm, cond.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Apply Higham and Tisseur's randomized block 1-norm estimator to  matrix A using T test vectors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
orth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 357
 -- Function File: orth (A)
 -- Function File: orth (A, TOL)
     Return an orthonormal basis of the range space of A.

     The dimension of the range space is taken as the number of singular
     values of A greater than TOL.  If the argument TOL is missing, it
     is computed as

          max (size (A)) * max (svd (A)) * eps

     See also: null.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return an orthonormal basis of the range space of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
planerot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 190
 -- Function File: [G, Y] = planerot (X)
     Given a two-element column vector, returns the 2 by 2 orthogonal
     matrix G such that 'Y = G * X' and 'Y(2) = 0'.

     See also: givens.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Given a two-element column vector, returns the 2 by 2 orthogonal  matrix G such that 'Y = G * X' and 'Y(2) = 0'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
qzhess


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 792
 -- Function File: [AA, BB, Q, Z] = qzhess (A, B)
     Compute the Hessenberg-triangular decomposition of the matrix
     pencil '(A, B)', returning 'AA = Q * A * Z', 'BB = Q * B * Z', with
     Q and Z orthogonal.  For example:

          [aa, bb, q, z] = qzhess ([1, 2; 3, 4], [5, 6; 7, 8])
               => aa = [ -3.02244, -4.41741;  0.92998,  0.69749 ]
               => bb = [ -8.60233, -9.99730;  0.00000, -0.23250 ]
               =>  q = [ -0.58124, -0.81373; -0.81373,  0.58124 ]
               =>  z = [ 1, 0; 0, 1 ]

     The Hessenberg-triangular decomposition is the first step in Moler
     and Stewart's QZ decomposition algorithm.

     Algorithm taken from Golub and Van Loan, 'Matrix Computations, 2nd
     edition'.

     See also: lu, chol, hess, qr, qz, schur, svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 151
Compute the Hessenberg-triangular decomposition of the matrix  pencil '(A, B)', returning 'AA = Q * A * Z', 'BB = Q * B * Z', with  Q and Z orthogonal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
rank


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 982
 -- Function File: rank (A)
 -- Function File: rank (A, TOL)
     Compute the rank of matrix A, using the singular value
     decomposition.

     The rank is taken to be the number of singular values of A that are
     greater than the specified tolerance TOL.  If the second argument
     is omitted, it is taken to be

          tol = max (size (A)) * sigma(1) * eps;

     where 'eps' is machine precision and 'sigma(1)' is the largest
     singular value of A.

     The rank of a matrix is the number of linearly independent rows or
     columns and determines how many particular solutions exist to a
     system of equations.  Use 'null' for finding the remaining
     homogenous solutions.

     Example:

          x = [1 2 3
               4 5 6
               7 8 9];
          rank (x)
            => 2

     The number of linearly independent rows is only 2 because the final
     row is a linear combination of -1*row1 + 2*row2.

     See also: null, sprank, svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Compute the rank of matrix A, using the singular value  decomposition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
rref


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 371
 -- Function File: rref (A)
 -- Function File: rref (A, TOL)
 -- Function File: [R, K] = rref (...)
     Return the reduced row echelon form of A.  TOL defaults to 'eps *
     max (size (A)) * norm (A, inf)'.

     Called with two return arguments, K returns the vector of "bound
     variables", which are those columns on which elimination has been
     performed.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Return the reduced row echelon form of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
subspace


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 160
 -- Function File: ANGLE = subspace (A, B)
     Determine the largest principal angle between two subspaces spanned
     by the columns of matrices A and B.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
Determine the largest principal angle between two subspaces spanned  by the columns of matrices A and B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
trace


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 199
 -- Function File: trace (A)
     Compute the trace of A, the sum of the elements along the main
     diagonal.

     The implementation is straightforward: 'sum (diag (A))'.

     See also: eig.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Compute the trace of A, the sum of the elements along the main  diagonal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
vech


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 362
 -- Function File: vech (X)
     Return the vector obtained by eliminating all supradiagonal
     elements of the square matrix X and stacking the result one column
     above the other.  This has uses in matrix calculus where the
     underlying matrix is symmetric and it would be pointless to keep
     values above the main diagonal.

     See also: vec.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 145
Return the vector obtained by eliminating all supradiagonal  elements of the square matrix X and stacking the result one column  above the other.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
ans


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 234
 -- Automatic Variable: ans
     The most recently computed result that was not explicitly assigned
     to a variable.  For example, after the expression

          3^2 + 4^2

     is evaluated, the value returned by 'ans' is 25.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 82
The most recently computed result that was not explicitly assigned  to a variable.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
bug_report


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
 -- Function File: bug_report ()
     Display information about how to submit bug reports for Octave.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Display information about how to submit bug reports for Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bunzip2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 261
 -- Function File: bunzip2 (BZFILE)
 -- Function File: bunzip2 (BZFILE, DIR)
     Unpack the bzip2 archive BZFILE to the directory DIR.  If DIR is
     not specified, it defaults to the current directory.

     See also: bzip2, unpack, gunzip, unzip, untar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Unpack the bzip2 archive BZFILE to the directory DIR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
bzip2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 463
 -- Function File: ENTRIES = bzip2 (FILES)
 -- Function File: ENTRIES = bzip2 (FILES, OUTDIR)
     Compress the list of files specified in FILES.  Each file is
     compressed separately and a new file with a '".bz2"' extension is
     created.  The original files are not modified.  Existing compressed
     files are silently overwritten.  If OUTDIR is defined the
     compressed files are placed in this directory.

     See also: bunzip2, gzip, zip, tar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Compress the list of files specified in FILES.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cast


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 162
 -- Function File: cast (VAL, TYPE)
     Convert VAL to data type TYPE.

     See also: int8, uint8, int16, uint16, int32, uint32, int64, uint64,
     double.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Convert VAL to data type TYPE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
colon


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 285
 -- Function File: R = colon (A, B)
 -- Function File: R = colon (A, B, C)
     Method of a class to construct a range with the ':' operator.  For
     example:

          a = myclass (...);
          b = myclass (...);
          c = a : b

     See also: class, subsref, subsasgn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Method of a class to construct a range with the ':' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
citation


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 699
 -- Command: citation
 -- Command: citation PACKAGE
     Display instructions for citing GNU Octave or its packages in
     publications.

     When called without an argument, display information on how to cite
     the core GNU Octave system.  When given a package name PACKAGE,
     display information on citing the specific named package.  Note
     that some packages may not yet have instructions on how to cite
     them.

     The GNU Octave developers and its active community of package
     authors have invested a lot of time and effort in creating GNU
     Octave as it is today.  Please give credit where credit is due and
     cite GNU Octave and its packages when you use them.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Display instructions for citing GNU Octave or its packages in  publications.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
comma


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
 -- Operator: ,
     Array index, function argument, or command separator.

     See also: semicolon.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Array index, function argument, or command separator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
compare_versions


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1193
 -- Function File: compare_versions (V1, V2, OPERATOR)
     Compare two version strings using the given OPERATOR.

     This function assumes that versions V1 and V2 are arbitrarily long
     strings made of numeric and period characters possibly followed by
     an arbitrary string (e.g., "1.2.3", "0.3", "0.1.2+", or
     "1.2.3.4-test1").

     The version is first split into numeric and character portions and
     then the parts are padded to be the same length (i.e., "1.1" would
     be padded to be "1.1.0" when being compared with "1.1.1", and
     separately, the character parts of the strings are padded with
     nulls).

     The operator can be any logical operator from the set

        * "==" equal

        * "<" less than

        * "<=" less than or equal to

        * ">" greater than

        * ">=" greater than or equal to

        * "!=" not equal

        * "~=" not equal

     Note that version "1.1-test2" will compare as greater than
     "1.1-test10".  Also, since the numeric part is compared first, "a"
     compares less than "1a" because the second string starts with a
     numeric part even though 'double ("a")' is greater than 'double
     ("1").'
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compare two version strings using the given OPERATOR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
computer


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 859
 -- Function File: [C, MAXSIZE, ENDIAN] = computer ()
 -- Function File: ARCH = computer ("arch")
     Print or return a string of the form CPU-VENDOR-OS that identifies
     the kind of computer Octave is running on.  If invoked with an
     output argument, the value is returned instead of printed.  For
     example:

          computer ()
             -| i586-pc-linux-gnu

          x = computer ()
             => x = "i586-pc-linux-gnu"

     If two output arguments are requested, also return the maximum
     number of elements for an array.

     If three output arguments are requested, also return the byte order
     of the current system as a character ("B" for big-endian or "L" for
     little-endian).

     If the argument "arch" is specified, return a string indicating the
     architecture of the computer on which Octave is running.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
Print or return a string of the form CPU-VENDOR-OS that identifies  the kind of computer Octave is running on.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
copyfile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 748
 -- Function File: [STATUS, MSG, MSGID] = copyfile (F1, F2)
 -- Function File: [STATUS, MSG, MSGID] = copyfile (F1, F2, 'f')
     Copy the file F1 to the destination F2.

     The name F1 may contain globbing patterns.  If F1 expands to
     multiple file names, F2 must be a directory.  when the force flag
     'f' is given any existing files will be overwritten without
     prompting.

     If successful, STATUS is 1, and MSG, MSGID are empty character
     strings ("").  Otherwise, STATUS is 0, MSG contains a
     system-dependent error message, and MSGID contains a unique message
     identifier.  Note that the status code is exactly opposite that of
     the 'system' command.

     See also: movefile, rename, unlink, delete, glob.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Copy the file F1 to the destination F2.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
debug


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2209
 -- Function File: debug ()
     Summary of debugging commands.  For more information on each
     command and available options use 'help CMD'.

     The debugging commands available in Octave are

     'dbstop'
          Add a breakpoint.

     'dbclear'
          Remove a breakpoint.

     'dbstatus'
          List all breakpoints.

     'dbwhere'
          Report the current file and line number where execution is
          stopped.

     'dbtype'
          Display the code of the function being debugged, enumerating
          the line numbers.

     'dblist'
          List 10 lines of code centered around the line number where
          execution is stopped.

     'dbstep'
     'dbnext'
          Execute (step) one or more lines, follow execution into (step
          into) a function call, or execute until the end of a function
          (step out), and re-enter debug mode.

     'dbcont'
          Continue normal code execution from the debug prompt.

     'dbquit'
          Quit debugging mode immediately and return to the main prompt.

     'dbstack'
          Print a backtrace of the execution stack.

     'dbup'
          Move up the execution stack.

     'dbdown'
          Move down the execution stack.

     'keyboard'
          Force entry into debug mode from an m-file.

     'debug_on_error'
          Configure whether Octave enters debug mode when it encounters
          an error.

     'debug_on_warning'
          Configure whether Octave enters debug mode when it encounters
          a warning.

     'debug_on_interrupt'
          Configure whether Octave enters debug mode when it encounters
          an interrupt.

     'isdebugmode'
          Return true if in debug mode.

     When Octave encounters a breakpoint, or other reason to enter debug
     mode, the prompt changes to "debug>".  The workspace of the
     function where the breakpoint was encountered becomes available and
     any Octave command that is valid in that workspace context may be
     executed.

     See also: dbstop, dbclear, dbstatus, dbwhere, dbtype, dbcont,
     dbquit, dbstack, dbup, dbdown, keyboard, debug_on_error,
     debug_on_warning, debug_on_interrupt, isdebugmode.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Summary of debugging commands.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
delete


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 274
 -- Function File: delete (FILE)
 -- Function File: delete (HANDLE)
     Delete the named file or graphics handle.

     Deleting graphics objects is the proper way to remove features from
     a plot without clearing the entire figure.

     See also: clf, cla, unlink.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Delete the named file or graphics handle.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
desktop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 137
 -- Function File: USED = desktop ("-inuse")
     Return true if the desktop (GUI) is currently in use.

     See also: isguirunning.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return true if the desktop (GUI) is currently in use.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
dir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1395
 -- Function File: dir
 -- Function File: dir (DIRECTORY)
 -- Function File: [LIST] = dir (DIRECTORY)
     Display file listing for directory DIRECTORY.

     If DIRECTORY is not specified then list the present working
     directory.

     If a return value is requested, return a structure array with the
     fields

     name
          File or directory name.

     date
          Timestamp of file modification (string value).

     bytes
          File size in bytes.

     isdir
          True if name is a directory.

     datenum
          Timestamp of file modification as serial date number (double).

     statinfo
          Information structure returned from 'stat'.

     If DIRECTORY is a filename, rather than a directory, then return
     information about the named file.  DIRECTORY may also be a list
     rather than a single directory or file.

     DIRECTORY is subject to shell expansion if it contains any wildcard
     characters '*', '?', '[]'.  If you want to find a literal example
     of a wildcard character you must escape it using the backslash
     operator '\'.

     Note that for symbolic links, 'dir' returns information about the
     file that the symbolic link points to rather than the link itself.
     However, if the link points to a nonexistent file, 'dir' returns
     information about the link.

     See also: ls, readdir, glob, what, stat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Display file listing for directory DIRECTORY.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
dos


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 557
 -- Function File: dos ("COMMAND")
 -- Function File: STATUS = dos ("COMMAND")
 -- Function File: [STATUS, TEXT] = dos ("COMMAND")
 -- Function File: [...] = dos ("COMMAND", "-echo")
     Execute a system command if running under a Windows-like operating
     system, otherwise do nothing.  Return the exit status of the
     program in STATUS and any output from the command in TEXT.  When
     called with no output argument, or the "-echo" argument is given,
     then TEXT is also sent to standard output.

     See also: unix, system, isunix, ispc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Execute a system command if running under a Windows-like operating  system, otherwise do nothing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
dump_prefs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 295
 -- Function File: dump_prefs ()
 -- Function File: dump_prefs (FID)
     Dump all of the current user preference variables in a format that
     can be parsed by Octave later.  FID is a file descriptor as
     returned by 'fopen'.  If FILE is omitted, the listing is printed to
     stdout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Dump all of the current user preference variables in a format that  can be parsed by Octave later.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
edit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3967
 -- Command: edit NAME
 -- Command: edit FIELD VALUE
 -- Command: VALUE = edit get FIELD
     Edit the named function, or change editor settings.

     If 'edit' is called with the name of a file or function as its
     argument it will be opened in the text editor defined by 'EDITOR'.

        * If the function NAME is available in a file on your path and
          that file is modifiable, then it will be edited in place.  If
          it is a system function, then it will first be copied to the
          directory 'HOME' (see below) and then edited.  If no file is
          found, then the m-file variant, ending with ".m", will be
          considered.  If still no file is found, then variants with a
          leading "@" and then with both a leading "@" and trailing ".m"
          will be considered.

        * If NAME is the name of a function defined in the interpreter
          but not in an m-file, then an m-file will be created in 'HOME'
          to contain that function along with its current definition.

        * If 'NAME.cc' is specified, then it will search for 'NAME.cc'
          in the path and try to modify it, otherwise it will create a
          new '.cc' file in the current directory.  If NAME happens to
          be an m-file or interpreter defined function, then the text of
          that function will be inserted into the .cc file as a comment.

        * If 'NAME.ext' is on your path then it will be edited,
          otherwise the editor will be started with 'NAME.ext' in the
          current directory as the filename.  If 'NAME.ext' is not
          modifiable, it will be copied to 'HOME' before editing.

          *Warning:* You may need to clear NAME before the new
          definition is available.  If you are editing a .cc file, you
          will need to execute 'mkoctfile NAME.cc' before the definition
          will be available.

     If 'edit' is called with FIELD and VALUE variables, the value of
     the control field FIELD will be set to VALUE.  If an output
     argument is requested and the first input argument is 'get' then
     'edit' will return the value of the control field FIELD.  If the
     control field does not exist, edit will return a structure
     containing all fields and values.  Thus, 'edit get all' returns a
     complete control structure.  The following control fields are used:

     'home'
          This is the location of user local m-files.  Be sure it is in
          your path.  The default is '~/octave'.

     'author'
          This is the name to put after the "## Author:" field of new
          functions.  By default it guesses from the 'gecos' field of
          the password database.

     'email'
          This is the e-mail address to list after the name in the
          author field.  By default it guesses '<$LOGNAME@$HOSTNAME>',
          and if '$HOSTNAME' is not defined it uses 'uname -n'.  You
          probably want to override this.  Be sure to use the format
          '<user@host>'.

     'license'

          'gpl'
               GNU General Public License (default).

          'bsd'
               BSD-style license without advertising clause.

          'pd'
               Public domain.

          '"text"'
               Your own default copyright and license.

          Unless you specify 'pd', edit will prepend the copyright
          statement with "Copyright (C) yyyy Function Author".

     'mode'
          This value determines whether the editor should be started in
          async mode (editor is started in the background and Octave
          continues) or sync mode (Octave waits until the editor exits).
          Set it to "sync" to start the editor in sync mode.  The
          default is "async" (*note system: XREFsystem.).

     'editinplace'
          Determines whether files should be edited in place, without
          regard to whether they are modifiable or not.  The default is
          'false'.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Edit the named function, or change editor settings.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
error_ids


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 890
'Octave:invalid-context'
     Indicates the error was generated by an operation that cannot be
     executed in the scope from which it was called.  For example, the
     function 'print_usage ()' when called from the Octave prompt raises
     this error.

'Octave:invalid-input-arg'
     Indicates that a function was called with invalid input arguments.

'Octave:invalid-fun-call'
     Indicates that a function was called in an incorrect way, e.g.,
     wrong number of input arguments.

'Octave:invalid-indexing'
     Indicates that a data-type was indexed incorrectly, e.g.,
     real-value index for arrays, non-existent field of a structure.

'Octave:bad-alloc'
     Indicates that memory couldn't be allocated.

'Octave:undefined-function'
     Indicates a call to a function that is not defined.  The function
     may exist but Octave is unable to find it in the search path.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 139
'Octave:invalid-context'  Indicates the error was generated by an operation that cannot be  executed in the scope from which it was called.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fact


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 131
 -- Command: fact
 -- Function File: T = fact()
     Display an amazing and random fact about the world's greatest
     hacker.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Display an amazing and random fact about the world's greatest  hacker.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
fileattrib


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1240
 -- Function File: [STATUS, RESULT, MSGID] = fileattrib (FILE)
     Return information about FILE.

     If successful, STATUS is 1, with RESULT containing a structure with
     the following fields:

     'Name'
          Full name of FILE.

     'archive'
          True if FILE is an archive (Windows).

     'system'
          True if FILE is a system file (Windows).

     'hidden'
          True if FILE is a hidden file (Windows).

     'directory'
          True if FILE is a directory.

     'UserRead'
     'GroupRead'
     'OtherRead'
          True if the user (group; other users) has read permission for
          FILE.

     'UserWrite'
     'GroupWrite'
     'OtherWrite'
          True if the user (group; other users) has write permission for
          FILE.

     'UserExecute'
     'GroupExecute'
     'OtherExecute'
          True if the user (group; other users) has execute permission
          for FILE.

     If an attribute does not apply (i.e., archive on a Unix system)
     then the field is set to NaN.

     With no input arguments, return information about the current
     directory.

     If FILE contains globbing characters, return information about all
     the matching files.

     See also: glob.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Return information about FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
fileparts


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 178
 -- Function File: [DIR, NAME, EXT, VER] = fileparts (FILENAME)
     Return the directory, name, extension, and version components of
     FILENAME.

     See also: fullfile.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return the directory, name, extension, and version components of  FILENAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
fullfile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
 -- Function File: FILENAME = fullfile (DIR1, DIR2, ..., FILE)
     Return a complete filename constructed from the given components.

     See also: fileparts.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return a complete filename constructed from the given components.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
genvarname


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2158
 -- Function File: VARNAME = genvarname (STR)
 -- Function File: VARNAME = genvarname (STR, EXCLUSIONS)
     Create unique variable(s) from STR.  If EXCLUSIONS is given, then
     the variable(s) will be unique to each other and to EXCLUSIONS
     (EXCLUSIONS may be either a string or a cellstr).

     If STR is a cellstr, then a unique variable is created for each
     cell in STR.

          x = 3.141;
          genvarname ("x", who ())
            => x1

     If WANTED is a cell array, genvarname will make sure the returned
     strings are distinct:

          genvarname ({"foo", "foo"})
            =>
               {
                 [1,1] = foo
                 [1,2] = foo1
               }

     Note that the result is a char array/cell array of strings, not the
     variables themselves.  To define a variable, 'eval()' can be used.
     The following trivial example sets 'x' to '42'.

          name = genvarname ("x");
          eval ([name " = 42"]);
            => x =  42

     Also, this can be useful for creating unique struct field names.

          x = struct ();
          for i = 1:3
            x.(genvarname ("a", fieldnames (x))) = i;
          endfor
            => x =
               {
                 a =  1
                 a1 =  2
                 a2 =  3
               }

     Since variable names may only contain letters, digits and
     underscores, genvarname replaces any sequence of disallowed
     characters with an underscore.  Also, variables may not begin with
     a digit; in this case an underscore is added before the variable
     name.

     Variable names beginning and ending with two underscores "__" are
     valid but they are used internally by octave and should generally
     be avoided, therefore genvarname will not generate such names.

     genvarname will also make sure that returned names do not clash
     with keywords such as "for" and "if".  A number will be appended if
     necessary.  Note, however, that this does *not* include function
     names, such as "sin".  Such names should be included in AVOID if
     necessary.

     See also: isvarname, exist, tmpnam, eval.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Create unique variable(s) from STR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
getappdata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 359
 -- Function File: VALUE = getappdata (H, NAME)
 -- Function File: APPDATA = getappdata (H)

     Return the VALUE for named application data for the object(s) with
     handle(s) H.

     'getappdata(H)' returns a structure, APPDATA, whose fields
     correspond to the appdata properties.

     See also: setappdata, guidata, get, set, getpref, setpref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the VALUE for named application data for the object(s) with  handle(s) H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getfield


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 393
 -- Function File: [VAL] = getfield (S, FIELD)
 -- Function File: [VAL] = getfield (S, IDX1, FIELD1, IDX2, FIELD2, ...)
     Extract a field from a structure (or a nested structure).  The
     syntax is the same as 'setfield', except it omits the final VAL
     argument, returning this value instead of setting it.

     See also: setfield, rmfield, isfield, fieldnames, isstruct, struct.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Extract a field from a structure (or a nested structure).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gunzip


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 320
 -- Function File: gunzip (GZFILE, DIR)
     Unpack the gzip archive GZFILE to the directory DIR.  If DIR is not
     specified, it defaults to the current directory.  If GZFILE is a
     directory, all gzfiles in the directory will be recursively
     gunzipped.

     See also: gzip, unpack, bunzip2, unzip, untar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Unpack the gzip archive GZFILE to the directory DIR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
gzip


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 477
 -- Function File: ENTRIES = gzip (FILES)
 -- Function File: ENTRIES = gzip (FILES, OUTDIR)
     Compress the list of files and/or directories specified in FILES.
     Each file is compressed separately and a new file with a '".gz"'
     extension is created.  The original files are not modified.
     Existing compressed files are silently overwritten.  If OUTDIR is
     defined the compressed files are placed in this directory.

     See also: gunzip, bzip2, zip, tar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Compress the list of files and/or directories specified in FILES.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
info


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
 -- Function File: info ()
     Display contact information for the GNU Octave community.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Display contact information for the GNU Octave community.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
inputname


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 180
 -- Function File: inputname (N)
     Return the name of the N-th argument to the calling function.  If
     the argument is not a simple variable name, return an empty string.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Return the name of the N-th argument to the calling function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
isappdata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 193
 -- Function File: V = isappdata (H, NAME)
     Return true if the named application data, NAME, exists for the
     object with handle H.

     See also: getappdata, setappdata, rmappdata.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Return true if the named application data, NAME, exists for the  object with handle H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
isdeployed


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 275
 -- Function File: isdeployed ()
     Return true if the current program has been compiled and is running
     separately from the Octave interpreter and false if it is running
     in the Octave interpreter.  Currently, this function always returns
     false in Octave.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 162
Return true if the current program has been compiled and is running  separately from the Octave interpreter and false if it is running  in the Octave interpreter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ismac


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 146
 -- Function File: ismac ()
     Return true if Octave is running on a Mac OS X system and false
     otherwise.

     See also: isunix, ispc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return true if Octave is running on a Mac OS X system and false  otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
ispc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 145
 -- Function File: ispc ()
     Return true if Octave is running on a Windows system and false
     otherwise.

     See also: isunix, ismac.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Return true if Octave is running on a Windows system and false  otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isunix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 147
 -- Function File: isunix ()
     Return true if Octave is running on a Unix-like system and false
     otherwise.

     See also: ismac, ispc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Return true if Octave is running on a Unix-like system and false  otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
license


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1298
 -- Command: license
 -- Function File: license ("inuse")
 -- Function File: RETVAL = license ("inuse")
 -- Function File: RETVAL = license ("test", FEATURE)
 -- Function File: license ("test", FEATURE, TOGGLE)
 -- Function File: RETVAL = license ("checkout", FEATURE)

     Display the license of Octave.

     'license ("inuse")'

     Display a list of packages currently being used.

     'RETVAL = license ("inuse")'

     Return a structure containing the fields 'feature' and 'user'.

     'RETVAL = license ("test", FEATURE)'

     Return 1 if a license exists for the product identified by the
     string FEATURE and 0 otherwise.  The argument FEATURE is case
     insensitive and only the first 27 characters are checked.

     'license ("test", FEATURE, TOGGLE)'

     Enable or disable license testing for FEATURE, depending on TOGGLE,
     which may be one of:

     "enable"
          Future tests for the specified license of FEATURE are
          conducted as usual.

     "disable"
          Future tests for the specified license of FEATURE return 0.

     'RETVAL = license ("checkout", FEATURE)'

     Check out a license for FEATURE, returning 1 on success and 0 on
     failure.

     This function is provided for compatibility with MATLAB.

     See also: ver, version.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Display the license of Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
list_primes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 252
 -- Function File: list_primes ()
 -- Function File: list_primes (N)
     List the first N primes.  If N is unspecified, the first 25 primes
     are listed.

     The algorithm used is from page 218 of the TeXbook.

     See also: primes, isprime.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
List the first N primes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
ls


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 802
 -- Command: ls
 -- Command: ls filenames
 -- Command: ls options
 -- Command: ls options filenames
     List directory contents.  For example:

          ls -l
               -| total 12
               -| -rw-r--r--   1 jwe  users  4488 Aug 19 04:02 foo.m
               -| -rw-r--r--   1 jwe  users  1315 Aug 17 23:14 bar.m

     The 'dir' and 'ls' commands are implemented by calling your
     system's directory listing command, so the available options will
     vary from system to system.

     Filenames are subject to shell expansion if they contain any
     wildcard characters '*', '?', '[]'.  If you want to find a literal
     example of a wildcard character you must escape it using the
     backslash operator '\'.

     See also: dir, readdir, glob, what, stat, filesep, ls_command.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
List directory contents.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
ls_command


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 179
 -- Function File: VAL = ls_command ()
 -- Function File: OLD_VAL = ls_command (NEW_VAL)
     Query or set the shell command used by Octave's 'ls' command.

     See also: ls.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Query or set the shell command used by Octave's 'ls' command.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
menu


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 474
 -- Function File: menu (TITLE, OPT1, ...)
     Print a title string followed by a series of options.  Each option
     will be printed along with a number.  The return value is the
     number of the option selected by the user.  This function is useful
     for interactive programs.  There is no limit to the number of
     options that may be passed in, but it may be confusing to present
     more than will fit easily on one screen.

     See also: input, listdlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Print a title string followed by a series of options.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
mex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 198
 -- Command: mex [options] file ...
     Compile source code written in C, C++, or Fortran, to a MEX file.
     This is equivalent to 'mkoctfile --mex [options] file'.

     See also: mkoctfile.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Compile source code written in C, C++, or Fortran, to a MEX file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mexext


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
 -- Function File: mexext ()
     Return the filename extension used for MEX files.

     See also: mex.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Return the filename extension used for MEX files.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
mkoctfile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4216
 -- Command: mkoctfile [-options] file ...
 -- Function File: [OUTPUT, STATUS] = mkoctfile (...)

     The 'mkoctfile' function compiles source code written in C, C++, or
     Fortran.  Depending on the options used with 'mkoctfile', the
     compiled code can be called within Octave or can be used as a
     stand-alone application.

     'mkoctfile' can be called from the shell prompt or from the Octave
     prompt.  Calling it from the Octave prompt simply delegates the
     call to the shell prompt.  The output is stored in the OUTPUT
     variable and the exit status in the STATUS variable.

     'mkoctfile' accepts the following options, all of which are
     optional except for the file name of the code you wish to compile:

     '-I DIR'
          Add the include directory DIR to compile commands.

     '-D DEF'
          Add the definition DEF to the compiler call.

     '-l LIB'
          Add the library LIB to the link command.

     '-L DIR'
          Add the library directory DIR to the link command.

     '-M'
     '--depend'
          Generate dependency files (.d) for C and C++ source files.

     '-R DIR'
          Add the run-time path to the link command.

     '-Wl,...'
          Pass flags though the linker like "-Wl,-rpath=...".  The
          quotes are needed since commas are interpreted as command
          separators.

     '-W...'
          Pass flags though the compiler like "-Wa,OPTION".

     '-c'
          Compile but do not link.

     '-g'
          Enable debugging options for compilers.

     '-o FILE'
     '--output FILE'
          Output file name.  Default extension is .oct (or .mex if
          '--mex' is specified) unless linking a stand-alone executable.

     '-p VAR'
     '--print VAR'
          Print the configuration variable VAR.  Recognized variables
          are:

                  ALL_CFLAGS                  INCFLAGS
                  ALL_CXXFLAGS                INCLUDEDIR
                  ALL_FFLAGS                  LAPACK_LIBS
                  ALL_LDFLAGS                 LD_CXX
                  AR                          LDFLAGS
                  BLAS_LIBS                   LD_STATIC_FLAG
                  CC                          LFLAGS
                  CFLAGS                      LIBDIR
                  CPICFLAG                    LIBOCTAVE
                  CPPFLAGS                    LIBOCTINTERP
                  CXX                         LIBS
                  CXXFLAGS                    OCTAVE_HOME
                  CXXPICFLAG                  OCTAVE_LIBS
                  DEPEND_EXTRA_SED_PATTERN    OCTAVE_LINK_DEPS
                  DEPEND_FLAGS                OCTAVE_LINK_OPTS
                  DL_LD                       OCTAVE_PREFIX
                  DL_LDFLAGS                  OCTINCLUDEDIR
                  F77                         OCTLIBDIR
                  F77_INTEGER8_FLAG           OCT_LINK_DEPS
                  FFLAGS                      OCT_LINK_OPTS
                  FFTW3F_LDFLAGS              RANLIB
                  FFTW3F_LIBS                 RDYNAMIC_FLAG
                  FFTW3_LDFLAGS               READLINE_LIBS
                  FFTW3_LIBS                  SED
                  FFTW_LIBS                   SPECIAL_MATH_LIB
                  FLIBS                       XTRA_CFLAGS
                  FPICFLAG                    XTRA_CXXFLAGS

     '--link-stand-alone'
          Link a stand-alone executable file.

     '--mex'
          Assume we are creating a MEX file.  Set the default output
          extension to ".mex".

     '-s'
     '--strip'
          Strip the output file.

     '-v'
     '--verbose'
          Echo commands as they are executed.

     'file'
          The file to compile or link.  Recognized file types are

                  .c    C source
                  .cc   C++ source
                  .C    C++ source
                  .cpp  C++ source
                  .f    Fortran source (fixed form)
                  .F    Fortran source (fixed form)
                  .f90  Fortran source (free form)
                  .F90  Fortran source (free form)
                  .o    object file
                  .a    library file

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
The 'mkoctfile' function compiles source code written in C, C++, or  Fortran.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
movefile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 939
 -- Function File: movefile (F1)
 -- Function File: movefile (F1, F2)
 -- Function File: movefile (F1, F2, 'f')
 -- Function File: [STATUS, MSG, MSGID] = movefile (...)
     Move the file F1 to the destination F2.

     The name F1 may contain globbing patterns.  If F1 expands to
     multiple file names, F2 must be a directory.  If no destination F2
     is specified then the destination is the present working directory.
     If F2 is a file name then F1 is renamed to F2.  When the force flag
     'f' is given any existing files will be overwritten without
     prompting.

     If successful, STATUS is 1, and MSG, MSGID are empty character
     strings ("").  Otherwise, STATUS is 0, MSG contains a
     system-dependent error message, and MSGID contains a unique message
     identifier.  Note that the status code is exactly opposite that of
     the 'system' command.

     See also: rename, copyfile, unlink, delete, glob.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Move the file F1 to the destination F2.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
namelengthmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 445
 -- Function File: namelengthmax ()
     Return the MATLAB compatible maximum variable name length.  Octave
     is capable of storing strings up to 2^{31} - 1 in length.  However
     for MATLAB compatibility all variable, function, and structure
     field names should be shorter than the length supplied by
     'namelengthmax'.  In particular variables stored to a MATLAB file
     format will have their names truncated to this length.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Return the MATLAB compatible maximum variable name length.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
news


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 284
 -- Command: news
 -- Command: news PACKAGE
     Display the current NEWS file for Octave or an installed package.

     When called without an argument, display the NEWS file for Octave.
     When given a package name PACKAGE, display the current NEWS file
     for that package.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Display the current NEWS file for Octave or an installed package.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
orderfields


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1834
 -- Function File: [T, P] = orderfields (S1)
 -- Function File: [T, P] = orderfields (S1, S2)
     Return a copy of S1 with fields arranged alphabetically or as
     specified by S2.

     Given one struct, arrange field names in S1 alphabetically.

     If the second argument is a struct, arrange field names in S1 as
     they appear in S2.  The second argument may also specify the order
     in a permutation vector or a cell array of strings containing the
     fieldnames of S1 in the desired order.

     The optional second output argument P is assigned the permutation
     vector which converts the original name order into the new name
     order.

     Examples:

          s = struct ("d", 4, "b", 2, "a", 1, "c", 3);
          t1 = orderfields (s)
               => t1 =
                  {
                    a =  1
                    b =  2
                    c =  3
                    d =  4
                  }
          t = struct ("d", {}, "c", {}, "b", {}, "a", {});
          t2 = orderfields (s, t)
               => t2 =
                  {
                    d =  4
                    c =  3
                    b =  2
                    a =  1
                  }
          t3 = orderfields (s, [3, 2, 4, 1])
               => t3 =
                  {
                    a =  1
                    b =  2
                    c =  3
                    d =  4
                  }
          [t4, p] = orderfields (s, {"d", "c", "b", "a"})
               => t4 =
                  {
                    d =  4
                    c =  3
                    b =  2
                    a =  1
                  }
                  p =
                     1
                     4
                     2
                     3

     See also: getfield, rmfield, isfield, isstruct, fieldnames, struct.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Return a copy of S1 with fields arranged alphabetically or as  specified by S2.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
pack


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 154
 -- Function File: pack ()
     Consolidate workspace memory in MATLAB.  This function is provided
     for compatibility, but does nothing in Octave.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Consolidate workspace memory in MATLAB.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
paren


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
 -- Operator: (
 -- Operator: )
     Array index or function argument delimeter.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Array index or function argument delimeter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
parseparams


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1204
 -- Function File: [REG, PROP] = parseparams (PARAMS)
 -- Function File: [REG, VAR1, ...] = parseparams (PARAMS, NAME1,
          DEFAULT1, ...)
     Return in REG the cell elements of PARAM up to the first string
     element and in PROP all remaining elements beginning with the first
     string element.  For example:

          [reg, prop] = parseparams ({1, 2, "linewidth", 10})
          reg =
          {
            [1,1] = 1
            [1,2] = 2
          }
          prop =
          {
            [1,1] = linewidth
            [1,2] = 10
          }

     The parseparams function may be used to separate regular numeric
     arguments from additional arguments given as property/value pairs
     of the VARARGIN cell array.

     In the second form of the call, available options are specified
     directly with their default values given as name-value pairs.  If
     PARAMS do not form name-value pairs, or if an option occurs that
     does not match any of the available options, an error occurs.  When
     called from an m-file function, the error is prefixed with the name
     of the caller function.  The matching of options is
     case-insensitive.

     See also: varargin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
DEFAULT1, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
perl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 481
 -- Function File: OUTPUT = perl (SCRIPTFILE)
 -- Function File: OUTPUT = perl (SCRIPTFILE, ARGUMENT1, ARGUMENT2, ...)
 -- Function File: [OUTPUT, STATUS] = perl (...)
     Invoke Perl script SCRIPTFILE, possibly with a list of command line
     arguments.  Return output in OUTPUT and optional status in STATUS.
     If SCRIPTFILE is not an absolute file name it is is searched for in
     the current directory and then in the Octave loadpath.

     See also: system, python.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Invoke Perl script SCRIPTFILE, possibly with a list of command line  arguments.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
python


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 503
 -- Function File: OUTPUT = python (SCRIPTFILE)
 -- Function File: OUTPUT = python (SCRIPTFILE, ARGUMENT1, ARGUMENT2,
          ...)
 -- Function File: [OUTPUT, STATUS] = python (...)
     Invoke Python script SCRIPTFILE, possibly with a list of command
     line arguments.  Return output in OUTPUT and optional status in
     STATUS.  If SCRIPTFILE is not an absolute file name it is is
     searched for in the current directory and then in the Octave
     loadpath.

     See also: system, perl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
recycle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 410
 -- Function File: CURRENT_STATE = recycle ()
 -- Function File: OLD_STATE = recycle (NEW_STATE)
     Query or set the preference for recycling deleted files.

     Recycling files, instead of permanently deleting them, is not
     currently implemented in Octave.  To help avoid accidental data
     loss an error will be raised if an attempt is made to enable file
     recycling.

     See also: delete.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Query or set the preference for recycling deleted files.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
rmappdata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 122
 -- Function File: rmappdata (H, NAME)
     Delete the named application data for the object(s) with handle(s)
     H.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Delete the named application data for the object(s) with handle(s)  H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
run


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 891
 -- Command: run SCRIPT
 -- Function File: run ("SCRIPT")
     Run SCRIPT in the current workspace.

     Scripts which reside in directories specified in Octave's load
     path, and which end with the extension '".m"', can be run simply by
     typing their name.  For scripts not located on the load path, use
     'run'.

     The file name SCRIPT can be a bare, fully qualified, or relative
     filename and with or without a file extension.  If no extension is
     specified, Octave will first search for a script with the '".m"'
     extension before falling back to the script name without an
     extension.

     Implementation Note: If SCRIPT includes a path component, then
     'run' first changes the directory to the directory where SCRIPT is
     found.  'run' then executes the script, and returns to the original
     directory.

     See also: path, addpath, source.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Run SCRIPT in the current workspace.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
semicolon


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
 -- Operator: ;
     Array row or command separator.

     See also: comma.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Array row or command separator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
setappdata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 286
 -- Function File: setappdata (H, NAME, VALUE)
     Set the named application data to VALUE for the object(s) with
     handle(s) H.  If the application data with the specified name does
     not exist, it is created.

     See also: getappdata, guidata, get, set, getpref, setpref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Set the named application data to VALUE for the object(s) with  handle(s) H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
setfield


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2110
 -- Function File: S = setfield (S, FIELD, VAL)
 -- Function File: S = setfield (S, IDX1, FIELD1, IDX2, FIELD2, ...,
          VAL)

     Set a field member FIELD in a structure S equal to VAL.  For
     example:

          S = struct ();
          S = setfield (S, "foo bar", 42);

     This is equivalent to

          S.("foo bar") = 42;

     Note that ordinary structure syntax 'S.foo bar = 42' cannot be used
     here, as the field name is not a valid Octave identifier.  Using
     arbitrary strings for field name is incompatible with MATLAB, so
     this usage will warn if the 'Octave:matlab-incompatible' warning is
     set.  *Note XREFwarning_ids::.

     With the second calling form, set a field on a structure array,
     possibly nested, with successive nested indices IDX1, IDX2, ... and
     fields FIELD1, FIELD2, ... The indices must be cells containing the
     desired index at this nesting depth.

     Thus consider instead,

          S = struct ("baz", 42);
          setfield (S, {1}, "foo", {1}, "bar", 5)
              => ans =
              scalar structure containing the fields:
                baz =  42
                foo =
                  scalar structure containing the fields:
                    bar =  54

     Here we first have an ordinary structure array with one field 'baz'
     set to 42.  Then we set another field in a nested scalar structure
     indexing with two single cells containing the unique desired
     indices.

     Finally an example with nested structure arrays,

          SA.foo = 1;
          SA = setfield (SA, {2}, "bar", {3}, "baz", 6);
          SA(2).bar(3)
               => ans =
               scalar structure containing the fields:
                 baz =  6

     Here SA is a structure array whose field 'fd' at elements 1 and 2
     field is in turn another structure array whose third element is a
     structure

     Note that the same result as in the above example could be achieved
     by:

          SA.foo = 1;
          SA(2).bar(3).baz = 6

     See also: getfield, rmfield, isfield, fieldnames, isstruct, struct.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
VAL) 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
substruct


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 552
 -- Function File: substruct (TYPE, SUBS, ...)
     Create a subscript structure for use with 'subsref' or 'subsasgn'.
     For example:

          idx = substruct ("()", {3, ":"})
               =>
                 idx =
                 {
                   type = ()
                   subs =
                   {
                     [1,1] =  3
                     [1,2] = :
                   }
                 }
          x = [1, 2, 3; 4, 5, 6; 7, 8, 9];
          subsref (x, idx)
             => 7  8  9

     See also: subsref, subsasgn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Create a subscript structure for use with 'subsref' or 'subsasgn'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
swapbytes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 259
 -- Function File: swapbytes (X)
     Swap the byte order on values, converting from little endian to big
     endian and vice versa.  For example:

          swapbytes (uint16 (1:4))
          => [   256   512   768  1024]

     See also: typecast, cast.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
Swap the byte order on values, converting from little endian to big  endian and vice versa.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
symvar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 341
 -- Function File: symvar (S)
     Identify the argument names in the function defined by a string.
     Common constant names such as 'pi', 'NaN', 'Inf', 'eps', 'i' or 'j'
     are ignored.  The arguments that are found are returned in a cell
     array of strings.  If no variables are found then the returned cell
     array is empty.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Identify the argument names in the function defined by a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
tar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 475
 -- Function File: ENTRIES = tar (TARFILE, FILES)
 -- Function File: ENTRIES = tar (TARFILE, FILES, ROOT)
     Pack FILES FILES into the TAR archive TARFILE.  The list of files
     must be a string or a cell array of strings.

     The optional argument ROOT changes the relative path of FILES from
     the current directory.

     If an output argument is requested the entries in the archive are
     returned in a cell array.

     See also: untar, bzip2, gzip, zip.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Pack FILES FILES into the TAR archive TARFILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
tempdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 107
 -- Function File: DIR = tempdir ()
     Return the name of the system's directory for temporary files.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return the name of the system's directory for temporary files.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
tempname


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 179
 -- Function File: tempname ()
 -- Function File: tempname (DIR)
 -- Function File: tempname (DIR, PREFIX)
     This function is an alias for 'tmpnam'.

     See also: tmpnam.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
This function is an alias for 'tmpnam'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
unix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 557
 -- Function File: unix ("COMMAND")
 -- Function File: STATUS = unix ("COMMAND")
 -- Function File: [STATUS, TEXT] = unix ("COMMAND")
 -- Function File: [...] = unix ("COMMAND", "-echo")
     Execute a system command if running under a Unix-like operating
     system, otherwise do nothing.  Return the exit status of the
     program in STATUS and any output from the command in TEXT.  When
     called with no output argument, or the "-echo" argument is given,
     then TEXT is also sent to standard output.

     See also: dos, system, isunix, ispc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 94
Execute a system command if running under a Unix-like operating  system, otherwise do nothing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
unpack


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 555
 -- Function File: FILES = unpack (FILE)
 -- Function File: FILES = unpack (FILE, DIR)
 -- Function File: FILES = unpack (FILE, DIR, FILETYPE)
     Unpack the archive FILE based on its extension to the directory
     DIR.  If FILE is a list of strings, then each file is unpacked
     individually.  If DIR is not specified, it defaults to the current
     directory.  If a directory is in the file list, then the FILETYPE
     must also be specified.

     The optional return value is a list of FILES unpacked.

     See also: bzip2, gzip, zip, tar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Unpack the archive FILE based on its extension to the directory  DIR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
untar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 258
 -- Function File: untar (TARFILE)
 -- Function File: untar (TARFILE, DIR)
     Unpack the TAR archive TARFILE to the directory DIR.  If DIR is not
     specified, it defaults to the current directory.

     See also: tar, unpack, bunzip2, gunzip, unzip.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Unpack the TAR archive TARFILE to the directory DIR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
unzip


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 258
 -- Function File: unzip (ZIPFILE)
 -- Function File: unzip (ZIPFILE, DIR)
     Unpack the ZIP archive ZIPFILE to the directory DIR.  If DIR is not
     specified, it defaults to the current directory.

     See also: zip, unpack, bunzip2, gunzip, untar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Unpack the ZIP archive ZIPFILE to the directory DIR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
ver


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 870
 -- Function File: ver ()
 -- Function File: v = ver ()
 -- Function File: v = ver ("Octave")
 -- Function File: v = ver (PACKAGE)

     Display a header containing the current Octave version number,
     license string, and operating system followed by a list of
     installed packages, versions, and installation directories.

     'v = ver ()'

     Return a vector of structures describing Octave and each installed
     package.  The structure includes the following fields.

     'Name'
          Package name.

     'Version'
          Version of the package.

     'Revision'
          Revision of the package.

     'Date'
          Date of the version/revision.

     'v = ver ("Octave")'

     Return version information for Octave only.

     'v = ver (PACKAGE)'

     Return version information for PACKAGE.

     See also: version, octave_config_info.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 183
Display a header containing the current Octave version number,  license string, and operating system followed by a list of  installed packages, versions, and installation directories.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
version


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 210
 -- Function File: version ()
     Return the version number of Octave, as a string.

     This is an alias for the function 'OCTAVE_VERSION' provided for
     compatibility.

     See also: OCTAVE_VERSION.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Return the version number of Octave, as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
warning_ids


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10888
'Octave:abbreviated-property-match'
     By default, the 'Octave:abbreviated-property-match' warning is
     enabled.

'Octave:array-to-scalar'
     If the 'Octave:array-to-scalar' warning is enabled, Octave will
     warn when an implicit conversion from an array to a scalar value is
     attempted.  By default, the 'Octave:array-to-scalar' warning is
     disabled.

'Octave:array-to-vector'
     If the 'Octave:array-to-vector' warning is enabled, Octave will
     warn when an implicit conversion from an array to a vector value is
     attempted.  By default, the 'Octave:array-to-vector' warning is
     disabled.

'Octave:assign-as-truth-value'
     If the 'Octave:assign-as-truth-value' warning is enabled, a warning
     is issued for statements like

          if (s = t)
            ...

     since such statements are not common, and it is likely that the
     intent was to write

          if (s == t)
            ...

     instead.

     There are times when it is useful to write code that contains
     assignments within the condition of a 'while' or 'if' statement.
     For example, statements like

          while (c = getc ())
            ...

     are common in C programming.

     It is possible to avoid all warnings about such statements by
     disabling the 'Octave:assign-as-truth-value' warning, but that may
     also let real errors like

          if (x = 1)  # intended to test (x == 1)!
            ...

     slip by.

     In such cases, it is possible suppress errors for specific
     statements by writing them with an extra set of parentheses.  For
     example, writing the previous example as

          while ((c = getc ()))
            ...

     will prevent the warning from being printed for this statement,
     while allowing Octave to warn about other assignments used in
     conditional contexts.

     By default, the 'Octave:assign-as-truth-value' warning is enabled.

'Octave:associativity-change'
     If the 'Octave:associativity-change' warning is enabled, Octave
     will warn about possible changes in the meaning of some code due to
     changes in associativity for some operators.  Associativity changes
     have typically been made for MATLAB compatibility.  By default, the
     'Octave:associativity-change' warning is enabled.

'Octave:autoload-relative-file-name'
     If the 'Octave:autoload-relative-file-name' is enabled, Octave will
     warn when parsing autoload() function calls with relative paths to
     function files.  This usually happens when using autoload() calls
     in PKG_ADD files, when the PKG_ADD file is not in the same
     directory as the .oct file referred to by the autoload() command.
     By default, the 'Octave:autoload-relative-file-name' warning is
     enabled.

'Octave:broadcast'
     Warn when performing broadcasting operations.  By default, this is
     enabled.  See *note Broadcasting:: in the chapter Vectorization and
     Faster Code Execution of the manual.

'Octave:built-in-variable-assignment'
     By default, the 'Octave:built-in-variable-assignment' warning is
     enabled.

'Octave:deprecated-keyword'
     If the 'Octave:deprecated-keyword' warning is enabled, a warning is
     issued when Octave encounters a keyword that is obsolete and
     scheduled for removal from Octave.  By default, the
     'Octave:deprecated-keyword' warning is enabled.

'Octave:divide-by-zero'
     If the 'Octave:divide-by-zero' warning is enabled, a warning is
     issued when Octave encounters a division by zero.  By default, the
     'Octave:divide-by-zero' warning is enabled.

'Octave:fopen-file-in-path'
     By default, the 'Octave:fopen-file-in-path' warning is enabled.

'Octave:function-name-clash'
     If the 'Octave:function-name-clash' warning is enabled, a warning
     is issued when Octave finds that the name of a function defined in
     a function file differs from the name of the file.  (If the names
     disagree, the name declared inside the file is ignored.)  By
     default, the 'Octave:function-name-clash' warning is enabled.

'Octave:future-time-stamp'
     If the 'Octave:future-time-stamp' warning is enabled, Octave will
     print a warning if it finds a function file with a time stamp that
     is in the future.  By default, the 'Octave:future-time-stamp'
     warning is enabled.

'Octave:glyph-render'
     By default, the 'Octave:glyph-render' warning is enabled.

'Octave:imag-to-real'
     If the 'Octave:imag-to-real' warning is enabled, a warning is
     printed for implicit conversions of complex numbers to real
     numbers.  By default, the 'Octave:imag-to-real' warning is
     disabled.

'Octave:load-file-in-path'
     By default, the 'Octave:load-file-in-path' warning is enabled.

'Octave:logical-conversion'
     By default, the 'Octave:logical-conversion' warning is enabled.

'Octave:matlab-incompatible'
     Print warnings for Octave language features that may cause
     compatibility problems with MATLAB.  By default, the
     'Octave:matlab-incompatible' warning is disabled.  The -traditional
     or -braindead startup options for Octave may also be of use, *note
     Command Line Options::.

'Octave:md5sum-file-in-path'
     By default, the 'Octave:md5sum-file-in-path' warning is enabled.

'Octave:missing-glyph'
     By default, the 'Octave:missing-glyph' warning is enabled.

'Octave:missing-semicolon'
     If the 'Octave:missing-semicolon' warning is enabled, Octave will
     warn when statements in function definitions don't end in
     semicolons.  By default the 'Octave:missing-semicolon' warning is
     disabled.

'Octave:mixed-string-concat'
     If the 'Octave:mixed-string-concat' warning is enabled, print a
     warning when concatenating a mixture of double and single quoted
     strings.  By default, the 'Octave:mixed-string-concat' warning is
     disabled.

'Octave:neg-dim-as-zero'
     If the 'Octave:neg-dim-as-zero' warning is enabled, print a warning
     for expressions like

          eye (-1)

     By default, the 'Octave:neg-dim-as-zero' warning is disabled.

'Octave:nested-functions-coerced'
     By default, the 'Octave:nested-functions-coerced' warning is
     enabled.

'Octave:noninteger-range-as-index'
     By default, the 'Octave:noninteger-range-as-index' warning is
     enabled.

'Octave:num-to-str'
     If the 'Octave:num-to-str' warning is enable, a warning is printed
     for implicit conversions of numbers to their ASCII character
     equivalents when strings are constructed using a mixture of strings
     and numbers in matrix notation.  For example,

          [ "f", 111, 111 ]
          => "foo"

     elicits a warning if the 'Octave:num-to-str' warning is enabled.
     By default, the 'Octave:num-to-str' warning is enabled.

'Octave:possible-matlab-short-circuit-operator'
     If the 'Octave:possible-matlab-short-circuit-operator' warning is
     enabled, Octave will warn about using the not short circuiting
     operators '&' and '|' inside 'if' or 'while' conditions.  They
     normally never short circuit, but MATLAB always short circuits if
     any logical operators are used in a condition.  You can turn on the
     option

          do_braindead_shortcircuit_evaluation (1)

     if you would like to enable this short-circuit evaluation in
     Octave.  Note that the '&&' and '||' operators always short circuit
     in both Octave and MATLAB, so it's only necessary to enable
     MATLAB-style short-circuiting if it's too arduous to modify
     existing code that relies on this behavior.  By default, the
     'Octave:possible-matlab-short-circuit-operator' warning is enabled.

'Octave:precedence-change'
     If the 'Octave:precedence-change' warning is enabled, Octave will
     warn about possible changes in the meaning of some code due to
     changes in precedence for some operators.  Precedence changes have
     typically been made for MATLAB compatibility.  By default, the
     'Octave:precedence-change' warning is enabled.

'Octave:recursive-path-search'
     By default, the 'Octave:recursive-path-search' warning is enabled.

'Octave:remove-init-dir'
     The 'path' function changes the search path that Octave uses to
     find functions.  It is possible to set the path to a value which
     excludes Octave's own built-in functions.  If the
     'Octave:remove-init-dir' warning is enabled then Octave will warn
     when the 'path' function has been used in a way that may render
     Octave unworkable.  By default, the 'Octave:remove-init-dir'
     warning is enabled.

'Octave:reload-forces-clear'
     If several functions have been loaded from the same file, Octave
     must clear all the functions before any one of them can be
     reloaded.  If the 'Octave:reload-forces-clear' warning is enabled,
     Octave will warn you when this happens, and print a list of the
     additional functions that it is forced to clear.  By default, the
     'Octave:reload-forces-clear' warning is enabled.

'Octave:resize-on-range-error'
     If the 'Octave:resize-on-range-error' warning is enabled, print a
     warning when a matrix is resized by an indexed assignment with
     indices outside the current bounds.  By default, the ##
     'Octave:resize-on-range-error' warning is disabled.

'Octave:separator-insert'
     Print warning if commas or semicolons might be inserted
     automatically in literal matrices.  By default, the
     'Octave:separator-insert' warning is disabled.

'Octave:shadowed-function'
     By default, the 'Octave:shadowed-function' warning is enabled.

'Octave:single-quote-string'
     Print warning if a single quote character is used to introduce a
     string constant.  By default, the 'Octave:single-quote-string'
     warning is disabled.

'Octave:singular-matrix-div'
     By default, the 'Octave:singular-matrix-div' warning is enabled.

'Octave:sqrtm:SingularMatrix'
     By default, the 'Octave:sqrtm:SingularMatrix' warning is enabled.

'Octave:str-to-num'
     If the 'Octave:str-to-num' warning is enabled, a warning is printed
     for implicit conversions of strings to their numeric ASCII
     equivalents.  For example,

          "abc" + 0
          => 97 98 99

     elicits a warning if the 'Octave:str-to-num' warning is enabled.
     By default, the 'Octave:str-to-num' warning is disabled.

'Octave:undefined-return-values'
     If the 'Octave:undefined-return-values' warning is disabled, print
     a warning if a function does not define all the values in the
     return list which are expected.  By default, the
     'Octave:undefined-return-values' warning is enabled.

'Octave:variable-switch-label'
     If the 'Octave:variable-switch-label' warning is enabled, Octave
     will print a warning if a switch label is not a constant or
     constant expression.  By default, the
     'Octave:variable-switch-label' warning is disabled.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
'Octave:abbreviated-property-match'  By default, the 'Octave:abbreviated-property-match' warning is  enabled.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
what


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 310
 -- Command: what
 -- Command: what DIR
 -- Function File: w = what (DIR)
     List the Octave specific files in directory DIR.  If DIR is not
     specified then the current directory is used.  If a return argument
     is requested, the files found are returned in the structure W.

     See also: which.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
List the Octave specific files in directory DIR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
xor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 594
 -- Mapping Function: Z = xor (X, Y)
     Return the "exclusive or" of the entries of X and Y.  For boolean
     expressions X and Y, 'xor (X, Y)' is true if and only if one of X
     or Y is true.  Otherwise, for X and Y both true or both false,
     'xor' returns false.

     The truth table for the xor operation is

                                      X  Y    Z
                                      0  0    0
                                      1  0    1
                                      0  1    1
                                      1  1    0

     See also: and, or, not.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return the "exclusive or" of the entries of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
zip


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 386
 -- Function File: ENTRIES = zip (ZIPFILE, FILES)
 -- Function File: ENTRIES = zip (ZIPFILE, FILES, ROOTDIR)
     Compress the list of files and/or directories specified in FILES
     into the archive ZIPFILE in the same directory.  If ROOTDIR is
     defined the FILES are located relative to ROOTDIR rather than the
     current directory.

     See also: unzip, bzip2, gzip, tar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
Compress the list of files and/or directories specified in FILES  into the archive ZIPFILE in the same directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
display_info_file news() and citation() are very much alike.  They


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
both do the same thing, just for different files.  This function does
all the work.  


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
both do the same thing, just for different files.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
fminbnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1258
 -- Function File: [X, FVAL, INFO, OUTPUT] = fminbnd (FUN, A, B,
          OPTIONS)
     Find a minimum point of a univariate function.

     FUN should be a function handle or name.  A, B specify a starting
     interval.  OPTIONS is a structure specifying additional options.
     Currently, 'fminbnd' recognizes these options: "FunValCheck",
     "OutputFcn", "TolX", "MaxIter", "MaxFunEvals".  For a description
     of these options, see *note optimset: XREFoptimset.

     On exit, the function returns X, the approximate minimum point and
     FVAL, the function value thereof.  INFO is an exit flag that can
     have these values:

        * 1 The algorithm converged to a solution.

        * 0 Maximum number of iterations or function evaluations has
          been exhausted.

        * -1 The algorithm has been terminated from user output
          function.

     Notes: The search for a minimum is restricted to be in the interval
     bound by A and B.  If you only have an initial point to begin
     searching from you will need to use an unconstrained minimization
     algorithm such as 'fminunc' or 'fminsearch'.  'fminbnd' internally
     uses a Golden Section search strategy.

     See also: fzero, fminunc, fminsearch, optimset.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
OPTIONS)  Find a minimum point of a univariate function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
fminsearch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1034
 -- Function File: X = fminsearch (FUN, X0)
 -- Function File: X = fminsearch (FUN, X0, OPTIONS)
 -- Function File: [X, FVAL] = fminsearch (...)

     Find a value of X which minimizes the function FUN.  The search
     begins at the point X0 and iterates using the Nelder & Mead Simplex
     algorithm (a derivative-free method).  This algorithm is
     better-suited to functions which have discontinuities or for which
     a gradient-based search such as 'fminunc' fails.

     Options for the search are provided in the parameter OPTIONS using
     the function 'optimset'.  Currently, 'fminsearch' accepts the
     options: "TolX", "MaxFunEvals", "MaxIter", "Display".  For a
     description of these options, see 'optimset'.

     On exit, the function returns X, the minimum point, and FVAL, the
     function value thereof.

     Example usages:

          fminsearch (@(x) (x(1)-5).^2+(x(2)-8).^4, [0;0])

          fminsearch (inline ("(x(1)-5).^2+(x(2)-8).^4", "x"), [0;0])

     See also: fminbnd, fminunc, optimset.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Find a value of X which minimizes the function FUN.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
fminunc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2644
 -- Function File: fminunc (FCN, X0)
 -- Function File: fminunc (FCN, X0, OPTIONS)
 -- Function File: [X, FVAL, INFO, OUTPUT, GRAD, HESS] = fminunc (FCN,
          ...)
     Solve an unconstrained optimization problem defined by the function
     FCN.

     FCN should accept a vector (array) defining the unknown variables,
     and return the objective function value, optionally with gradient.
     'fminunc' attempts to determine a vector X such that 'FCN (X)' is a
     local minimum.  X0 determines a starting guess.  The shape of X0 is
     preserved in all calls to FCN, but otherwise is treated as a column
     vector.  OPTIONS is a structure specifying additional options.
     Currently, 'fminunc' recognizes these options: "FunValCheck",
     "OutputFcn", "TolX", "TolFun", "MaxIter", "MaxFunEvals", "GradObj",
     "FinDiffType", "TypicalX", "AutoScaling".

     If "GradObj" is "on", it specifies that FCN, when called with 2
     output arguments, also returns the Jacobian matrix of partial first
     derivatives at the requested point.  'TolX' specifies the
     termination tolerance for the unknown variables X, while 'TolFun'
     is a tolerance for the objective function value FVAL.  The default
     is '1e-7' for both options.

     For a description of the other options, see 'optimset'.

     On return, X is the location of the minimum and FVAL contains the
     value of the objective function at X.  INFO may be one of the
     following values:

     1
          Converged to a solution point.  Relative gradient error is
          less than specified by 'TolFun'.

     2
          Last relative step size was less than 'TolX'.

     3
          Last relative change in function value was less than 'TolFun'.

     0
          Iteration limit exceeded--either maximum numer of algorithm
          iterations 'MaxIter' or maximum number of function evaluations
          'MaxFunEvals'.

     -1
          Alogrithm terminated by 'OutputFcn'.

     -3
          The trust region radius became excessively small.

     Optionally, 'fminunc' can return a structure with convergence
     statistics (OUTPUT), the output gradient (GRAD) at the solution X,
     and approximate Hessian (HESS) at the solution X.

     Notes: If have only a single nonlinear equation of one variable
     then using 'fminbnd' is usually a much better idea.  The algorithm
     used is a gradient search which depends on the objective function
     being differentiable.  If the function has discontinuities it may
     be better to use a derivative-free algorithm such as 'fminsearch'.

     See also: fminbnd, fminsearch, optimset.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fsolve


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4540
 -- Function File: fsolve (FCN, X0, OPTIONS)
 -- Function File: [X, FVEC, INFO, OUTPUT, FJAC] = fsolve (FCN, ...)
     Solve a system of nonlinear equations defined by the function FCN.
     FCN should accept a vector (array) defining the unknown variables,
     and return a vector of left-hand sides of the equations.
     Right-hand sides are defined to be zeros.  In other words, this
     function attempts to determine a vector X such that 'FCN (X)' gives
     (approximately) all zeros.  X0 determines a starting guess.  The
     shape of X0 is preserved in all calls to FCN, but otherwise it is
     treated as a column vector.  OPTIONS is a structure specifying
     additional options.  Currently, 'fsolve' recognizes these options:
     "FunValCheck", "OutputFcn", "TolX", "TolFun", "MaxIter",
     "MaxFunEvals", "Jacobian", "Updating", "ComplexEqn" "TypicalX",
     "AutoScaling" and "FinDiffType".

     If "Jacobian" is "on", it specifies that FCN, called with 2 output
     arguments, also returns the Jacobian matrix of right-hand sides at
     the requested point.  "TolX" specifies the termination tolerance in
     the unknown variables, while "TolFun" is a tolerance for equations.
     Default is '1e-7' for both "TolX" and "TolFun".

     If "AutoScaling" is on, the variables will be automatically scaled
     according to the column norms of the (estimated) Jacobian.  As a
     result, TolF becomes scaling-independent.  By default, this option
     is off, because it may sometimes deliver unexpected (though
     mathematically correct) results.

     If "Updating" is "on", the function will attempt to use Broyden
     updates to update the Jacobian, in order to reduce the amount of
     Jacobian calculations.  If your user function always calculates the
     Jacobian (regardless of number of output arguments), this option
     provides no advantage and should be set to false.

     "ComplexEqn" is "on", 'fsolve' will attempt to solve complex
     equations in complex variables, assuming that the equations possess
     a complex derivative (i.e., are holomorphic).  If this is not what
     you want, should unpack the real and imaginary parts of the system
     to get a real system.

     For description of the other options, see 'optimset'.

     On return, FVAL contains the value of the function FCN evaluated at
     X, and INFO may be one of the following values:

     1
          Converged to a solution point.  Relative residual error is
          less than specified by TolFun.

     2
          Last relative step size was less that TolX.

     3
          Last relative decrease in residual was less than TolF.

     0
          Iteration limit exceeded.

     -3
          The trust region radius became excessively small.

     Note: If you only have a single nonlinear equation of one variable,
     using 'fzero' is usually a much better idea.

     Note about user-supplied Jacobians: As an inherent property of the
     algorithm, Jacobian is always requested for a solution vector whose
     residual vector is already known, and it is the last accepted
     successful step.  Often this will be one of the last two calls, but
     not always.  If the savings by reusing intermediate results from
     residual calculation in Jacobian calculation are significant, the
     best strategy is to employ OutputFcn: After a vector is evaluated
     for residuals, if OutputFcn is called with that vector, then the
     intermediate results should be saved for future Jacobian
     evaluation, and should be kept until a Jacobian evaluation is
     requested or until OutputFcn is called with a different vector, in
     which case they should be dropped in favor of this most recent
     vector.  A short example how this can be achieved follows:

          function [fvec, fjac] = user_func (x, optimvalues, state)
          persistent sav = [], sav0 = [];
          if (nargin == 1)
            ## evaluation call
            if (nargout == 1)
              sav0.x = x; # mark saved vector
              ## calculate fvec, save results to sav0.
            elseif (nargout == 2)
              ## calculate fjac using sav.
            endif
          else
            ## outputfcn call.
            if (all (x == sav0.x))
              sav = sav0;
            endif
            ## maybe output iteration status, etc.
          endif
          endfunction

          ## ...

          fsolve (@user_func, x0, optimset ("OutputFcn", @user_func, ...))

     See also: fzero, optimset.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Solve a system of nonlinear equations defined by the function FCN.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fzero


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1949
 -- Function File: fzero (FUN, X0)
 -- Function File: fzero (FUN, X0, OPTIONS)
 -- Function File: [X, FVAL, INFO, OUTPUT] = fzero (...)
     Find a zero of a univariate function.

     FUN is a function handle, inline function, or string containing the
     name of the function to evaluate.  X0 should be a two-element
     vector specifying two points which bracket a zero.  In other words,
     there must be a change in sign of the function between X0(1) and
     X0(2).  More mathematically, the following must hold

          sign (FUN(X0(1))) * sign (FUN(X0(2))) <= 0

     If X0 is a single scalar then several nearby and distant values are
     probed in an attempt to obtain a valid bracketing.  If this is not
     successful, the function fails.  OPTIONS is a structure specifying
     additional options.  Currently, 'fzero' recognizes these options:
     "FunValCheck", "OutputFcn", "TolX", "MaxIter", "MaxFunEvals".  For
     a description of these options, see *note optimset: XREFoptimset.

     On exit, the function returns X, the approximate zero point and
     FVAL, the function value thereof.  INFO is an exit flag that can
     have these values:

        * 1 The algorithm converged to a solution.

        * 0 Maximum number of iterations or function evaluations has
          been reached.

        * -1 The algorithm has been terminated from user output
          function.

        * -5 The algorithm may have converged to a singular point.

     OUTPUT is a structure containing runtime information about the
     'fzero' algorithm.  Fields in the structure are:

        * iterations Number of iterations through loop.

        * nfev Number of function evaluations.

        * bracketx A two-element vector with the final bracketing of the
          zero along the x-axis.

        * brackety A two-element vector with the final bracketing of the
          zero along the y-axis.

     See also: optimset, fsolve.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Find a zero of a univariate function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
glpk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11764
 -- Function File: [XOPT, FMIN, ERRNUM, EXTRA] = glpk (C, A, B, LB, UB,
          CTYPE, VARTYPE, SENSE, PARAM)
     Solve a linear program using the GNU GLPK library.  Given three
     arguments, 'glpk' solves the following standard LP:

          min C'*x

     subject to

          A*x  = b
            x >= 0

     but may also solve problems of the form

          [ min | max ] C'*x

     subject to

          A*x [ "=" | "<=" | ">=" ] b
            x >= LB
            x <= UB

     Input arguments:

     C
          A column array containing the objective function coefficients.

     A
          A matrix containing the constraints coefficients.

     B
          A column array containing the right-hand side value for each
          constraint in the constraint matrix.

     LB
          An array containing the lower bound on each of the variables.
          If LB is not supplied, the default lower bound for the
          variables is zero.

     UB
          An array containing the upper bound on each of the variables.
          If UB is not supplied, the default upper bound is assumed to
          be infinite.

     CTYPE
          An array of characters containing the sense of each constraint
          in the constraint matrix.  Each element of the array may be
          one of the following values

          "F"
               A free (unbounded) constraint (the constraint is
               ignored).

          "U"
               An inequality constraint with an upper bound ('A(i,:)*x
               <= b(i)').

          "S"
               An equality constraint ('A(i,:)*x = b(i)').

          "L"
               An inequality with a lower bound ('A(i,:)*x >= b(i)').

          "D"
               An inequality constraint with both upper and lower bounds
               ('A(i,:)*x >= -b(i)' _and_ ('A(i,:)*x <= b(i)').

     VARTYPE
          A column array containing the types of the variables.

          "C"
               A continuous variable.

          "I"
               An integer variable.

     SENSE
          If SENSE is 1, the problem is a minimization.  If SENSE is -1,
          the problem is a maximization.  The default value is 1.

     PARAM
          A structure containing the following parameters used to define
          the behavior of solver.  Missing elements in the structure
          take on default values, so you only need to set the elements
          that you wish to change from the default.

          Integer parameters:

          'msglev (default: 1)'
               Level of messages output by solver routines:

               0 ('GLP_MSG_OFF')
                    No output.

               1 ('GLP_MSG_ERR')
                    Error and warning messages only.

               2 ('GLP_MSG_ON')
                    Normal output.

               3 ('GLP_MSG_ALL')
                    Full output (includes informational messages).

          'scale (default: 16)'
               Scaling option.  The values can be combined with the
               bitwise OR operator and may be the following:

               1 ('GLP_SF_GM')
                    Geometric mean scaling.

               16 ('GLP_SF_EQ')
                    Equilibration scaling.

               32 ('GLP_SF_2N')
                    Round scale factors to power of two.

               64 ('GLP_SF_SKIP')
                    Skip if problem is well scaled.

               Alternatively, a value of 128 ('GLP_SF_AUTO') may be also
               specified, in which case the routine chooses the scaling
               options automatically.

          'dual (default: 1)'
               Simplex method option:

               1 ('GLP_PRIMAL')
                    Use two-phase primal simplex.

               2 ('GLP_DUALP')
                    Use two-phase dual simplex, and if it fails, switch
                    to the primal simplex.

               3 ('GLP_DUAL')
                    Use two-phase dual simplex.

          'price (default: 34)'
               Pricing option (for both primal and dual simplex):

               17 ('GLP_PT_STD')
                    Textbook pricing.

               34 ('GLP_PT_PSE')
                    Steepest edge pricing.

          'itlim (default: intmax)'
               Simplex iterations limit.  It is decreased by one each
               time when one simplex iteration has been performed, and
               reaching zero value signals the solver to stop the
               search.

          'outfrq (default: 200)'
               Output frequency, in iterations.  This parameter
               specifies how frequently the solver sends information
               about the solution to the standard output.

          'branch (default: 4)'
               Branching technique option (for MIP only):

               1 ('GLP_BR_FFV')
                    First fractional variable.

               2 ('GLP_BR_LFV')
                    Last fractional variable.

               3 ('GLP_BR_MFV')
                    Most fractional variable.

               4 ('GLP_BR_DTH')
                    Heuristic by Driebeck and Tomlin.

               5 ('GLP_BR_PCH')
                    Hybrid pseudocost heuristic.

          'btrack (default: 4)'
               Backtracking technique option (for MIP only):

               1 ('GLP_BT_DFS')
                    Depth first search.

               2 ('GLP_BT_BFS')
                    Breadth first search.

               3 ('GLP_BT_BLB')
                    Best local bound.

               4 ('GLP_BT_BPH')
                    Best projection heuristic.

          'presol (default: 1)'
               If this flag is set, the simplex solver uses the built-in
               LP presolver.  Otherwise the LP presolver is not used.

          'lpsolver (default: 1)'
               Select which solver to use.  If the problem is a MIP
               problem this flag will be ignored.

               1
                    Revised simplex method.

               2
                    Interior point method.

          'rtest (default: 34)'
               Ratio test technique:

               17 ('GLP_RT_STD')
                    Standard ("textbook").

               34 ('GLP_RT_HAR')
                    Harris' two-pass ratio test.

          'tmlim (default: intmax)'
               Searching time limit, in milliseconds.

          'outdly (default: 0)'
               Output delay, in seconds.  This parameter specifies how
               long the solver should delay sending information about
               the solution to the standard output.

          'save (default: 0)'
               If this parameter is nonzero, save a copy of the problem
               in CPLEX LP format to the file '"outpb.lp"'.  There is
               currently no way to change the name of the output file.

          Real parameters:

          'tolbnd (default: 1e-7)'
               Relative tolerance used to check if the current basic
               solution is primal feasible.  It is not recommended that
               you change this parameter unless you have a detailed
               understanding of its purpose.

          'toldj (default: 1e-7)'
               Absolute tolerance used to check if the current basic
               solution is dual feasible.  It is not recommended that
               you change this parameter unless you have a detailed
               understanding of its purpose.

          'tolpiv (default: 1e-10)'
               Relative tolerance used to choose eligible pivotal
               elements of the simplex table.  It is not recommended
               that you change this parameter unless you have a detailed
               understanding of its purpose.

          'objll (default: -DBL_MAX)'
               Lower limit of the objective function.  If the objective
               function reaches this limit and continues decreasing, the
               solver stops the search.  This parameter is used in the
               dual simplex method only.

          'objul (default: +DBL_MAX)'
               Upper limit of the objective function.  If the objective
               function reaches this limit and continues increasing, the
               solver stops the search.  This parameter is used in the
               dual simplex only.

          'tolint (default: 1e-5)'
               Relative tolerance used to check if the current basic
               solution is integer feasible.  It is not recommended that
               you change this parameter unless you have a detailed
               understanding of its purpose.

          'tolobj (default: 1e-7)'
               Relative tolerance used to check if the value of the
               objective function is not better than in the best known
               integer feasible solution.  It is not recommended that
               you change this parameter unless you have a detailed
               understanding of its purpose.

     Output values:

     XOPT
          The optimizer (the value of the decision variables at the
          optimum).

     FOPT
          The optimum value of the objective function.

     ERRNUM
          Error code.

          0
               No error.

          1 ('GLP_EBADB')
               Invalid basis.

          2 ('GLP_ESING')
               Singular matrix.

          3 ('GLP_ECOND')
               Ill-conditioned matrix.

          4 ('GLP_EBOUND')
               Invalid bounds.

          5 ('GLP_EFAIL')
               Solver failed.

          6 ('GLP_EOBJLL')
               Objective function lower limit reached.

          7 ('GLP_EOBJUL')
               Objective function upper limit reached.

          8 ('GLP_EITLIM')
               Iterations limit exhausted.

          9 ('GLP_ETMLIM')
               Time limit exhausted.

          10 ('GLP_ENOPFS')
               No primal feasible solution.

          11 ('GLP_ENODFS')
               No dual feasible solution.

          12 ('GLP_EROOT')
               Root LP optimum not provided.

          13 ('GLP_ESTOP')
               Search terminated by application.

          14 ('GLP_EMIPGAP')
               Relative MIP gap tolerance reached.

          15 ('GLP_ENOFEAS')
               No primal/dual feasible solution.

          16 ('GLP_ENOCVG')
               No convergence.

          17 ('GLP_EINSTAB')
               Numerical instability.

          18 ('GLP_EDATA')
               Invalid data.

          19 ('GLP_ERANGE')
               Result out of range.

     EXTRA
          A data structure containing the following fields:

          'lambda'
               Dual variables.

          'redcosts'
               Reduced Costs.

          'time'
               Time (in seconds) used for solving LP/MIP problem.

          'status'
               Status of the optimization.

               1 ('GLP_UNDEF')
                    Solution status is undefined.

               2 ('GLP_FEAS')
                    Solution is feasible.

               3 ('GLP_INFEAS')
                    Solution is infeasible.

               4 ('GLP_NOFEAS')
                    Problem has no feasible solution.

               5 ('GLP_OPT')
                    Solution is optimal.

               6 ('GLP_UNBND')
                    Problem has no unbounded solution.

     Example:

          c = [10, 6, 4]';
          A = [ 1, 1, 1;
               10, 4, 5;
                2, 2, 6];
          b = [100, 600, 300]';
          lb = [0, 0, 0]';
          ub = [];
          ctype = "UUU";
          vartype = "CCC";
          s = -1;

          param.msglev = 1;
          param.itlim = 100;

          [xmin, fmin, status, extra] = ...
             glpk (c, A, b, lb, ub, ctype, vartype, s, param);
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 81
CTYPE, VARTYPE, SENSE, PARAM)  Solve a linear program using the GNU GLPK library.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
lsqnonneg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1478
 -- Function File: X = lsqnonneg (C, D)
 -- Function File: X = lsqnonneg (C, D, X0)
 -- Function File: X = lsqnonneg (C, D, X0, OPTIONS)
 -- Function File: [X, RESNORM] = lsqnonneg (...)
 -- Function File: [X, RESNORM, RESIDUAL] = lsqnonneg (...)
 -- Function File: [X, RESNORM, RESIDUAL, EXITFLAG] = lsqnonneg (...)
 -- Function File: [X, RESNORM, RESIDUAL, EXITFLAG, OUTPUT] = lsqnonneg
          (...)
 -- Function File: [X, RESNORM, RESIDUAL, EXITFLAG, OUTPUT, LAMBDA] =
          lsqnonneg (...)
     Minimize 'norm (C*X - d)' subject to 'X >= 0'.  C and D must be
     real.  X0 is an optional initial guess for X.  Currently,
     'lsqnonneg' recognizes these options: "MaxIter", "TolX". For a
     description of these options, see *note optimset: XREFoptimset.

     Outputs:

        * resnorm

          The squared 2-norm of the residual: norm (C*X-D)^2

        * residual

          The residual: D-C*X

        * exitflag

          An indicator of convergence.  0 indicates that the iteration
          count was exceeded, and therefore convergence was not reached;
          >0 indicates that the algorithm converged.  (The algorithm is
          stable and will converge given enough iterations.)

        * output

          A structure with two fields:

             * "algorithm": The algorithm used ("nnls")

             * "iterations": The number of iterations taken.

        * lambda

          Not implemented.

     See also: optimset, pqpnonneg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
(.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
optimget


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 300
 -- Function File: optimget (OPTIONS, PARNAME)
 -- Function File: optimget (OPTIONS, PARNAME, DEFAULT)
     Return a specific option from a structure created by 'optimset'.
     If PARNAME is not a field of the OPTIONS structure, return DEFAULT
     if supplied, otherwise return an empty matrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return a specific option from a structure created by 'optimset'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
optimset


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2614
 -- Function File: optimset ()
 -- Function File: optimset (PAR, VAL, ...)
 -- Function File: optimset (OLD, PAR, VAL, ...)
 -- Function File: optimset (OLD, NEW)
     Create options struct for optimization functions.

     Valid parameters are:

     AutoScaling

     ComplexEqn

     Display
          Request verbose display of results from optimizations.  Values
          are:

          "off" [default]
               No display.

          "iter"
               Display intermediate results for every loop iteration.

          "final"
               Display the result of the final loop iteration.

          "notify"
               Display the result of the final loop iteration if the
               function has failed to converge.

     FinDiffType

     FunValCheck
          When enabled, display an error if the objective function
          returns an invalid value (a complex number, NaN, or Inf).
          Must be set to "on" or "off" [default].  Note: the functions
          'fzero' and 'fminbnd' correctly handle Inf values and only
          complex values or NaN will cause an error in this case.

     GradObj
          When set to "on", the function to be minimized must return a
          second argument which is the gradient, or first derivative, of
          the function at the point X.  If set to "off" [default], the
          gradient is computed via finite differences.

     Jacobian
          When set to "on", the function to be minimized must return a
          second argument which is the Jacobian, or first derivative, of
          the function at the point X.  If set to "off" [default], the
          Jacobian is computed via finite differences.

     MaxFunEvals
          Maximum number of function evaluations before optimization
          stops.  Must be a positive integer.

     MaxIter
          Maximum number of algorithm iterations before optimization
          stops.  Must be a positive integer.

     OutputFcn
          A user-defined function executed once per algorithm iteration.

     TolFun
          Termination criterion for the function output.  If the
          difference in the calculated objective function between one
          algorithm iteration and the next is less than 'TolFun' the
          optimization stops.  Must be a positive scalar.

     TolX
          Termination criterion for the function input.  If the
          difference in X, the current search point, between one
          algorithm iteration and the next is less than 'TolX' the
          optimization stops.  Must be a positive scalar.

     TypicalX

     Updating
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Create options struct for optimization functions.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
pqpnonneg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1189
 -- Function File: X = pqpnonneg (C, D)
 -- Function File: X = pqpnonneg (C, D, X0)
 -- Function File: [X, MINVAL] = pqpnonneg (...)
 -- Function File: [X, MINVAL, EXITFLAG] = pqpnonneg (...)
 -- Function File: [X, MINVAL, EXITFLAG, OUTPUT] = pqpnonneg (...)
 -- Function File: [X, MINVAL, EXITFLAG, OUTPUT, LAMBDA] = pqpnonneg
          (...)
     Minimize '1/2*x'*c*x + d'*x' subject to 'X >= 0'.  C and D must be
     real, and C must be symmetric and positive definite.  X0 is an
     optional initial guess for X.

     Outputs:

        * minval

          The minimum attained model value, 1/2*xmin'*c*xmin + d'*xmin

        * exitflag

          An indicator of convergence.  0 indicates that the iteration
          count was exceeded, and therefore convergence was not reached;
          >0 indicates that the algorithm converged.  (The algorithm is
          stable and will converge given enough iterations.)

        * output

          A structure with two fields:

             * "algorithm": The algorithm used ("nnls")

             * "iterations": The number of iterations taken.

        * lambda

          Not implemented.

     See also: optimset, lsqnonneg, qp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
(.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
qp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1903
 -- Function File: [X, OBJ, INFO, LAMBDA] = qp (X0, H)
 -- Function File: [X, OBJ, INFO, LAMBDA] = qp (X0, H, Q)
 -- Function File: [X, OBJ, INFO, LAMBDA] = qp (X0, H, Q, A, B)
 -- Function File: [X, OBJ, INFO, LAMBDA] = qp (X0, H, Q, A, B, LB, UB)
 -- Function File: [X, OBJ, INFO, LAMBDA] = qp (X0, H, Q, A, B, LB, UB,
          A_LB, A_IN, A_UB)
 -- Function File: [X, OBJ, INFO, LAMBDA] = qp (..., OPTIONS)
     Solve the quadratic program

          min 0.5 x'*H*x + x'*q
           x

     subject to

          A*x = b
          lb <= x <= ub
          A_lb <= A_in*x <= A_ub

     using a null-space active-set method.

     Any bound (A, B, LB, UB, A_LB, A_UB) may be set to the empty matrix
     ('[]') if not present.  If the initial guess is feasible the
     algorithm is faster.

     OPTIONS
          An optional structure containing the following parameter(s)
          used to define the behavior of the solver.  Missing elements
          in the structure take on default values, so you only need to
          set the elements that you wish to change from the default.

          'MaxIter (default: 200)'
               Maximum number of iterations.

     INFO
          Structure containing run-time information about the algorithm.
          The following fields are defined:

          'solveiter'
               The number of iterations required to find the solution.

          'info'
               An integer indicating the status of the solution.

               0
                    The problem is feasible and convex.  Global solution
                    found.

               1
                    The problem is not convex.  Local solution found.

               2
                    The problem is not convex and unbounded.

               3
                    Maximum number of iterations reached.

               6
                    The problem is infeasible.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
A_LB, A_IN, A_UB)  Solve the quadratic program 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
sqp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4220
 -- Function File: [X, OBJ, INFO, ITER, NF, LAMBDA] = sqp (X0, PHI)
 -- Function File: [...] = sqp (X0, PHI, G)
 -- Function File: [...] = sqp (X0, PHI, G, H)
 -- Function File: [...] = sqp (X0, PHI, G, H, LB, UB)
 -- Function File: [...] = sqp (X0, PHI, G, H, LB, UB, MAXITER)
 -- Function File: [...] = sqp (X0, PHI, G, H, LB, UB, MAXITER, TOL)
     Solve the nonlinear program

          min phi (x)
           x

     subject to

          g(x)  = 0
          h(x) >= 0
          lb <= x <= ub

     using a sequential quadratic programming method.

     The first argument is the initial guess for the vector X0.

     The second argument is a function handle pointing to the objective
     function PHI.  The objective function must accept one vector
     argument and return a scalar.

     The second argument may also be a 2- or 3-element cell array of
     function handles.  The first element should point to the objective
     function, the second should point to a function that computes the
     gradient of the objective function, and the third should point to a
     function that computes the Hessian of the objective function.  If
     the gradient function is not supplied, the gradient is computed by
     finite differences.  If the Hessian function is not supplied, a
     BFGS update formula is used to approximate the Hessian.

     When supplied, the gradient function 'PHI{2}' must accept one
     vector argument and return a vector.  When supplied, the Hessian
     function 'PHI{3}' must accept one vector argument and return a
     matrix.

     The third and fourth arguments G and H are function handles
     pointing to functions that compute the equality constraints and the
     inequality constraints, respectively.  If the problem does not have
     equality (or inequality) constraints, then use an empty matrix ([])
     for G (or H).  When supplied, these equality and inequality
     constraint functions must accept one vector argument and return a
     vector.

     The third and fourth arguments may also be 2-element cell arrays of
     function handles.  The first element should point to the constraint
     function and the second should point to a function that computes
     the gradient of the constraint function:

                      [ d f(x)   d f(x)        d f(x) ]
          transpose ( [ ------   -----   ...   ------ ] )
                      [  dx_1     dx_2          dx_N  ]

     The fifth and sixth arguments, LB and UB, contain lower and upper
     bounds on X.  These must be consistent with the equality and
     inequality constraints G and H.  If the arguments are vectors then
     X(i) is bound by LB(i) and UB(i).  A bound can also be a scalar in
     which case all elements of X will share the same bound.  If only
     one bound (lb, ub) is specified then the other will default to
     (-REALMAX, +REALMAX).

     The seventh argument MAXITER specifies the maximum number of
     iterations.  The default value is 100.

     The eighth argument TOL specifies the tolerance for the stopping
     criteria.  The default value is 'sqrt (eps)'.

     The value returned in INFO may be one of the following:

     101
          The algorithm terminated normally.  Either all constraints
          meet the requested tolerance, or the stepsize, delta X, is
          less than 'TOL * norm (x)'.

     102
          The BFGS update failed.

     103
          The maximum number of iterations was reached.

     An example of calling 'sqp':

          function r = g (x)
            r = [ sumsq(x)-10;
                  x(2)*x(3)-5*x(4)*x(5);
                  x(1)^3+x(2)^3+1 ];
          endfunction

          function obj = phi (x)
            obj = exp (prod (x)) - 0.5*(x(1)^3+x(2)^3+1)^2;
          endfunction

          x0 = [-1.8; 1.7; 1.9; -0.8; -0.8];

          [x, obj, info, iter, nf, lambda] = sqp (x0, @phi, @g, [])

          x =

            -1.71714
             1.59571
             1.82725
            -0.76364
            -0.76364

          obj = 0.053950
          info = 101
          iter = 8
          nf = 10
          lambda =

            -0.0401627
             0.0379578
            -0.0052227

     See also: qp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Solve the nonlinear program 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
matlabroot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 221
 -- Function File: matlabroot ()
     Return the name of the top-level Octave installation directory.

     This is an alias for the function 'OCTAVE_HOME' provided for
     compatibility.

     See also: OCTAVE_HOME.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return the name of the top-level Octave installation directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
pathdef


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 406
 -- Function File: VAL = pathdef ()
     Return the default path for Octave.  The path information is
     extracted from one of three sources.  The possible sources, in
     order of preference, are:

       1. '~/.octaverc'

       2. '<octave-home>/.../<version>/m/startup/octaverc'

       3. Octave's path prior to changes by any octaverc.

     See also: path, addpath, rmpath, genpath, savepath.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Return the default path for Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
savepath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 395
 -- Function File: savepath ()
 -- Function File: savepath (FILE)
 -- Function File: STATUS = savepath (...)
     Save the unique portion of the current function search path that is
     not set during Octave's initialization process to FILE.  If FILE is
     omitted, '~/.octaverc' is used.  If successful, 'savepath' returns
     0.

     See also: path, addpath, rmpath, genpath, pathdef.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
Save the unique portion of the current function search path that is  not set during Octave's initialization process to FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
pkg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7348
 -- Command: pkg COMMAND PKG_NAME
 -- Command: pkg COMMAND OPTION PKG_NAME
     Manage packages (groups of add-on functions) for Octave.  Different
     actions are available depending on the value of COMMAND.

     Available commands:

     'install'
          Install named packages.  For example,

               pkg install image-1.0.0.tar.gz

          installs the package found in the file 'image-1.0.0.tar.gz'.

          The OPTION variable can contain options that affect the manner
          in which a package is installed.  These options can be one or
          more of

          '-nodeps'
               The package manager will disable dependency checking.
               With this option it is possible to install a package even
               when it depends on another package which is not installed
               on the system.  *Use this option with care.*

          '-noauto'
               The package manager will not automatically load the
               installed package when starting Octave.  This overrides
               any setting within the package.

          '-auto'
               The package manager will automatically load the installed
               package when starting Octave.  This overrides any setting
               within the package.

          '-local'
               A local installation (package available only to current
               user) is forced, even if the user has system privileges.

          '-global'
               A global installation (package available to all users) is
               forced, even if the user doesn't normally have system
               privileges.

          '-forge'
               Install a package directly from the Octave-Forge
               repository.  This requires an internet connection and the
               cURL library.

          '-verbose'
               The package manager will print the output of all commands
               as they are performed.

     'update'
          Check installed Octave-Forge packages against repository and
          update any outdated items.  This requires an internet
          connection and the cURL library.  Usage:

               pkg update

     'uninstall'
          Uninstall named packages.  For example,

               pkg uninstall image

          removes the 'image' package from the system.  If another
          installed package depends on the 'image' package an error will
          be issued.  The package can be uninstalled anyway by using the
          '-nodeps' option.

     'load'
          Add named packages to the path.  After loading a package it is
          possible to use the functions provided by the package.  For
          example,

               pkg load image

          adds the 'image' package to the path.  It is possible to load
          all installed packages at once with the keyword 'all'.  Usage:

               pkg load all

     'unload'
          Remove named packages from the path.  After unloading a
          package it is no longer possible to use the functions provided
          by the package.  It is possible to unload all installed
          packages at once with the keyword 'all'.  Usage:

               pkg unload all

     'list'
          Show the list of currently installed packages.  For example,

               installed_packages = pkg ("list")

          returns a cell array containing a structure for each installed
          package.

          If two output arguments are requested 'pkg' splits the list of
          installed packages into those which were installed by the
          current user, and those which were installed by the system
          administrator.

               [user_packages, system_packages] = pkg ("list")

          The option "-forge" lists packages available at the
          Octave-Forge repository.  This requires an internet connection
          and the cURL library.  For example:

               oct_forge_pkgs = pkg ("list", "-forge")

     'describe'
          Show a short description of the named installed packages, with
          the option "-verbose" also list functions provided by the
          package.  For example,

               pkg describe -verbose all

          will describe all installed packages and the functions they
          provide.  If one output is requested a cell of structure
          containing the description and list of functions of each
          package is returned as output rather than printed on screen:

               desc = pkg ("describe", "secs1d", "image")

          If any of the requested packages is not installed, pkg returns
          an error, unless a second output is requested:

               [desc, flag] = pkg ("describe", "secs1d", "image")

          FLAG will take one of the values "Not installed", "Loaded", or
          "Not loaded" for each of the named packages.

     'prefix'
          Set the installation prefix directory.  For example,

               pkg prefix ~/my_octave_packages

          sets the installation prefix to '~/my_octave_packages'.
          Packages will be installed in this directory.

          It is possible to get the current installation prefix by
          requesting an output argument.  For example:

               pfx = pkg ("prefix")

          The location in which to install the architecture dependent
          files can be independently specified with an addition
          argument.  For example:

               pkg prefix ~/my_octave_packages ~/my_arch_dep_pkgs

     'local_list'
          Set the file in which to look for information on locally
          installed packages.  Locally installed packages are those that
          are available only to the current user.  For example:

               pkg local_list ~/.octave_packages

          It is possible to get the current value of local_list with the
          following

               pkg local_list

     'global_list'
          Set the file in which to look for information on globally
          installed packages.  Globally installed packages are those
          that are available to all users.  For example:

               pkg global_list /usr/share/octave/octave_packages

          It is possible to get the current value of global_list with
          the following

               pkg global_list

     'build'
          Build a binary form of a package or packages.  The binary file
          produced will itself be an Octave package that can be
          installed normally with 'pkg'.  The form of the command to
          build a binary package is

               pkg build builddir image-1.0.0.tar.gz ...

          where 'builddir' is the name of a directory where the
          temporary installation will be produced and the binary
          packages will be found.  The options '-verbose' and '-nodeps'
          are respected, while all other options are ignored.

     'rebuild'
          Rebuild the package database from the installed directories.
          This can be used in cases where the package database has been
          corrupted.  It can also take the '-auto' and '-noauto' options
          to allow the autoloading state of a package to be changed.
          For example,

               pkg rebuild -noauto image

          will remove the autoloading status of the image package.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Manage packages (groups of add-on functions) for Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
build


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
 -- Function File: build (FILES, HANDLE_DEPS, AUTOLOAD, VERBOSE)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
configure_make


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
 -- Function File: configure_make (DESC, PACKDIR, VERBOSE)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
copy_files


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
 -- Function File: copy_files (DESC, PACKDIR, GLOBAL_INSTALL)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
create_pkgadddel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
 -- Function File: create_pkgadddel (DESC, PACKDIR, NM, GLOBAL_INSTALL)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
describe


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 147
 -- Function File: [PKG_DESC_LIST, FLAG] = describe (PKGNAMES, VERBOSE,
          LOCAL_LIST, GLOBAL_LIST)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
LOCAL_LIST, GLOBAL_LIST)  Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
dirempty


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
 -- Function File: EMP = dirempty (NM, IGN)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
extract_pkg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
 -- Function File: PKG = extract_pkg (NM, PAT)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
finish_installation


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
 -- Function File: finish_installation (DESC, PACKDIR, GLOBAL_INSTALL)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
fix_depends


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
 -- Function File: DEPS_CELL = fix_depends (DEPENDS)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
fix_version


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 81
 -- Function File: OUT = fix_version (V)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
generate_lookfor_cache


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
 -- Function File: generate_lookfor_cache (DESC)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
get_description


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
 -- Function File: DESC = get_description (FILENAME)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
get_forge_download


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
 -- Function File: [URL, LOCAL_FILE] = list_forge_packages ()
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
get_forge_pkg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 310
 -- Function File: [VER, URL] = get_forge_pkg (NAME)
     Try to discover the current version of an OctaveForge package from
     the web, using a working internet connection and the urlread
     function.  If two output arguments are requested, also return an
     address from which to download the file.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 139
Try to discover the current version of an OctaveForge package from  the web, using a working internet connection and the urlread  function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
getarch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
 -- Function File: ARCH = getarch ()
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
getarchdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
 -- Function File: ARCHDIR = getarchdir (DESC)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
getarchprefix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
 -- Function File: [ARCHPREFIX = getarchprefix (DESC, GLOBAL_INSTALL)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
get_unsatisfied_deps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 128
 -- Function File: BAD_DEPS = get_unsatisfied_deps (DESC,
          INSTALLED_PKGS_LST)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
INSTALLED_PKGS_LST)  Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
install


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 178
 -- Function File: install (FILES, HANDLE_DEPS, AUTOLOAD, PREFIX,
          ARCHPREFIX, VERBOSE, LOCAL_LIST, GLOBAL_LIST, GLOBAL_INSTALL)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 94
ARCHPREFIX, VERBOSE, LOCAL_LIST, GLOBAL_LIST, GLOBAL_INSTALL)  Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
installed_packages


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
 -- Function File: [OUT1, OUT2] = installed_packages (LOCAL_LIST,
          GLOBAL_LIST)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
GLOBAL_LIST)  Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
is_architecture_dependent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
 -- Function File: DEP = is_architecture_dependent (NM)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
list_forge_packages


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
 -- Function File: LIST = list_forge_packages ()
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
load_package_dirs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 138
 -- Function File: IDX = load_package_dirs (LIDX, IDX, HANDLE_DEPS,
          INSTALLED_PKGS_LST)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
INSTALLED_PKGS_LST)  Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
load_packages


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
 -- Function File: load_packages (FILES, HANDLE_DEPS, LOCAL_LIST,
          GLOBAL_LIST)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
GLOBAL_LIST)  Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
load_packages_and_dependencies


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 155
 -- Function File: load_packages_and_dependencies (IDX, HANDLE_DEPS,
          INSTALLED_PKGS_LST, GLOBAL_INSTALL)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
INSTALLED_PKGS_LST, GLOBAL_INSTALL)  Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
packinfo_copy_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 149
 -- Function File: packinfo_copy_file (FILENAME, REQUIREMENT, PACKDIR,
          PACKINFO, DESC, OCTFILEDIR)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
PACKINFO, DESC, OCTFILEDIR)  Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
parse_pkg_idx


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
 -- Function File: PKG_IDX_STRUCT = parse_pkg_idx (PACKDIR)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
prepare_installation


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
 -- Function File: prepare_installation (DESC, PACKDIR)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
print_package_description


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 158
 -- Function File: print_package_description (PKG_NAME, PKG_VER,
          PKG_IDX_STRUCT, PKG_DESC, STATUS, VERBOSE)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
PKG_IDX_STRUCT, PKG_DESC, STATUS, VERBOSE)  Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rebuild


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 141
 -- Function File: DESCRIPTIONS = rebuild (PREFIX, ARCHPREFIX, LIST,
          FILES, AUTO, VERBOSE)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
FILES, AUTO, VERBOSE)  Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
repackage


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
 -- Function File: repackage (BUILDDIR, BUILDLIST)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
save_order


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
 -- Function File: NEWDESC = save_order (DESC)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
shell Executes a shell command.  In the end it calls system() but in


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 245
case of windows will first check if sh.exe works.

   If VERBOSE is true, it will prints the output to STDOUT in real time
and the second output argument will be an empty string.  Otherwise, it
will contain the output of the execeuted command.  


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
case of windows will first check if sh.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
uninstall


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
 -- Function File: uninstall (PKGNAMES, HANDLE_DEPS, VERBOSE,
          LOCAL_LIST, GLOBAL_LIST, GLOBAL_INSTALL)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
LOCAL_LIST, GLOBAL_LIST, GLOBAL_INSTALL)  Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
unload_packages


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 131
 -- Function File: unload_packages (FILES, HANDLE_DEPS, LOCAL_LIST,
          GLOBAL_LIST)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
GLOBAL_LIST)  Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
verify_directory


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 82
 -- Function File: verify_directory (DIR)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
write_index


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
 -- Function File: write_index (DESC, DIR, INDEX_FILE, GLOBAL_INSTALL)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
axis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2774
 -- Function File: axis ()
 -- Function File: axis ([X_lo X_hi])
 -- Function File: axis ([X_lo X_hi Y_lo Y_hi])
 -- Function File: axis ([X_lo X_hi Y_lo Y_hi Z_lo Z_hi])
 -- Function File: axis (OPTION)
 -- Function File: axis (..., OPTION)
 -- Function File: axis (HAX, ...)
 -- Function File: LIMITS = axis ()
     Set axis limits and appearance.

     The argument LIMITS should be a 2-, 4-, or 6-element vector.  The
     first and second elements specify the lower and upper limits for
     the x-axis.  The third and fourth specify the limits for the
     y-axis, and the fifth and sixth specify the limits for the z-axis.

     Without any arguments, 'axis' turns autoscaling on.

     With one output argument, 'LIMITS = axis' returns the current axis
     limits.

     The vector argument specifying limits is optional, and additional
     string arguments may be used to specify various axis properties.
     For example,

          axis ([1, 2, 3, 4], "square");

     forces a square aspect ratio, and

          axis ("tic", "labely");

     turns tic marks on for all axes and tic mark labels on for the
     y-axis only.

     The following options control the aspect ratio of the axes.

     "square"
          Force a square aspect ratio.

     "equal"
          Force x distance to equal y-distance.

     "normal"
          Restore default aspect ratio.

     The following options control the way axis limits are interpreted.

     "auto"
          Set the specified axes to have nice limits around the data or
          all if no axes are specified.

     "manual"
          Fix the current axes limits.

     "tight"
          Fix axes to the limits of the data.

     "image"
          Equivalent to "tight" and "equal".

     The following options affect the appearance of tic marks.

     "on"
          Turn tic marks and labels on for all axes.

     "off"
          Turn tic marks off for all axes.

     "tic[xyz]"
          Turn tic marks on for all axes, or turn them on for the
          specified axes and off for the remainder.

     "label[xyz]"
          Turn tic labels on for all axes, or turn them on for the
          specified axes and off for the remainder.

     "nolabel"
          Turn tic labels off for all axes.

     Note, if there are no tic marks for an axis, there can be no
     labels.

     The following options affect the direction of increasing values on
     the axes.

     "ij"
          Reverse y-axis, so lower values are nearer the top.

     "xy"
          Restore y-axis, so higher values are nearer the top.

     If the first argument HAX is an axes handle, then operate on this
     axes rather than the current axes returned by 'gca'.

     See also: xlim, ylim, zlim, daspect, pbaspect, box, grid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Set axis limits and appearance.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
box


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 400
 -- Command: box on
 -- Command: box off
 -- Command: box
 -- Function File: box (HAX, ...)
     Control display of the axis border.

     The argument may be either "on" or "off".  If it is omitted, the
     current box state is toggled.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by 'gca'.

     See also: axis, grid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Control display of the axis border.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
caxis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1053
 -- Function File: caxis ([cmin cmax])
 -- Function File: caxis ("auto")
 -- Function File: caxis ("manual")
 -- Function File: caxis (HAX, ...)
 -- Function File: LIMITS = caxis ()
     Query or set color axis limits for plots.

     The limits argument should be a 2-element vector specifying the
     lower and upper limits to assign to the first and last value in the
     colormap.  Data values outside this range are clamped to the first
     and last colormap entries.

     If the "auto" option is given then automatic colormap limits are
     applied.  The automatic algorithm sets CMIN to the minimum data
     value and CMAX to the maximum data value.  If "manual" is specified
     then the "climmode" property is set to "manual" and the numeric
     values in the "clim" property are used for limits.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by 'gca'.

     Called without arguments the current color axis limits are
     returned.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Query or set color axis limits for plots.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
clabel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1720
 -- Function File: clabel (C, H)
 -- Function File: clabel (C, H, V)
 -- Function File: clabel (C, H, "manual")
 -- Function File: clabel (C)
 -- Function File: clabel (..., PROP, VAL, ...)
 -- Function File: H = clabel (...)
     Add labels to the contours of a contour plot.

     The contour levels are specified by the contour matrix C which is
     returned by 'contour', 'contourc', 'contourf', and 'contour3'.
     Contour labels are rotated to match the local line orientation and
     centered on the line.  The position of labels along the contour
     line is chosen randomly.

     If the argument H is a handle to a contour group object, then label
     this plot rather than the one in the current axes returned by
     'gca'.

     By default, all contours are labeled.  However, the contours to
     label can be specified by the vector V.  If the "manual" argument
     is given then the contours to label can be selected with the mouse.

     Additional property/value pairs that are valid properties of text
     objects can be given and are passed to the underlying text objects.
     Moreover, the contour group property "LabelSpacing" is available
     which determines the spacing between labels on a contour to be
     specified.  The default is 144 points, or 2 inches.

     The optional return value H is a vector of graphics handles to the
     text objects representing each label.  The "userdata" property of
     the text objects contains the numerical value of the contour label.

     An example of the use of 'clabel' is

          [c, h] = contour (peaks (), -4 : 6);
          clabel (c, h, -4:2:6, "fontsize", 12);

     See also: contour, contourf, contour3, meshc, surfc, text.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Add labels to the contours of a contour plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
daspect


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 763
 -- Function File: DATA_ASPECT_RATIO = daspect ()
 -- Function File: daspect (DATA_ASPECT_RATIO)
 -- Function File: daspect (MODE)
 -- Function File: DATA_ASPECT_RATIO_MODE = daspect ("mode")
 -- Function File: daspect (HAX, ...)
     Query or set the data aspect ratio of the current axes.

     The aspect ratio is a normalized 3-element vector representing the
     span of the x, y, and z-axis limits.

     'daspect (MODE)'

     Set the data aspect ratio mode of the current axes.  MODE is either
     "auto" or "manual".

     'daspect ("mode")'

     Return the data aspect ratio mode of the current axes.

     'daspect (HAX, ...)'

     Operate on the axes in handle HAX instead of the current axes.

     See also: axis, pbaspect, xlim, ylim, zlim.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Query or set the data aspect ratio of the current axes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
datetick


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 610
 -- Function File: datetick ()
 -- Function File: datetick (FORM)
 -- Function File: datetick (AXIS, FORM)
 -- Function File: datetick (..., "keeplimits")
 -- Function File: datetick (..., "keepticks")
 -- Function File: datetick (HAX, ...)
     Add date formatted tick labels to an axis.  The axis to apply the
     ticks to is determined by AXIS which can take the values "x", "y",
     or "z".  The default value is "x".  The formatting of the labels is
     determined by the variable FORM, which can either be a string or
     positive integer that 'datestr' accepts.

     See also: datenum, datestr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Add date formatted tick labels to an axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
diffuse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 345
 -- Function File: diffuse (SX, SY, SZ, LV)
     Calculate diffuse reflection strength of a surface defined by the
     normal vector elements SX, SY, SZ.

     The light source location vector LV can be given as 2-element
     vector [azimuth, elevation] in degrees or as 3-element vector [lx,
     ly, lz].

     See also: specular, surfl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
Calculate diffuse reflection strength of a surface defined by the  normal vector elements SX, SY, SZ.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
grid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 754
 -- Command: grid
 -- Command: grid on
 -- Command: grid off
 -- Command: grid minor
 -- Command: grid minor on
 -- Command: grid minor off
 -- Function File: grid (HAX, ...)
     Control the display of plot grid lines.

     The function state input may be either "on" or "off".  If it is
     omitted, the current grid state is toggled.

     When the first argument is "minor" all subsequent commands modify
     the minor grid rather than the major grid.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by 'gca'.

     To control the grid lines for an individual axis use the 'set'
     function.  For example:

          set (gca, "ygrid", "on");

     See also: axis, box.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Control the display of plot grid lines.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
gtext


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 756
 -- Function File: gtext (S)
 -- Function File: gtext ({S1, S2, ...})
 -- Function File: gtext ({S1; S2; ...})
 -- Function File: gtext (..., PROP, VAL, ...)
 -- Function File: H = gtext (...)
     Place text on the current figure using the mouse.

     The text is defined by the string S.  If S is a cell string
     organized as a row vector then each string of the cell array is
     written to a separate line.  If S is organized as a column vector
     then one string element of the cell array is placed for every mouse
     click.

     Optional property/value pairs are passed directly to the underlying
     text objects.

     The optional return value H is a graphics handle to the created
     text object(s).

     See also: ginput, text.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Place text on the current figure using the mouse.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
hidden


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 821
 -- Command: hidden
 -- Command: hidden "on"
 -- Command: hidden "off"
 -- Function File: MODE = hidden (...)
     Control mesh hidden line removal.

     When called with no argument the hidden line removal state is
     toggled.  When called with one of the modes "on" or "off" the state
     is set accordingly.

     The optional output argument MODE is the current state.

     Hidden Line Removal determines what graphic objects behind a mesh
     plot are visible.  The default is for the mesh to be opaque and
     lines behind the mesh are not visible.  If hidden line removal is
     turned off then objects behind the mesh can be seen through the
     faces (openings) of the mesh, although the mesh grid lines are
     still opaque.

     See also: mesh, meshc, meshz, ezmesh, ezmeshc, trimesh, waterfall.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Control mesh hidden line removal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
legend


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3141
 -- Function File: legend (STR1, STR2, ...)
 -- Function File: legend (MATSTR)
 -- Function File: legend (CELLSTR)
 -- Function File: legend (..., "location", POS)
 -- Function File: legend (..., "orientation", ORIENT)
 -- Function File: legend (HAX, ...)
 -- Function File: legend (HOBJS, ...)
 -- Function File: legend (HAX, HOBJS, ...)
 -- Function File: legend ("OPTION")
 -- Function File: [HLEG, HLEG_OBJ, HPLOT, LABELS] = legend (...)

     Display a legend for the current axes using the specified strings
     as labels.

     Legend entries may be specified as individual character string
     arguments, a character array, or a cell array of character strings.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.  If the
     handles, HOBJS, are not specified then the legend's strings will be
     associated with the axes' descendants.  'legend' works on line
     graphs, bar graphs, etc.  A plot must exist before legend is
     called.

     The optional parameter POS specifies the location of the legend as
     follows:

          pos        location of the legend
     ---------------------------------------------------------------------------
          north      center top
          south      center bottom
          east       right center
          west       left center
          northeast  right top (default)
          northwest  left top
          southeast  right bottom
          southwest  left bottom
          outside    can be appended to any location string

     The optional parameter ORIENT determines if the key elements are
     placed vertically or horizontally.  The allowed values are
     "vertical" (default) or "horizontal".

     The following customizations are available using OPTION:

     "show"
          Show legend on the plot

     "hide"
          Hide legend on the plot

     "toggle"
          Toggles between "hide" and "show"

     "boxon"
          Show a box around legend (default)

     "boxoff"
          Hide the box around legend

     "right"
          Place label text to the right of the keys (default)

     "left"
          Place label text to the left of the keys

     "off"
          Delete the legend object

     The optional output values are

     HLEG
          The graphics handle of the legend object.

     HLEG_OBJ
          Graphics handles to the text and line objects which make up
          the legend.

     HPLOT
          Graphics handles to the plot objects which were used in making
          the legend.

     LABELS
          A cell array of strings of the labels in the legend.

     The legend label text is either provided in the call to 'legend' or
     is taken from the DisplayName property of graphics objects.  If no
     labels or DisplayNames are available, then the label text is simply
     "data1", "data2", ..., "dataN".

     Implementation Note: A legend is implemented as an additional axes
     object of the current figure with the "tag" set to "legend".
     Properties of the legend object may be manipulated directly by
     using 'set'.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Display a legend for the current axes using the specified strings  as labels.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
orient


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1054
 -- Function File: orient (ORIENTATION)
 -- Function File: orient (HFIG, ORIENTATION)
 -- Function File: ORIENTATION = orient ()
 -- Function File: ORIENTATION = orient (HFIG)
     Query or set the print orientation for figure HFIG.

     Valid values for ORIENTATION are "portrait", "landscape", and
     "tall".

     The "landscape" option changes the orientation so the plot width is
     larger than the plot height.  The "paperposition" is also modified
     so that the plot fills the page, while leaving a 0.25 inch border.

     The "tall" option sets the orientation to "portrait" and fills the
     page with the plot, while leaving a 0.25 inch border.

     The "portrait" option (default) changes the orientation so the plot
     height is larger than the plot width.  It also restores the default
     "paperposition" property.

     When called with no arguments, return the current print
     orientation.

     If the argument HFIG is omitted, then operate on the current figure
     returned by 'gcf'.

     See also: print, saveas.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Query or set the print orientation for figure HFIG.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
pbaspect


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 800
 -- Function File: PLOT_BOX_ASPECT_RATIO = pbaspect ( )
 -- Function File: pbaspect (PLOT_BOX_ASPECT_RATIO)
 -- Function File: pbaspect (MODE)
 -- Function File: PLOT_BOX_ASPECT_RATIO_MODE = pbaspect ("mode")
 -- Function File: pbaspect (HAX, ...)

     Query or set the plot box aspect ratio of the current axes.

     The aspect ratio is a normalized 3-element vector representing the
     rendered lengths of the x, y, and z axes.

     'pbaspect(MODE)'

     Set the plot box aspect ratio mode of the current axes.  MODE is
     either "auto" or "manual".

     'pbaspect ("mode")'

     Return the plot box aspect ratio mode of the current axes.

     'pbaspect (HAX, ...)'

     Operate on the axes in handle HAX instead of the current axes.

     See also: axis, daspect, xlim, ylim, zlim.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Query or set the plot box aspect ratio of the current axes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
shading


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 618
 -- Function File: shading (TYPE)
 -- Function File: shading (HAX, TYPE)
     Set the shading of patch or surface graphic objects.

     Valid arguments for TYPE are

     "flat"
          Single colored patches with invisible edges.

     "faceted"
          Single colored patches with visible edges.

     "interp"
          Color between patch vertices are interpolated and the patch
          edges are invisible.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     See also: fill, mesh, patch, pcolor, surf, surface, hidden.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Set the shading of patch or surface graphic objects.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
specular


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 612
 -- Function File: specular (SX, SY, SZ, LV, VV)
 -- Function File: specular (SX, SY, SZ, LV, VV, SE)
     Calculate specular reflection strength of a surface defined by the
     normal vector elements SX, SY, SZ using Phong's approximation.

     The light source location and viewer location vectors can be
     specified using parameter LV and VV respectively.  The location
     vectors can given as 2-element vectors [azimuth, elevation] in
     degrees or as 3-element vectors [x, y, z].

     An optional sixth argument describes the specular exponent (spread)
     SE.

     See also: diffuse, surfl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 130
Calculate specular reflection strength of a surface defined by the  normal vector elements SX, SY, SZ using Phong's approximation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
text


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 665
 -- Function File: text (X, Y, STRING)
 -- Function File: text (X, Y, Z, STRING)
 -- Function File: text (..., PROP, VAL, ...)
 -- Function File: H = text (...)
     Create a text object with text STRING at position X, Y, (Z) on the
     current axes.

     Multiple locations can be specified if X, Y, (Z) are vectors.
     Multiple strings can be specified with a character matrix or a cell
     array of strings.

     Optional property/value pairs may be used to control the appearance
     of the text.

     The optional return value H is a vector of graphics handles to the
     created text objects.

     See also: gtext, title, xlabel, ylabel, zlabel.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 81
Create a text object with text STRING at position X, Y, (Z) on the  current axes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
title


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 607
 -- Function File: title (STRING)
 -- Function File: title (STRING, PROP, VAL, ...)
 -- Function File: title (HAX, ...)
 -- Function File: H = title (...)
     Specify the string used as a title for the current axis.

     An optional list of PROPERTY/VALUE pairs can be used to change the
     appearance of the created title text object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     text object.

     See also: xlabel, ylabel, zlabel, text.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Specify the string used as a title for the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
view


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 957
 -- Function File: view (AZIMUTH, ELEVATION)
 -- Function File: view ([AZIMUTH ELEVATION])
 -- Function File: view ([X Y Z])
 -- Function File: view (2)
 -- Function File: view (3)
 -- Function File: view (HAX, ...)
 -- Function File: [AZIMUTH, ELEVATION] = view ()
     Query or set the viewpoint for the current axes.

     The parameters AZIMUTH and ELEVATION can be given as two arguments
     or as 2-element vector.  The viewpoint can also be specified with
     Cartesian coordinates X, Y, and Z.

     The call 'view (2)' sets the viewpoint to AZIMUTH = 0 and
     ELEVATION = 90, which is the default for 2-D graphs.

     The call 'view (3)' sets the viewpoint to AZIMUTH = -37.5 and
     ELEVATION = 30, which is the default for 3-D graphs.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by 'gca'.

     If no inputs are given, return the current AZIMUTH and ELEVATION.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Query or set the viewpoint for the current axes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
whitebg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 810
 -- Function File: whitebg ()
 -- Function File: whitebg (COLOR)
 -- Function File: whitebg ("none")
 -- Function File: whitebg (HFIG, ...)
     Invert the colors in the current color scheme.

     The root properties are also inverted such that all subsequent plot
     use the new color scheme.

     If the optional argument COLOR is present then the background color
     is set to COLOR rather than inverted.  COLOR may be a string
     representing one of the eight known colors or an RGB triplet.  The
     special string argument "none" restores the plot to the default
     colors.

     If the first argument HFIG is a figure handle, then operate on this
     figure rather than the current figure returned by 'gcf'.  The root
     properties will not be changed.

     See also: reset, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Invert the colors in the current color scheme.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
xlabel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 625
 -- Function File: xlabel (STRING)
 -- Function File: xlabel (STRING, PROPERTY, VAL, ...)
 -- Function File: xlabel (HAX, ...)
 -- Function File: H = xlabel (...)
     Specify the string used to label the x-axis of the current axis.

     An optional list of PROPERTY/VALUE pairs can be used to change the
     properties of the created text label.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     text object.

     See also: ylabel, zlabel, datetick, title, text.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Specify the string used to label the x-axis of the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
xlim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 910
 -- Function File: XLIMITS = xlim ()
 -- Function File: XMODE = xlim ("mode")
 -- Function File: xlim ([X_LO X_HI])
 -- Function File: xlim ("auto")
 -- Function File: xlim ("manual")
 -- Function File: xlim (HAX, ...)
     Query or set the limits of the x-axis for the current plot.

     Called without arguments 'xlim' returns the x-axis limits of the
     current plot.  With the input query "mode", return the current
     x-limit calculation mode which is either "auto" or "manual".

     If passed a 2-element vector [X_LO X_HI], the limits of the x-axis
     are set to these values and the mode is set to "manual".

     The current plotting mode can be changed by using either "auto" or
     "manual" as the argument.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by 'gca'.

     See also: ylim, zlim, axis, set, get, gca.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Query or set the limits of the x-axis for the current plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ylabel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 687
 -- Function File: ylabel (STRING)
 -- Function File: ylabel (STRING, PROPERTY, VAL, ...)
 -- Function File: ylabel (HAX, ...)
 -- Function File: H = ylabel (...)
     Specify the string used to label the y-axis of the current axis.

     If HAX is specified then label the axis defined by HAX.

     An optional list of PROPERTY/VALUE pairs can be used to change the
     properties of the created text label.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     text object.

     See also: xlabel, zlabel, datetick, title, text.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Specify the string used to label the y-axis of the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
ylim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 910
 -- Function File: YLIMITS = ylim ()
 -- Function File: XMODE = ylim ("mode")
 -- Function File: ylim ([Y_LO Y_HI])
 -- Function File: ylim ("auto")
 -- Function File: ylim ("manual")
 -- Function File: ylim (HAX, ...)
     Query or set the limits of the y-axis for the current plot.

     Called without arguments 'ylim' returns the y-axis limits of the
     current plot.  With the input query "mode", return the current
     y-limit calculation mode which is either "auto" or "manual".

     If passed a 2-element vector [Y_LO Y_HI], the limits of the y-axis
     are set to these values and the mode is set to "manual".

     The current plotting mode can be changed by using either "auto" or
     "manual" as the argument.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by 'gca'.

     See also: xlim, zlim, axis, set, get, gca.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Query or set the limits of the y-axis for the current plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
zlabel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 637
 -- Function File: zlabel (STRING)
 -- Function File: zlabel (STRING, PROPERTY, VAL, ...)
 -- Function File: zlabel (HAX, ...)
 -- Function File: H = zlabel (...)
     Specify the string used to label the z-axis of the current axis.

     An optional list of PROPERTY/VALUE pairs can be used to change the
     properties of the created text label.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     text object.

     See also: xlabel, ylabel, datetick, title, text.
   Author: jwe 


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Specify the string used to label the z-axis of the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
zlim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 910
 -- Function File: ZLIMITS = zlim ()
 -- Function File: XMODE = zlim ("mode")
 -- Function File: zlim ([Z_LO Z_HI])
 -- Function File: zlim ("auto")
 -- Function File: zlim ("manual")
 -- Function File: zlim (HAX, ...)
     Query or set the limits of the z-axis for the current plot.

     Called without arguments 'zlim' returns the z-axis limits of the
     current plot.  With the input query "mode", return the current
     z-limit calculation mode which is either "auto" or "manual".

     If passed a 2-element vector [Z_LO Z_HI], the limits of the x-axis
     are set to these values and the mode is set to "manual".

     The current plotting mode can be changed by using either "auto" or
     "manual" as the argument.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by 'gca'.

     See also: xlim, ylim, axis, set, get, gca.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Query or set the limits of the z-axis for the current plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
area


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1352
 -- Function File: area (Y)
 -- Function File: area (X, Y)
 -- Function File: area (..., LVL)
 -- Function File: area (..., PROP, VAL, ...)
 -- Function File: area (HAX, ...)
 -- Function File: H = area (...)
     Area plot of the columns of Y.

     This plot shows the contributions of each column value to the row
     sum.  It is functionally similar to 'plot (X, cumsum (Y, 2))',
     except that the area under the curve is shaded.

     If the X argument is omitted it defaults to '1:rows (Y)'.  A value
     LVL can be defined that determines where the base level of the
     shading under the curve should be defined.  The default level is 0.

     Additional property/value pairs are passed directly to the
     underlying patch object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the hggroup
     object comprising the area patch objects.  The "BaseValue" property
     of the hggroup can be used to adjust the level where shading
     begins.

     Example: Verify identity sin^2 + cos^2 = 1

          t = linspace (0, 2*pi, 100)';
          y = [sin(t).^2, cos(t).^2)];
          area (t, y);
          legend ("sin^2", "cos^2", "location", "NorthEastOutside");

     See also: plot, patch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Area plot of the columns of Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
barh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1800
 -- Function File: barh (Y)
 -- Function File: barh (X, Y)
 -- Function File: barh (..., W)
 -- Function File: barh (..., STYLE)
 -- Function File: barh (..., PROP, VAL, ...)
 -- Function File: barh (HAX, ...)
 -- Function File: H = barh (..., PROP, VAL, ...)
     Produce a horizontal bar graph from two vectors of X-Y data.

     If only one argument is given, it is taken as a vector of Y values
     and the X coordinates are the range '1:numel (Y)'.

     The optional input W controls the width of the bars.  A value of
     1.0 will cause each bar to exactly touch any adjacent bars.  The
     default width is 0.8.

     If Y is a matrix, then each column of Y is taken to be a separate
     bar graph plotted on the same graph.  By default the columns are
     plotted side-by-side.  This behavior can be changed by the STYLE
     argument which can take the following values:

     "grouped" (default)
          Side-by-side bars with a gap between bars and centered over
          the Y-coordinate.

     "stacked"
          Bars are stacked so that each Y value has a single bar
          composed of multiple segments.

     "hist"
          Side-by-side bars with no gap between bars and centered over
          the Y-coordinate.

     "histc"
          Side-by-side bars with no gap between bars and left-aligned to
          the Y-coordinate.

     Optional property/value pairs are passed directly to the underlying
     patch objects.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created bar
     series hggroup.  For a description of the use of the bar series,
     *note bar: XREFbar.

     See also: bar, hist, pie, plot, patch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Produce a horizontal bar graph from two vectors of X-Y data.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
bar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2675
 -- Function File: bar (Y)
 -- Function File: bar (X, Y)
 -- Function File: bar (..., W)
 -- Function File: bar (..., STYLE)
 -- Function File: bar (..., PROP, VAL, ...)
 -- Function File: bar (HAX, ...)
 -- Function File: H = bar (..., PROP, VAL, ...)
     Produce a bar graph from two vectors of X-Y data.

     If only one argument is given, Y, it is taken as a vector of Y
     values and the X coordinates are the range '1:numel (Y)'.

     The optional input W controls the width of the bars.  A value of
     1.0 will cause each bar to exactly touch any adjacent bars.  The
     default width is 0.8.

     If Y is a matrix, then each column of Y is taken to be a separate
     bar graph plotted on the same graph.  By default the columns are
     plotted side-by-side.  This behavior can be changed by the STYLE
     argument which can take the following values:

     "grouped" (default)
          Side-by-side bars with a gap between bars and centered over
          the X-coordinate.

     "stacked"
          Bars are stacked so that each X value has a single bar
          composed of multiple segments.

     "hist"
          Side-by-side bars with no gap between bars and centered over
          the X-coordinate.

     "histc"
          Side-by-side bars with no gap between bars and left-aligned to
          the X-coordinate.

     Optional property/value pairs are passed directly to the underlying
     patch objects.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a vector of handles to the created
     "bar series" hggroups with one handle per column of the variable Y.
     This series makes it possible to change a common element in one bar
     series object and have the change reflected in the other "bar
     series".  For example,

          h = bar (rand (5, 10));
          set (h(1), "basevalue", 0.5);

     changes the position on the base of all of the bar series.

     The following example modifies the face and edge colors using
     property/value pairs.

          bar (randn (1, 100), "facecolor", "r", "edgecolor", "b");

     The color of the bars is taken from the figure's colormap, such
     that

          bar (rand (10, 3));
          colormap (summer (64));

     will change the colors used for the bars.  The color of bars can
     also be set manually using the "facecolor" property as shown below.

          h = bar (rand (10, 3));
          set (h(1), "facecolor", "r")
          set (h(2), "facecolor", "g")
          set (h(3), "facecolor", "b")

     See also: barh, hist, pie, plot, patch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Produce a bar graph from two vectors of X-Y data.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
colorbar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2253
 -- Command: colorbar
 -- Function File: colorbar (LOC)
 -- Function File: colorbar (DELETE_OPTION)
 -- Function File: colorbar (HCB, ...)
 -- Function File: colorbar (HAX, ...)
 -- Function File: colorbar (..., "peer", HAX, ...)
 -- Function File: colorbar (..., "location", LOC, ...)
 -- Function File: colorbar (..., PROP, VAL, ...)
 -- Function File: H = colorbar (...)
     Add a colorbar to the current axes.

     A colorbar displays the current colormap along with numerical
     rulings so that the color scale can be interpreted.

     The optional input LOC determines the location of the colorbar.
     Valid values for LOC are

     "EastOutside"
          Place the colorbar outside the plot to the right.  This is the
          default.

     "East"
          Place the colorbar inside the plot to the right.

     "WestOutside"
          Place the colorbar outside the plot to the left.

     "West"
          Place the colorbar inside the plot to the left.

     "NorthOutside"
          Place the colorbar above the plot.

     "North"
          Place the colorbar at the top of the plot.

     "SouthOutside"
          Place the colorbar under the plot.

     "South"
          Place the colorbar at the bottom of the plot.

     To remove a colorbar from a plot use any one of the following
     keywords for the DELETE_OPTION: "delete", "hide", "off".

     If the argument "peer" is given, then the following argument is
     treated as the axes handle in which to add the colorbar.
     Alternatively, If the first argument HAX is an axes handle, then
     the colorbar is added to this axis, rather than the current axes
     returned by 'gca'.

     If the first argument HCB is a handle to a colorbar object, then
     operate on this colorbar directly.

     Additional property/value pairs are passed directly to the
     underlying axes object.

     The optional return value H is a graphics handle to the created
     colorbar object.

     Implementation Note: A colorbar is created as an additional axes to
     the current figure with the "tag" property set to "colorbar".  The
     created axes object has the extra property "location" which
     controls the positioning of the colorbar.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Add a colorbar to the current axes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
comet3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 667
 -- Function File: comet3 (Z)
 -- Function File: comet3 (X, Y, Z)
 -- Function File: comet3 (X, Y, Z, P)
 -- Function File: comet3 (HAX, ...)
     Produce a simple comet style animation along the trajectory
     provided by the input coordinate vectors (X, Y, Z).  If only Z is
     specified then X, Y default to the indices of Z.

     The speed of the comet may be controlled by P, which represents the
     time each point is displayed before moving to the next one.  The
     default for P is 0.1 seconds.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     See also: comet.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Produce a simple comet style animation along the trajectory  provided by the input coordinate vectors (X, Y, Z).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
comet


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 648
 -- Function File: comet (Y)
 -- Function File: comet (X, Y)
 -- Function File: comet (X, Y, P)
 -- Function File: comet (HAX, ...)
     Produce a simple comet style animation along the trajectory
     provided by the input coordinate vectors (X, Y).  If X is not
     specified it defaults to the indices of Y.

     The speed of the comet may be controlled by P, which represents the
     time each point is displayed before moving to the next one.  The
     default for P is 0.1 seconds.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     See also: comet3.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
Produce a simple comet style animation along the trajectory  provided by the input coordinate vectors (X, Y).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
compass


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 986
 -- Function File: compass (U, V)
 -- Function File: compass (Z)
 -- Function File: compass (..., STYLE)
 -- Function File: compass (HAX, ...)
 -- Function File: H = compass (...)

     Plot the '(U, V)' components of a vector field emanating from the
     origin of a polar plot.

     The arrow representing each vector has one end at the origin and
     the tip at [U(i), V(i)].  If a single complex argument Z is given,
     then 'U = real (Z)' and 'V = imag (Z)'.

     The style to use for the plot can be defined with a line style
     STYLE of the same format as the 'plot' command.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a vector of graphics handles to the
     line objects representing the drawn vectors.

          a = toeplitz ([1;randn(9,1)], [1,randn(1,9)]);
          compass (eig (a));

     See also: polar, feather, quiver, rose, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Plot the '(U, V)' components of a vector field emanating from the  origin of a polar plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
contour3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1470
 -- Function File: contour3 (Z)
 -- Function File: contour3 (Z, VN)
 -- Function File: contour3 (X, Y, Z)
 -- Function File: contour3 (X, Y, Z, VN)
 -- Function File: contour3 (..., STYLE)
 -- Function File: contour3 (HAX, ...)
 -- Function File: [C, H] = contour3 (...)
     Create a 3-D contour plot.

     'contour3' plots level curves (contour lines) of the matrix Z at a
     Z level corresponding to each contour.  This is in contrast to
     'contour' which plots all of the contour lines at the same Z level
     and produces a 2-D plot.

     The level curves are taken from the contour matrix C computed by
     'contourc' for the same arguments; see the latter for their
     interpretation.

     The appearance of contour lines can be defined with a line style
     STYLE in the same manner as 'plot'.  Only line style and color are
     used; Any markers defined by STYLE are ignored.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional output C are the contour levels in 'contourc' format.

     The optional return value H is a graphics handle to the hggroup
     comprising the contour lines.

     Example:

          contour3 (peaks (19));
          colormap cool;
          hold on;
          surf (peaks (19), "facecolor", "none", "edgecolor", "black");

     See also: contour, contourc, contourf, clabel, meshc, surfc, caxis,
     colormap, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Create a 3-D contour plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
contourc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1526
 -- Function File: [C, LEV] = contourc (Z)
 -- Function File: [C, LEV] = contourc (Z, VN)
 -- Function File: [C, LEV] = contourc (X, Y, Z)
 -- Function File: [C, LEV] = contourc (X, Y, Z, VN)
     Compute contour lines (isolines of constant Z value).

     The matrix Z contains height values above the rectangular grid
     determined by X and Y.  If only a single input Z is provided then X
     is taken to be '1:rows (Z)' and Y is taken to be '1:columns (Z)'.

     The optional input VN is either a scalar denoting the number of
     contour lines to compute or a vector containing the Z values where
     lines will be computed.  When VN is a vector the number of contour
     lines is 'numel (VN)'.  However, to compute a single contour line
     at a given value use 'VN = [val, val]'.  If VN is omitted it
     defaults to 10.

     The return value C is a 2xN matrix containing the contour lines in
     the following format

          C = [lev1, x1, x2, ..., levn, x1, x2, ...
               len1, y1, y2, ..., lenn, y1, y2, ...]

     in which contour line N has a level (height) of LEVN and length of
     LENN.

     The optional return value LEV is a vector with the Z values of of
     the contour levels.

     Example:

          x = 0:2;
          y = x;
          z = x' * y;
          contourc (x, y, z, 2:3)
             =>   2.0000   2.0000   1.0000   3.0000   1.5000   2.0000
                  2.0000   1.0000   2.0000   2.0000   2.0000   1.5000

     See also: contour, contourf, contour3, clabel.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute contour lines (isolines of constant Z value).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
contourf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1380
 -- Function File: contourf (Z)
 -- Function File: contourf (Z, VN)
 -- Function File: contourf (X, Y, Z)
 -- Function File: contourf (X, Y, Z, VN)
 -- Function File: contourf (..., STYLE)
 -- Function File: contourf (HAX, ...)
 -- Function File: [C, H] = contourf (...)
     Create a 2-D contour plot with filled intervals.

     Plot level curves (contour lines) of the matrix Z and fill the
     region between lines with colors from the current colormap.

     The level curves are taken from the contour matrix C computed by
     'contourc' for the same arguments; see the latter for their
     interpretation.

     The appearance of contour lines can be defined with a line style
     STYLE in the same manner as 'plot'.  Only line style and color are
     used; Any markers defined by STYLE are ignored.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional output C are the contour levels in 'contourc' format.

     The optional return value H is a graphics handle to the hggroup
     comprising the contour lines.

     The following example plots filled contours of the 'peaks'
     function.

          [x, y, z] = peaks (50);
          contourf (x, y, z, -7:9)

     See also: ezcontourf, contour, contourc, contour3, clabel, meshc,
     surfc, caxis, colormap, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Create a 2-D contour plot with filled intervals.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
contour


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1201
 -- Function File: contour (Z)
 -- Function File: contour (Z, VN)
 -- Function File: contour (X, Y, Z)
 -- Function File: contour (X, Y, Z, VN)
 -- Function File: contour (..., STYLE)
 -- Function File: contour (HAX, ...)
 -- Function File: [C, H] = contour (...)
     Create a 2-D contour plot.

     Plot level curves (contour lines) of the matrix Z, using the
     contour matrix C computed by 'contourc' from the same arguments;
     see the latter for their interpretation.

     The appearance of contour lines can be defined with a line style
     STYLE in the same manner as 'plot'.  Only line style and color are
     used; Any markers defined by STYLE are ignored.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional output C are the contour levels in 'contourc' format.

     The optional return value H is a graphics handle to the hggroup
     comprising the contour lines.

     Example:

          x = 0:2;
          y = x;
          z = x' * y;
          contour (x, y, z, 2:3)

     See also: ezcontour, contourc, contourf, contour3, clabel, meshc,
     surfc, caxis, colormap, plot.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Create a 2-D contour plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cylinder


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 951
 -- Command: cylinder
 -- Function File: cylinder (R)
 -- Function File: cylinder (R, N)
 -- Function File: cylinder (HAX, ...)
 -- Function File: [X, Y, Z] = cylinder (...)
     Plot a 3-D unit cylinder.

     The optional input R is a vector specifying the radius along the
     unit z-axis.  The default is [1 1] indicating radius 1 at 'Z == 0'
     and at 'Z == 1'.

     The optional input N determines the number of faces around the the
     circumference of the cylinder.  The default value is 20.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     If outputs are requested 'cylinder' returns three matrices in
     'meshgrid' format, such that 'surf (X, Y, Z)' generates a unit
     cylinder.

     Example:

          [x, y, z] = cylinder (10:-1:0, 50);
          surf (x, y, z);
          title ("a cone");

     See also: ellipsoid, rectangle, sphere.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Plot a 3-D unit cylinder.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
ellipsoid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 802
 -- Function File: ellipsoid (XC, YC, ZC, XR, YR, ZR, N)
 -- Function File: ellipsoid (..., N)
 -- Function File: ellipsoid (HAX, ...)
 -- Function File: [X, Y, Z] = ellipsoid (...)
     Plot a 3-D ellipsoid.

     The inputs XC, YC, ZC specify the center of the ellipsoid.  The
     inputs XR, YR, ZR specify the semi-major axis lengths.

     The optional input N determines the number of faces around the the
     circumference of the cylinder.  The default value is 20.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     If outputs are requested 'ellipsoid' returns three matrices in
     'meshgrid' format, such that 'surf (X, Y, Z)' generates the
     ellipsoid.

     See also: cylinder, rectangle, sphere.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Plot a 3-D ellipsoid.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
errorbar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4384
 -- Function File: errorbar (Y, EY)
 -- Function File: errorbar (Y, ..., FMT)
 -- Function File: errorbar (X, Y, EY)
 -- Function File: errorbar (X, Y, ERR, FMT)
 -- Function File: errorbar (X, Y, LERR, UERR, FMT)
 -- Function File: errorbar (X, Y, EX, EY, FMT)
 -- Function File: errorbar (X, Y, LX, UX, LY, UY, FMT)
 -- Function File: errorbar (X1, Y1, ..., FMT, XN, YN, ...)
 -- Function File: errorbar (HAX, ...)
 -- Function File: H = errorbar (...)
     Create a 2-D plot with errorbars.

     Many different combinations of arguments are possible.  The
     simplest form is

          errorbar (Y, EY)

     where the first argument is taken as the set of Y coordinates, the
     second argument EY are the errors around the Y values, and the X
     coordinates are taken to be the indices of the elements ('1:numel
     (Y)').

     The general form of the function is

          errorbar (X, Y, ERR1, ..., FMT, ...)

     After the X and Y arguments there can be 1, 2, or 4 parameters
     specifying the error values depending on the nature of the error
     values and the plot format FMT.

     ERR (scalar)
          When the error is a scalar all points share the same error
          value.  The errorbars are symmetric and are drawn from
          DATA-ERR to DATA+ERR.  The FMT argument determines whether ERR
          is in the x-direction, y-direction (default), or both.

     ERR (vector or matrix)
          Each data point has a particular error value.  The errorbars
          are symmetric and are drawn from DATA(n)-ERR(n) to
          DATA(n)+ERR(n).

     LERR, UERR (scalar)
          The errors have a single low-side value and a single
          upper-side value.  The errorbars are not symmetric and are
          drawn from DATA-LERR to DATA+UERR.

     LERR, UERR (vector or matrix)
          Each data point has a low-side error and an upper-side error.
          The errorbars are not symmetric and are drawn from
          DATA(n)-LERR(n) to DATA(n)+UERR(n).

     Any number of data sets (X1,Y1, X2,Y2, ...) may appear as long as
     they are separated by a format string FMT.

     If Y is a matrix, X and the error parameters must also be matrices
     having the same dimensions.  The columns of Y are plotted versus
     the corresponding columns of X and errorbars are taken from the
     corresponding columns of the error parameters.

     If FMT is missing, the yerrorbars ("~") plot style is assumed.

     If the FMT argument is supplied then it is interpreted, as in
     normal plots, to specify the line style, marker, and color.  In
     addition, FMT may include an errorbar style which *must precede*
     the ordinary format codes.  The following errorbar styles are
     supported:

     '~'
          Set yerrorbars plot style (default).

     '>'
          Set xerrorbars plot style.

     '~>'
          Set xyerrorbars plot style.

     '#~'
          Set yboxes plot style.

     '#'
          Set xboxes plot style.

     '#~>'
          Set xyboxes plot style.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a handle to the hggroup object
     representing the data plot and errorbars.

     Note: For compatibility with MATLAB a line is drawn through all
     data points.  However, most scientific errorbar plots are a scatter
     plot of points with errorbars.  To accomplish this, add a marker
     style to the FMT argument such as ".".  Alternatively, remove the
     line by modifying the returned graphic handle with 'set (h,
     "linestyle", "none")'.

     Examples:

          errorbar (X, Y, EX, ">.r")

     produces an xerrorbar plot of Y versus X with X errorbars drawn
     from X-EX to X+EX.  The marker "."  is used so no connecting line
     is drawn and the errorbars appear in red.

          errorbar (X, Y1, EY, "~",
                    X, Y2, LY, UY)

     produces yerrorbar plots with Y1 and Y2 versus X.  Errorbars for Y1
     are drawn from Y1-EY to Y1+EY, errorbars for Y2 from Y2-LY to
     Y2+UY.

          errorbar (X, Y, LX, UX,
                    LY, UY, "~>")

     produces an xyerrorbar plot of Y versus X in which X errorbars are
     drawn from X-LX to X+UX and Y errorbars from Y-LY to Y+UY.

     See also: semilogxerr, semilogyerr, loglogerr, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Create a 2-D plot with errorbars.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
ezcontourf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1147
 -- Function File: ezcontourf (F)
 -- Function File: ezcontourf (..., DOM)
 -- Function File: ezcontourf (..., N)
 -- Function File: ezcontourf (HAX, ...)
 -- Function File: H = ezcontourf (...)

     Plot the filled contour lines of a function.

     F is a string, inline function, or function handle with two
     arguments defining the function.  By default the plot is over the
     meshed domain '-2*pi <= X | Y <= 2*pi' with 60 points in each
     dimension.

     If DOM is a two element vector, it represents the minimum and
     maximum values of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum values are '[xmin xmax ymin ymax]'.

     N is a scalar defining the number of points to use in each
     dimension.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     plot.

     Example:

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezcontourf (f, [-3, 3]);

     See also: contourf, ezcontour, ezplot, ezmeshc, ezsurfc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Plot the filled contour lines of a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
ezcontour


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1134
 -- Function File: ezcontour (F)
 -- Function File: ezcontour (..., DOM)
 -- Function File: ezcontour (..., N)
 -- Function File: ezcontour (HAX, ...)
 -- Function File: H = ezcontour (...)

     Plot the contour lines of a function.

     F is a string, inline function, or function handle with two
     arguments defining the function.  By default the plot is over the
     meshed domain '-2*pi <= X | Y <= 2*pi' with 60 points in each
     dimension.

     If DOM is a two element vector, it represents the minimum and
     maximum values of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum values are '[xmin xmax ymin ymax]'.

     N is a scalar defining the number of points to use in each
     dimension.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     plot.

     Example:

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezcontour (f, [-3, 3]);

     See also: contour, ezcontourf, ezplot, ezmeshc, ezsurfc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Plot the contour lines of a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ezmeshc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1577
 -- Function File: ezmeshc (F)
 -- Function File: ezmeshc (FX, FY, FZ)
 -- Function File: ezmeshc (..., DOM)
 -- Function File: ezmeshc (..., N)
 -- Function File: ezmeshc (..., "circ")
 -- Function File: ezmeshc (HAX, ...)
 -- Function File: H = ezmeshc (...)

     Plot the mesh and contour lines defined by a function.

     F is a string, inline function, or function handle with two
     arguments defining the function.  By default the plot is over the
     meshed domain '-2*pi <= X | Y <= 2*pi' with 60 points in each
     dimension.

     If three functions are passed, then plot the parametrically defined
     function '[FX (S, T), FY (S, T), FZ (S, T)]'.

     If DOM is a two element vector, it represents the minimum and
     maximum values of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum values are '[xmin xmax ymin ymax]'.

     N is a scalar defining the number of points to use in each
     dimension.

     If the argument "circ" is given, then the function is plotted over
     a disk centered on the middle of the domain DOM.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a 2-element vector with a graphics
     handle for the created mesh plot and a second handle for the
     created contour plot.

     Example: 2-argument function

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezmeshc (f, [-3, 3]);

     See also: meshc, ezmesh, ezplot, ezsurf, ezsurfc, hidden.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Plot the mesh and contour lines defined by a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ezmesh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1703
 -- Function File: ezmesh (F)
 -- Function File: ezmesh (FX, FY, FZ)
 -- Function File: ezmesh (..., DOM)
 -- Function File: ezmesh (..., N)
 -- Function File: ezmesh (..., "circ")
 -- Function File: ezmesh (HAX, ...)
 -- Function File: H = ezmesh (...)

     Plot the mesh defined by a function.

     F is a string, inline function, or function handle with two
     arguments defining the function.  By default the plot is over the
     meshed domain '-2*pi <= X | Y <= 2*pi' with 60 points in each
     dimension.

     If three functions are passed, then plot the parametrically defined
     function '[FX (S, T), FY (S, T), FZ (S, T)]'.

     If DOM is a two element vector, it represents the minimum and
     maximum values of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum values are '[xmin xmax ymin ymax]'.

     N is a scalar defining the number of points to use in each
     dimension.

     If the argument "circ" is given, then the function is plotted over
     a disk centered on the middle of the domain DOM.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     Example 1: 2-argument function

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezmesh (f, [-3, 3]);

     Example 2: parametrically defined function

          fx = @(s,t) cos (s) .* cos (t);
          fy = @(s,t) sin (s) .* cos (t);
          fz = @(s,t) sin (t);
          ezmesh (fx, fy, fz, [-pi, pi, -pi/2, pi/2], 20);

     See also: mesh, ezmeshc, ezplot, ezsurf, ezsurfc, hidden.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Plot the mesh defined by a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ezplot3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1023
 -- Function File: ezplot3 (FX, FY, FZ)
 -- Function File: ezplot3 (..., DOM)
 -- Function File: ezplot3 (..., N)
 -- Function File: ezplot3 (HAX, ...)
 -- Function File: H = ezplot3 (...)

     Plot a parametrically defined curve in three dimensions.

     FX, FY, and FZ are strings, inline functions, or function handles
     with one argument defining the function.  By default the plot is
     over the domain '0 <= T <= 2*pi' with 500 points.

     If DOM is a two element vector, it represents the minimum and
     maximum values of T.

     N is a scalar defining the number of points to use in plotting the
     function.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     plot.

          fx = @(t) cos (t);
          fy = @(t) sin (t);
          fz = @(t) t;
          ezplot3 (fx, fy, fz, [0, 10*pi], 100);

     See also: plot3, ezplot, ezmesh, ezsurf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Plot a parametrically defined curve in three dimensions.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ezplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1635
 -- Function File: ezplot (F)
 -- Function File: ezplot (F2V)
 -- Function File: ezplot (FX, FY)
 -- Function File: ezplot (..., DOM)
 -- Function File: ezplot (..., N)
 -- Function File: ezplot (HAX, ...)
 -- Function File: H = ezplot (...)

     Plot the 2-D curve defined by the function F.

     The function F may be a string, inline function, or function handle
     and can have either one or two variables.  If F has one variable,
     then the function is plotted over the domain '-2*pi < X < 2*pi'
     with 500 points.

     If F2V is a function of two variables then the implicit function
     'F(X,Y) = 0' is calculated over the meshed domain '-2*pi <= X | Y
     <= 2*pi' with 60 points in each dimension.

     For example:

          ezplot (@(X, Y) X.^2 - Y.^2 - 1)

     If two functions are passed as inputs then the parametric function

          X = FX (T)
          Y = FY (T)

     is plotted over the domain '-2*pi <= T <= 2*pi' with 500 points.

     If DOM is a two element vector, it represents the minimum and
     maximum values of both X and Y, or T for a parametric plot.  If DOM
     is a four element vector, then the minimum and maximum values are
     '[xmin xmax ymin ymax]'.

     N is a scalar defining the number of points to use in plotting the
     function.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a vector of graphics handles to the
     created line objects.

     See also: plot, ezplot3, ezpolar, ezcontour, ezcontourf, ezmesh,
     ezmeshc, ezsurf, ezsurfc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Plot the 2-D curve defined by the function F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ezpolar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 969
 -- Function File: ezpolar (F)
 -- Function File: ezpolar (..., DOM)
 -- Function File: ezpolar (..., N)
 -- Function File: ezpolar (HAX, ...)
 -- Function File: H = ezpolar (...)

     Plot a 2-D function in polar coordinates.

     The function F is a string, inline function, or function handle
     with a single argument.  The expected form of the function is 'RHO
     = F(THETA)'.  By default the plot is over the domain '0 <= THETA <=
     2*pi' with 500 points.

     If DOM is a two element vector, it represents the minimum and
     maximum values of THETA.

     N is a scalar defining the number of points to use in plotting the
     function.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     plot.

     Example:

          ezpolar (@(t) sin (5/4 * t), [0, 8*pi]);

     See also: polar, ezplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Plot a 2-D function in polar coordinates.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ezsurfc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1564
 -- Function File: ezsurfc (F)
 -- Function File: ezsurfc (FX, FY, FZ)
 -- Function File: ezsurfc (..., DOM)
 -- Function File: ezsurfc (..., N)
 -- Function File: ezsurfc (..., "circ")
 -- Function File: ezsurfc (HAX, ...)
 -- Function File: H = ezsurfc (...)

     Plot the surface and contour lines defined by a function.

     F is a string, inline function, or function handle with two
     arguments defining the function.  By default the plot is over the
     meshed domain '-2*pi <= X | Y <= 2*pi' with 60 points in each
     dimension.

     If three functions are passed, then plot the parametrically defined
     function '[FX (S, T), FY (S, T), FZ (S, T)]'.

     If DOM is a two element vector, it represents the minimum and
     maximum values of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum values are '[xmin xmax ymin ymax]'.

     N is a scalar defining the number of points to use in each
     dimension.

     If the argument "circ" is given, then the function is plotted over
     a disk centered on the middle of the domain DOM.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a 2-element vector with a graphics
     handle for the created surface plot and a second handle for the
     created contour plot.

     Example:

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezsurfc (f, [-3, 3]);

     See also: surfc, ezsurf, ezplot, ezmesh, ezmeshc, shading.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Plot the surface and contour lines defined by a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ezsurf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1707
 -- Function File: ezsurf (F)
 -- Function File: ezsurf (FX, FY, FZ)
 -- Function File: ezsurf (..., DOM)
 -- Function File: ezsurf (..., N)
 -- Function File: ezsurf (..., "circ")
 -- Function File: ezsurf (HAX, ...)
 -- Function File: H = ezsurf (...)

     Plot the surface defined by a function.

     F is a string, inline function, or function handle with two
     arguments defining the function.  By default the plot is over the
     meshed domain '-2*pi <= X | Y <= 2*pi' with 60 points in each
     dimension.

     If three functions are passed, then plot the parametrically defined
     function '[FX (S, T), FY (S, T), FZ (S, T)]'.

     If DOM is a two element vector, it represents the minimum and
     maximum values of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum values are '[xmin xmax ymin ymax]'.

     N is a scalar defining the number of points to use in each
     dimension.

     If the argument "circ" is given, then the function is plotted over
     a disk centered on the middle of the domain DOM.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     Example 1: 2-argument function

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezsurf (f, [-3, 3]);

     Example 2: parametrically defined function

          fx = @(s,t) cos (s) .* cos (t);
          fy = @(s,t) sin (s) .* cos (t);
          fz = @(s,t) sin (t);
          ezsurf (fx, fy, fz, [-pi, pi, -pi/2, pi/2], 20);

     See also: surf, ezsurfc, ezplot, ezmesh, ezmeshc, shading.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Plot the surface defined by a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
feather


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 880
 -- Function File: feather (U, V)
 -- Function File: feather (Z)
 -- Function File: feather (..., STYLE)
 -- Function File: feather (HAX, ...)
 -- Function File: H = feather (...)

     Plot the '(U, V)' components of a vector field emanating from
     equidistant points on the x-axis.

     If a single complex argument Z is given, then 'U = real (Z)' and 'V
     = imag (Z)'.

     The style to use for the plot can be defined with a line style
     STYLE of the same format as the 'plot' command.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a vector of graphics handles to the
     line objects representing the drawn vectors.

          phi = [0 : 15 : 360] * pi/180;
          feather (sin (phi), cos (phi));

     See also: plot, quiver, compass.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Plot the '(U, V)' components of a vector field emanating from  equidistant points on the x-axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fill


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1738
 -- Function File: fill (X, Y, C)
 -- Function File: fill (X1, Y1, C1, X2, Y2, C2)
 -- Function File: fill (..., PROP, VAL)
 -- Function File: fill (HAX, ...)
 -- Function File: H = fill (...)
     Create one or more filled 2-D polygons.

     The inputs X and Y are the coordinates of the polygon vertices.  If
     the inputs are matrices then the rows represent different vertices
     and each column produces a different polygon.  'fill' will close
     any open polygons before plotting.

     The input C determines the color of the polygon.  The simplest form
     is a single color specification such as a 'plot' format or an
     RGB-triple.  In this case the polygon(s) will have one unique
     color.  If C is a vector or matrix then the color data is first
     scaled using 'caxis' and then indexed into the current colormap.  A
     row vector will color each polygon (a column from matrices X and Y)
     with a single computed color.  A matrix C of the same size as X and
     Y will compute the color of each vertex and then interpolate the
     face color between the vertices.

     Multiple property/value pairs for the underlying patch object may
     be specified, but they must appear in pairs.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a vector of graphics handles to the
     created patch objects.

     Example: red square

          vertices = [0 0
                      1 0
                      1 1
                      0 1];
          fill (vertices(:,1), vertices(:,2), "r");
          axis ([-0.5 1.5, -0.5 1.5])
          axis equal

     See also: patch, caxis, colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Create one or more filled 2-D polygons.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1578
 -- Function File: fplot (FN, LIMITS)
 -- Function File: fplot (..., TOL)
 -- Function File: fplot (..., N)
 -- Function File: fplot (..., FMT)
 -- Function File: [X, Y] = fplot (...)
     Plot a function FN within the range defined by LIMITS.

     FN is a function handle, inline function, or string containing the
     name of the function to evaluate.

     The limits of the plot are of the form '[XLO, XHI]' or
     '[XLO, XHI, YLO, YHI]'.

     The next three arguments are all optional and any number of them
     may be given in any order.

     TOL is the relative tolerance to use for the plot and defaults to
     2e-3 (.2%).

     N is the minimum number of points to use.  When N is specified, the
     maximum stepsize will be 'XHI - XLO / N'.  More than N points may
     still be used in order to meet the relative tolerance requirement.

     The FMT argument specifies the linestyle to be used by the plot
     command.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     With no output arguments the results are immediately plotted.  With
     two output arguments the 2-D plot data is returned.  The data can
     subsequently be plotted manually with 'plot (X, Y)'.

     Example:

          fplot (@cos, [0, 2*pi])
          fplot ("[cos(x), sin(x)]", [0, 2*pi])

     Note: 'fplot' works best with continuous functions.  Functions with
     discontinuities are unlikely to plot well.  This restriction may be
     removed in the future.

     See also: ezplot, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Plot a function FN within the range defined by LIMITS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
hist


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1674
 -- Function File: hist (Y)
 -- Function File: hist (Y, X)
 -- Function File: hist (Y, NBINS)
 -- Function File: hist (Y, X, NORM)
 -- Function File: hist (..., PROP, VAL, ...)
 -- Function File: hist (HAX, ...)
 -- Function File: [NN, XX] = hist (...)
     Produce histogram counts or plots.

     With one vector input argument, Y, plot a histogram of the values
     with 10 bins.  The range of the histogram bins is determined by the
     range of the data.  With one matrix input argument, Y, plot a
     histogram where each bin contains a bar per input column.

     Given a second vector argument, X, use that as the centers of the
     bins, with the width of the bins determined from the adjacent
     values in the vector.

     If scalar, the second argument, NBINS, defines the number of bins.

     If a third argument is provided, the histogram is normalized such
     that the sum of the bars is equal to NORM.

     Extreme values are lumped into the first and last bins.

     The histogram's appearance may be modified by specifying
     property/value pairs.  For example the face and edge color may be
     modified.

          hist (randn (1, 100), 25, "facecolor", "r", "edgecolor", "b");

     The histogram's colors also depend upon the current colormap.

          hist (rand (10, 3));
          colormap (summer ());

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     With two output arguments, produce the values NN (numbers of
     elements) and XX (bin centers) such that 'bar (XX, NN)' will plot
     the histogram.

     See also: histc, bar, pie, rose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Produce histogram counts or plots.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
isocolors


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3393
 -- Function File: [CD] = isocolors (C, V)
 -- Function File: [CD] = isocolors (X, Y, Z, C, V)
 -- Function File: [CD] = isocolors (X, Y, Z, R, G, B, V)
 -- Function File: [CD] = isocolors (R, G, B, V)
 -- Function File: [CD] = isocolors (..., P)
 -- Function File: isocolors (...)

     If called with one output argument and the first input argument C
     is a three-dimensional array that contains color values and the
     second input argument V keeps the vertices of a geometry then
     return a matrix CD with color data information for the geometry at
     computed points '[x, y, z] = meshgrid (1:l, 1:m, 1:n)'.  The output
     argument CD can be taken to manually set FaceVertexCData of a
     patch.

     If called with further input arguments X, Y and Z which are
     three-dimensional arrays of the same size than C then the color
     data is taken at those given points.  Instead of the color data C
     this function can also be called with RGB values R, G, B.  If input
     argumnets X, Y, Z are not given then again 'meshgrid' computed
     values are taken.

     Optionally, the patch handle P can be given as the last input
     argument to all variations of function calls instead of the
     vertices data V.  Finally, if no output argument is given then
     directly change the colors of a patch that is given by the patch
     handle P.

     For example:

          function [] = isofinish (p)
            set (gca, "PlotBoxAspectRatioMode", "manual", ...
                      "PlotBoxAspectRatio", [1 1 1]);
            set (p, "FaceColor", "interp");
            ## set (p, "FaceLighting", "flat");
            ## light ("Position", [1 1 5]); ## Available with JHandles
          endfunction

          N = 15;    # Increase number of vertices in each direction
          iso = .4;  # Change isovalue to .1 to display a sphere
          lin = linspace (0, 2, N);
          [x, y, z] = meshgrid (lin, lin, lin);
          c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
          figure (); # Open another figure window

          subplot (2,2,1); view (-38, 20);
          [f, v] = isosurface (x, y, z, c, iso);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          cdat = rand (size (c));       # Compute random patch color data
          isocolors (x, y, z, cdat, p); # Directly set colors of patch
          isofinish (p);                # Call user function isofinish

          subplot (2,2,2); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          [r, g, b] = meshgrid (lin, 2-lin, 2-lin);
          cdat = isocolors (x, y, z, c, v); # Compute color data vertices
          set (p, "FaceVertexCData", cdat); # Set color data manually
          isofinish (p);

          subplot (2,2,3); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          cdat = isocolors (r, g, b, c, p); # Compute color data patch
          set (p, "FaceVertexCData", cdat); # Set color data manually
          isofinish (p);

          subplot (2,2,4); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          r = g = b = repmat ([1:N] / N, [N, 1, N]); # Black to white
          cdat = isocolors (x, y, z, r, g, b, v);
          set (p, "FaceVertexCData", cdat);
          isofinish (p);

     See also: isosurface, isonormals.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 318
If called with one output argument and the first input argument C  is a three-dimensional array that contains color values and the  second input argument V keeps the vertices of a geometry then  return a matrix CD with color data information for the geometry at  computed points '[x, y, z] = meshgrid (1:l, 1:m, 1:n)'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
isonormals


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3295
 -- Function File: [N] = isonormals (VAL, V)
 -- Function File: [N] = isonormals (VAL, P)
 -- Function File: [N] = isonormals (X, Y, Z, VAL, V)
 -- Function File: [N] = isonormals (X, Y, Z, VAL, P)
 -- Function File: [N] = isonormals (..., "negate")
 -- Function File: isonormals (..., P)

     If called with one output argument and the first input argument VAL
     is a three-dimensional array that contains the data for an
     isosurface geometry and the second input argument V keeps the
     vertices of an isosurface then return the normals N in form of a
     matrix with the same size than V at computed points '[x, y, z] =
     meshgrid (1:l, 1:m, 1:n)'.  The output argument N can be taken to
     manually set VERTEXNORMALS of a patch.

     If called with further input arguments X, Y and Z which are
     three-dimensional arrays with the same size than VAL then the
     volume data is taken at those given points.  Instead of the
     vertices data V a patch handle P can be passed to this function.

     If given the string input argument "negate" as last input argument
     then compute the reverse vector normals of an isosurface geometry.

     If no output argument is given then directly redraw the patch that
     is given by the patch handle P.

     For example:

          function [] = isofinish (p)
            set (gca, "PlotBoxAspectRatioMode", "manual", ...
                      "PlotBoxAspectRatio", [1 1 1]);
            set (p, "VertexNormals", -get (p,"VertexNormals")); # Revert normals
            set (p, "FaceColor", "interp");
            ## set (p, "FaceLighting", "phong");
            ## light ("Position", [1 1 5]); # Available with JHandles
          endfunction

          N = 15;    # Increase number of vertices in each direction
          iso = .4;  # Change isovalue to .1 to display a sphere
          lin = linspace (0, 2, N);
          [x, y, z] = meshgrid (lin, lin, lin);
          c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
          figure (); # Open another figure window

          subplot (2,2,1); view (-38, 20);
          [f, v, cdat] = isosurface (x, y, z, c, iso, y);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
                     "FaceColor", "interp", "EdgeColor", "none");
          isofinish (p); ## Call user function isofinish

          subplot (2,2,2); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
                     "FaceColor", "interp", "EdgeColor", "none");
          isonormals (x, y, z, c, p); # Directly modify patch
          isofinish (p);

          subplot (2,2,3); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
                     "FaceColor", "interp", "EdgeColor", "none");
          n = isonormals (x, y, z, c, v); # Compute normals of isosurface
          set (p, "VertexNormals", n);    # Manually set vertex normals
          isofinish (p);

          subplot (2,2,4); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
                     "FaceColor", "interp", "EdgeColor", "none");
          isonormals (x, y, z, c, v, "negate"); # Use reverse directly
          isofinish (p);

     See also: isosurface, isocolors.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 350
If called with one output argument and the first input argument VAL  is a three-dimensional array that contains the data for an  isosurface geometry and the second input argument V keeps the  vertices of an isosurface then return the normals N in form of a  matrix with the same size than V at computed points '[x, y, z] =  meshgrid (1:l, 1:m, 1:n)'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
isosurface


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4113
 -- Function File: [FV] = isosurface (VAL, ISO)
 -- Function File: [FV] = isosurface (X, Y, Z, VAL, ISO)
 -- Function File: [FV] = isosurface (..., "noshare", "verbose")
 -- Function File: [FVC] = isosurface (..., COL)
 -- Function File: [F, V] = isosurface (X, Y, Z, VAL, ISO)
 -- Function File: [F, V, C] = isosurface (X, Y, Z, VAL, ISO, COL)
 -- Function File: isosurface (X, Y, Z, VAL, ISO, COL, OPT)

     If called with one output argument and the first input argument VAL
     is a three-dimensional array that contains the data of an
     isosurface geometry and the second input argument ISO keeps the
     isovalue as a scalar value then return a structure array FV that
     contains the fields FACES and VERTICES at computed points '[x, y,
     z] = meshgrid (1:l, 1:m, 1:n)'.  The output argument FV can
     directly be taken as an input argument for the 'patch' function.

     If called with further input arguments X, Y and Z which are
     three-dimensional arrays with the same size than VAL then the
     volume data is taken at those given points.

     The string input argument "noshare" is only for compatibility and
     has no effect.  If given the string input argument "verbose" then
     print messages to the command line interface about the current
     progress.

     If called with the input argument COL which is a three-dimensional
     array of the same size than VAL then take those values for the
     interpolation of coloring the isosurface geometry.  Add the field
     FACEVERTEXCDATA to the structure array FV.

     If called with two or three output arguments then return the
     information about the faces F, vertices V and color data C as
     separate arrays instead of a single structure array.

     If called with no output argument then directly process the
     isosurface geometry with the 'patch' command.

     For example,

          [x, y, z] = meshgrid (1:5, 1:5, 1:5);
          val = rand (5, 5, 5);
          isosurface (x, y, z, val, .5);

     will directly draw a random isosurface geometry in a graphics
     window.  Another example for an isosurface geometry with different
     additional coloring

          N = 15;    # Increase number of vertices in each direction
          iso = .4;  # Change isovalue to .1 to display a sphere
          lin = linspace (0, 2, N);
          [x, y, z] = meshgrid (lin, lin, lin);
          c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
          figure (); # Open another figure window

          subplot (2,2,1); view (-38, 20);
          [f, v] = isosurface (x, y, z, c, iso);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          set (gca, "PlotBoxAspectRatioMode", "manual", ...
                    "PlotBoxAspectRatio", [1 1 1]);
          # set (p, "FaceColor", "green", "FaceLighting", "phong");
          # light ("Position", [1 1 5]); # Available with the JHandles package

          subplot (2,2,2); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "blue");
          set (gca, "PlotBoxAspectRatioMode", "manual", ...
                    "PlotBoxAspectRatio", [1 1 1]);
          # set (p, "FaceColor", "none", "FaceLighting", "phong");
          # light ("Position", [1 1 5]);

          subplot (2,2,3); view (-38, 20);
          [f, v, c] = isosurface (x, y, z, c, iso, y);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, ...
                     "FaceColor", "interp", "EdgeColor", "none");
          set (gca, "PlotBoxAspectRatioMode", "manual", ...
                    "PlotBoxAspectRatio", [1 1 1]);
          # set (p, "FaceLighting", "phong");
          # light ("Position", [1 1 5]);

          subplot (2,2,4); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, ...
                     "FaceColor", "interp", "EdgeColor", "blue");
          set (gca, "PlotBoxAspectRatioMode", "manual", ...
                    "PlotBoxAspectRatio", [1 1 1]);
          # set (p, "FaceLighting", "phong");
          # light ("Position", [1 1 5]);

     See also: isonormals, isocolors.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 357
If called with one output argument and the first input argument VAL  is a three-dimensional array that contains the data of an  isosurface geometry and the second input argument ISO keeps the  isovalue as a scalar value then return a structure array FV that  contains the fields FACES and VERTICES at computed points '[x, y,  z] = meshgrid (1:l, 1:m, 1:n)'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
line


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 819
 -- Function File: line ()
 -- Function File: line (X, Y)
 -- Function File: line (X, Y, PROPERTY, VALUE, ...)
 -- Function File: line (X, Y, Z)
 -- Function File: line (X, Y, Z, PROPERTY, VALUE, ...)
 -- Function File: line (PROPERTY, VALUE, ...)
 -- Function File: line (HAX, ...)
 -- Function File: H = line (...)
     Create line object from X and Y (and possibly Z) and insert in the
     current axes.

     Multiple property-value pairs may be specified for the line object,
     but they must appear in pairs.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle (or vector of
     handles) to the line objects created.

     See also: image, patch, rectangle, surface, text.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 81
Create line object from X and Y (and possibly Z) and insert in the  current axes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
loglogerr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1075
 -- Function File: loglogerr (Y, EY)
 -- Function File: loglogerr (Y, ..., FMT)
 -- Function File: loglogerr (X, Y, EY)
 -- Function File: loglogerr (X, Y, ERR, FMT)
 -- Function File: loglogerr (X, Y, LERR, UERR, FMT)
 -- Function File: loglogerr (X, Y, EX, EY, FMT)
 -- Function File: loglogerr (X, Y, LX, UX, LY, UY, FMT)
 -- Function File: loglogerr (X1, Y1, ..., FMT, XN, YN, ...)
 -- Function File: loglogerr (HAX, ...)
 -- Function File: H = loglogerr (...)
     Produce 2-D plots on a double logarithm axis with errorbars.

     Many different combinations of arguments are possible.  The most
     common form is

          loglogerr (X, Y, EY, FMT)

     which produces a double logarithm plot of Y versus X with errors in
     the Y-scale defined by EY and the plot format defined by FMT.
     *Note errorbar: XREFerrorbar, for available formats and additional
     information.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     See also: errorbar, semilogxerr, semilogyerr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Produce 2-D plots on a double logarithm axis with errorbars.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
loglog


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 650
 -- Function File: loglog (Y)
 -- Function File: loglog (X, Y)
 -- Function File: loglog (X, Y, PROP, VALUE, ...)
 -- Function File: loglog (X, Y, FMT)
 -- Function File: loglog (HAX, ...)
 -- Function File: H = loglog (...)
     Produce a 2-D plot using logarithmic scales for both axes.

     See the documentation of 'plot' for a description of the arguments
     that 'loglog' will accept.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     plot.

     See also: plot, semilogx, semilogy.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Produce a 2-D plot using logarithmic scales for both axes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
meshc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1550
 -- Function File: meshc (X, Y, Z)
 -- Function File: meshc (Z)
 -- Function File: meshc (..., C)
 -- Function File: meshc (..., PROP, VAL, ...)
 -- Function File: meshc (HAX, ...)
 -- Function File: H = meshc (...)
     Plot a 3-D wireframe mesh with underlying contour lines.

     The wireframe mesh is plotted using rectangles.  The vertices of
     the rectangles [X, Y] are typically the output of 'meshgrid'.  over
     a 2-D rectangular region in the x-y plane.  Z determines the height
     above the plane of each vertex.  If only a single Z matrix is
     given, then it is plotted over the meshgrid 'X = 1:columns (Z), Y =
     1:rows (Z)'.  Thus, columns of Z correspond to different X values
     and rows of Z correspond to different Y values.

     The color of the mesh is computed by linearly scaling the Z values
     to fit the range of the current colormap.  Use 'caxis' and/or
     change the colormap to control the appearance.

     Optionally the color of the mesh can be specified independently of
     Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying
     surface object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a 2-element vector with a graphics
     handle to the created surface object and to the created contour
     plot.

     See also: ezmeshc, mesh, meshz, contour, surfc, surface, meshgrid,
     hidden, shading, colormap, caxis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Plot a 3-D wireframe mesh with underlying contour lines.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
mesh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1462
 -- Function File: mesh (X, Y, Z)
 -- Function File: mesh (Z)
 -- Function File: mesh (..., C)
 -- Function File: mesh (..., PROP, VAL, ...)
 -- Function File: mesh (HAX, ...)
 -- Function File: H = mesh (...)
     Plot a 3-D wireframe mesh.

     The wireframe mesh is plotted using rectangles.  The vertices of
     the rectangles [X, Y] are typically the output of 'meshgrid'.  over
     a 2-D rectangular region in the x-y plane.  Z determines the height
     above the plane of each vertex.  If only a single Z matrix is
     given, then it is plotted over the meshgrid 'X = 1:columns (Z), Y =
     1:rows (Z)'.  Thus, columns of Z correspond to different X values
     and rows of Z correspond to different Y values.

     The color of the mesh is computed by linearly scaling the Z values
     to fit the range of the current colormap.  Use 'caxis' and/or
     change the colormap to control the appearance.

     Optionally, the color of the mesh can be specified independently of
     Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying
     surface object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     See also: ezmesh, meshc, meshz, trimesh, contour, surf, surface,
     meshgrid, hidden, shading, colormap, caxis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Plot a 3-D wireframe mesh.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
meshz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1487
 -- Function File: meshz (X, Y, Z)
 -- Function File: meshz (Z)
 -- Function File: meshz (..., C)
 -- Function File: meshz (..., PROP, VAL, ...)
 -- Function File: meshz (HAX, ...)
 -- Function File: H = meshz (...)
     Plot a 3-D wireframe mesh with a surrounding curtain.

     The wireframe mesh is plotted using rectangles.  The vertices of
     the rectangles [X, Y] are typically the output of 'meshgrid'.  over
     a 2-D rectangular region in the x-y plane.  Z determines the height
     above the plane of each vertex.  If only a single Z matrix is
     given, then it is plotted over the meshgrid 'X = 1:columns (Z), Y =
     1:rows (Z)'.  Thus, columns of Z correspond to different X values
     and rows of Z correspond to different Y values.

     The color of the mesh is computed by linearly scaling the Z values
     to fit the range of the current colormap.  Use 'caxis' and/or
     change the colormap to control the appearance.

     Optionally the color of the mesh can be specified independently of
     Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying
     surface object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     See also: mesh, meshc, contour, surf, surface, waterfall, meshgrid,
     hidden, shading, colormap, caxis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Plot a 3-D wireframe mesh with a surrounding curtain.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
pareto


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1786
 -- Function File: pareto (Y)
 -- Function File: pareto (Y, X)
 -- Function File: pareto (HAX, ...)
 -- Function File: H = pareto (...)
     Draw a Pareto chart.

     A Pareto chart is a bar graph that arranges information in such a
     way that priorities for process improvement can be established; It
     organizes and displays information to show the relative importance
     of data.  The chart is similar to the histogram or bar chart,
     except that the bars are arranged in decreasing magnitude from left
     to right along the x-axis.

     The fundamental idea (Pareto principle) behind the use of Pareto
     diagrams is that the majority of an effect is due to a small subset
     of the causes.  For quality improvement, the first few contributing
     causes (leftmost bars as presented on the diagram) to a problem
     usually account for the majority of the result.  Thus, targeting
     these "major causes" for elimination results in the most
     cost-effective improvement scheme.

     Typically only the magnitude data Y is present in which case X is
     taken to be the range '1 : length (Y)'.  If X is given it may be a
     string array, a cell array of strings, or a numerical vector.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a 2-element vector with a graphics
     handle for the created bar plot and a second handle for the created
     line plot.

     An example of the use of 'pareto' is

          Cheese = {"Cheddar", "Swiss", "Camembert", ...
                    "Munster", "Stilton", "Blue"};
          Sold = [105, 30, 70, 10, 15, 20];
          pareto (Sold, Cheese);

     See also: bar, barh, hist, pie, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Draw a Pareto chart.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
patch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2502
 -- Function File: patch ()
 -- Function File: patch (X, Y, C)
 -- Function File: patch (X, Y, Z, C)
 -- Function File: patch (FV)
 -- Function File: patch ("Faces", FACES, "Vertices", VERTS, ...)
 -- Function File: patch (..., PROP, VAL, ...)
 -- Function File: patch (HAX, ...)
 -- Function File: H = patch (...)
     Create patch object in the current axes with vertices at locations
     (X, Y) and of color C.

     If the vertices are matrices of size MxN then each polygon patch
     has M vertices and a total of N polygons will be created.  If some
     polygons do not have M vertices use NaN to represent "no vertex".
     If the Z input is present then 3-D patches will be created.

     The color argument C can take many forms.  To create polygons which
     all share a single color use a string value (e.g., "r" for red), a
     scalar value which is scaled by 'caxis' and indexed into the
     current colormap, or a 3-element RGB vector with the precise
     TrueColor.

     If C is a vector of length N then the ith polygon will have a color
     determined by scaling entry C(i) according to 'caxis' and then
     indexing into the current colormap.  More complicated coloring
     situations require directly manipulating patch property/value
     pairs.

     Instead of specifying polygons by matrices X and Y, it is possible
     to present a unique list of vertices and then a list of polygon
     faces created from those vertices.  In this case the "Vertices"
     matrix will be an Nx2 (2-D patch) or Nx3 (3-D path).  The MxN
     "Faces" matrix describes M polygons having N vertices--each row
     describes a single polygon and each column entry is an index into
     the "Vertices" matrix to identify a vertex.  The patch object can
     be created by directly passing the property/value pairs
     "Vertices"/VERTS, "Faces"/FACES as inputs.

     A third input form is to create a structure FV with the fields
     "vertices", "faces", and optionally "facevertexcdata".

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     patch object.

     Implementation Note: Patches are highly configurable objects.  To
     truly customize them requires setting patch properties directly.
     Useful patch properties are: "cdata", "edgecolor", "facecolor",
     "faces", "facevertexcdata".

     See also: fill, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Create patch object in the current axes with vertices at locations  (X, Y) and of color C.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
pcolor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1617
 -- Function File: pcolor (X, Y, C)
 -- Function File: pcolor (C)
 -- Function File: pcolor (HAX, ...)
 -- Function File: H = pcolor (...)
     Produce a 2-D density plot.

     A 'pcolor' plot draws rectangles with colors from the matrix C over
     the two-dimensional region represented by the matrices X and Y.  X
     and Y are the coordinates of the mesh's vertices and are typically
     the output of 'meshgrid'.  If X and Y are vectors, then a typical
     vertex is (X(j), Y(i), C(i,j)).  Thus, columns of C correspond to
     different X values and rows of C correspond to different Y values.

     The values in C are scaled to span the range of the current
     colormap.  Limits may be placed on the color axis by the command
     'caxis', or by setting the 'clim' property of the parent axis.

     The face color of each cell of the mesh is determined by
     interpolating the values of C for each of the cell's vertices;
     Contrast this with 'imagesc' which renders one cell for each
     element of C.

     'shading' modifies an attribute determining the manner by which the
     face color of each cell is interpolated from the values of C, and
     the visibility of the cells' edges.  By default the attribute is
     "faceted", which renders a single color for each cell's face with
     the edge visible.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     See also: caxis, shading, meshgrid, contour, imagesc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Produce a 2-D density plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
peaks


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1091
 -- Function File: peaks ()
 -- Function File: peaks (N)
 -- Function File: peaks (X, Y)
 -- Function File: Z = peaks (...)
 -- Function File: [X, Y, Z] = peaks (...)
     Plot a function with lots of local maxima and minima.

     The function has the form

     f(x,y) = 3*(1-x)^2*exp(-x^2 - (y+1)^2) ...
              - 10*(x/5 - x^3 - y^5)*exp(-x^2-y^2) ...
              - 1/3*exp(-(x+1)^2 - y^2)

     Called without a return argument, 'peaks' plots the surface of the
     above function using 'surf'.

     If N is a scalar, 'peaks' plots the value of the above function on
     an N-by-N mesh over the range [-3,3].  The default value for N is
     49.

     If N is a vector, then it represents the grid values over which to
     calculate the function.  If X and Y are specified then the function
     value is calculated over the specified grid of vertices.

     When called with output arguments, return the data for the function
     evaluated over the meshgrid.  This can subsequently be plotted with
     'surf (X, Y, Z)'.

     See also: sombrero, meshgrid, mesh, surf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Plot a function with lots of local maxima and minima.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
pie3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1282
 -- Function File: pie3 (X)
 -- Function File: pie3 (..., EXPLODE)
 -- Function File: pie3 (..., LABELS)
 -- Function File: pie3 (HAX, ...);
 -- Function File: H = pie3 (...);
     Plot a 3-D pie chart.

     Called with a single vector argument, produces a 3-D pie chart of
     the elements in X.  The size of the ith slice is the percentage
     that the element Xi represents of the total sum of X: 'pct = X(i) /
     sum (X)'.

     The optional input EXPLODE is a vector of the same length as X
     that, if non-zero, "explodes" the slice from the pie chart.

     The optional input LABELS is a cell array of strings of the same
     length as X specifying the label for each slice.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a list of graphics handles to the
     patch, surface, and text objects generating the plot.

     Note: If 'sum (X) <= 1' then the elements of X are interpreted as
     percentages directly and are not normalized by 'sum (x)'.
     Furthermore, if the sum is less than 1 then there will be a missing
     slice in the pie plot to represent the missing, unspecified
     percentage.

     See also: pie, bar, hist, rose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Plot a 3-D pie chart.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
pie


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1259
 -- Function File: pie (X)
 -- Function File: pie (..., EXPLODE)
 -- Function File: pie (..., LABELS)
 -- Function File: pie (HAX, ...);
 -- Function File: H = pie (...);
     Plot a 2-D pie chart.

     When called with a single vector argument, produce a pie chart of
     the elements in X.  The size of the ith slice is the percentage
     that the element Xi represents of the total sum of X: 'pct = X(i) /
     sum (X)'.

     The optional input EXPLODE is a vector of the same length as X
     that, if non-zero, "explodes" the slice from the pie chart.

     The optional input LABELS is a cell array of strings of the same
     length as X specifying the label for each slice.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a list of handles to the patch and
     text objects generating the plot.

     Note: If 'sum (X) <= 1' then the elements of X are interpreted as
     percentages directly and are not normalized by 'sum (x)'.
     Furthermore, if the sum is less than 1 then there will be a missing
     slice in the pie plot to represent the missing, unspecified
     percentage.

     See also: pie3, bar, hist, rose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Plot a 2-D pie chart.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
plot3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2153
 -- Function File: plot3 (X, Y, Z)
 -- Function File: plot3 (X, Y, Z, PROP, VALUE, ...)
 -- Function File: plot3 (X, Y, Z, FMT)
 -- Function File: plot3 (X, CPLX)
 -- Function File: plot3 (CPLX)
 -- Function File: plot3 (HAX, ...)
 -- Function File: H = plot3 (...)
     Produce 3-D plots.

     Many different combinations of arguments are possible.  The
     simplest form is

          plot3 (X, Y, Z)

     in which the arguments are taken to be the vertices of the points
     to be plotted in three dimensions.  If all arguments are vectors of
     the same length, then a single continuous line is drawn.  If all
     arguments are matrices, then each column of is treated as a
     separate line.  No attempt is made to transpose the arguments to
     make the number of rows match.

     If only two arguments are given, as

          plot3 (X, CPLX)

     the real and imaginary parts of the second argument are used as the
     Y and Z coordinates, respectively.

     If only one argument is given, as

          plot3 (CPLX)

     the real and imaginary parts of the argument are used as the Y and
     Z values, and they are plotted versus their index.

     Arguments may also be given in groups of three as

          plot3 (X1, Y1, Z1, X2, Y2, Z2, ...)

     in which each set of three arguments is treated as a separate line
     or set of lines in three dimensions.

     To plot multiple one- or two-argument groups, separate each group
     with an empty format string, as

          plot3 (X1, C1, "", C2, "", ...)

     Multiple property-value pairs may be specified which will affect
     the line objects drawn by 'plot3'.  If the FMT argument is supplied
     it will format the line objects in the same manner as 'plot'.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     plot.

     Example:

          z = [0:0.05:5];
          plot3 (cos (2*pi*z), sin (2*pi*z), z, ";helix;");
          plot3 (z, exp (2i*pi*z), ";complex sinusoid;");

     See also: ezplot3, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
Produce 3-D plots.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
plot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5120
 -- Function File: plot (Y)
 -- Function File: plot (X, Y)
 -- Function File: plot (X, Y, FMT)
 -- Function File: plot (..., PROPERTY, VALUE, ...)
 -- Function File: plot (X1, Y1, ..., XN, YN)
 -- Function File: plot (HAX, ...)
 -- Function File: H = plot (...)
     Produce 2-D plots.

     Many different combinations of arguments are possible.  The
     simplest form is

          plot (Y)

     where the argument is taken as the set of Y coordinates and the X
     coordinates are taken to be the range '1:numel (Y)'.

     If more than one argument is given, they are interpreted as

          plot (Y, PROPERTY, VALUE, ...)

     or

          plot (X, Y, PROPERTY, VALUE, ...)

     or

          plot (X, Y, FMT, ...)

     and so on.  Any number of argument sets may appear.  The X and Y
     values are interpreted as follows:

        * If a single data argument is supplied, it is taken as the set
          of Y coordinates and the X coordinates are taken to be the
          indices of the elements, starting with 1.

        * If X and Y are scalars, a single point is plotted.

        * 'squeeze()' is applied to arguments with more than two
          dimensions, but no more than two singleton dimensions.

        * If both arguments are vectors, the elements of Y are plotted
          versus the elements of X.

        * If X is a vector and Y is a matrix, then the columns (or rows)
          of Y are plotted versus X.  (using whichever combination
          matches, with columns tried first.)

        * If the X is a matrix and Y is a vector, Y is plotted versus
          the columns (or rows) of X.  (using whichever combination
          matches, with columns tried first.)

        * If both arguments are matrices, the columns of Y are plotted
          versus the columns of X.  In this case, both matrices must
          have the same number of rows and columns and no attempt is
          made to transpose the arguments to make the number of rows
          match.

     Multiple property-value pairs may be specified, but they must
     appear in pairs.  These arguments are applied to the line objects
     drawn by 'plot'.  Useful properties to modify are "linestyle",
     "linewidth", "color", "marker", "markersize", "markeredgecolor",
     "markerfacecolor".

     The FMT format argument can also be used to control the plot style.
     The format is composed of three parts: linestyle, markerstyle,
     color.  When a markerstyle is specified, but no linestyle, only the
     markers are plotted.  Similarly, if a linestyle is specified, but
     no markerstyle, then only lines are drawn.  If both are specified
     then lines and markers will be plotted.  If no FMT and no
     PROPERTY/VALUE pairs are given, then the default plot style is
     solid lines with no markers and the color determined by the
     "colororder" property of the current axes.

     Format arguments:

     linestyle

          '-'  Use solid lines (default).
          '--' Use dashed lines.
          ':'  Use dotted lines.
          '-.' Use dash-dotted lines.

     markerstyle

          '+'  crosshair
          'o'  circle
          '*'  star
          '.'  point
          'x'  cross
          's'  square
          'd'  diamond
          '^'  upward-facing triangle
          'v'  downward-facing triangle
          '>'  right-facing triangle
          '<'  left-facing triangle
          'p'  pentagram
          'h'  hexagram

     color

          'k'  blacK
          'r'  Red
          'g'  Green
          'b'  Blue
          'm'  Magenta
          'c'  Cyan
          'w'  White

     ";key;"
          Here "key" is the label to use for the plot legend.

     The FMT argument may also be used to assign legend keys.  To do so,
     include the desired label between semicolons after the formatting
     sequence described above, e.g., "+b;Key Title;".  Note that the
     last semicolon is required and Octave will generate an error if it
     is left out.

     Here are some plot examples:

          plot (x, y, "or", x, y2, x, y3, "m", x, y4, "+")

     This command will plot 'y' with red circles, 'y2' with solid lines,
     'y3' with solid magenta lines, and 'y4' with points displayed as
     '+'.

          plot (b, "*", "markersize", 10)

     This command will plot the data in the variable 'b', with points
     displayed as '*' and a marker size of 10.

          t = 0:0.1:6.3;
          plot (t, cos(t), "-;cos(t);", t, sin(t), "-b;sin(t);");

     This will plot the cosine and sine functions and label them
     accordingly in the legend.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a vector of graphics handles to the
     created line objects.

     To save a plot, in one of several image formats such as PostScript
     or PNG, use the 'print' command.

     See also: axis, box, grid, hold, legend, title, xlabel, ylabel,
     xlim, ylim, ezplot, errorbar, fplot, line, plot3, polar, loglog,
     semilogx, semilogy, subplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
Produce 2-D plots.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
plotmatrix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1469
 -- Function File: plotmatrix (X, Y)
 -- Function File: plotmatrix (X)
 -- Function File: plotmatrix (..., STYLE)
 -- Function File: plotmatrix (HAX, ...)
 -- Function File: [H, AX, BIGAX, P, PAX] = plotmatrix (...)
     Scatter plot of the columns of one matrix against another.

     Given the arguments X and Y, that have a matching number of rows,
     'plotmatrix' plots a set of axes corresponding to

          plot (X(:, i), Y(:, j))

     Given a single argument X this is equivalent to

          plotmatrix (X, X)

     except that the diagonal of the set of axes will be replaced with
     the histogram 'hist (X(:, i))'.

     The marker to use can be changed with the STYLE argument, that is a
     string defining a marker in the same manner as the 'plot' command.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H provides handles to the individual
     graphics objects in the scatter plots, whereas AX returns the
     handles to the scatter plot axis objects.  BIGAX is a hidden axis
     object that surrounds the other axes, such that the commands
     'xlabel', 'title', etc., will be associated with this hidden axis.
     Finally, P returns the graphics objects associated with the
     histogram and PAX the corresponding axes objects.

     Example:

          plotmatrix (randn (100, 3), "g+")

     See also: scatter, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Scatter plot of the columns of one matrix against another.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
plotyy


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1316
 -- Function File: plotyy (X1, Y1, X2, Y2)
 -- Function File: plotyy (..., FUN)
 -- Function File: plotyy (..., FUN1, FUN2)
 -- Function File: plotyy (HAX, ...)
 -- Function File: [AX, H1, H2] = plotyy (...)
     Plot two sets of data with independent y-axes.

     The arguments X1 and Y1 define the arguments for the first plot and
     X1 and Y2 for the second.

     By default the arguments are evaluated with 'feval (@plot, X, Y)'.
     However the type of plot can be modified with the FUN argument, in
     which case the plots are generated by 'feval (FUN, X, Y)'.  FUN can
     be a function handle, an inline function, or a string of a function
     name.

     The function to use for each of the plots can be independently
     defined with FUN1 and FUN2.

     If the first argument HAX is an axes handle, then it defines the
     principal axis in which to plot the X1 and Y1 data.

     The return value AX is a vector with the axis handles of the two y
     axes.  H1 and H2 are handles to the objects generated by the plot
     commands.

          x = 0:0.1:2*pi;
          y1 = sin (x);
          y2 = exp (x - 1);
          ax = plotyy (x, y1, x - 1, y2, @plot, @semilogy);
          xlabel ("X");
          ylabel (ax(1), "Axis 1");
          ylabel (ax(2), "Axis 2");

     See also: plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Plot two sets of data with independent y-axes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
polar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 751
 -- Function File: polar (THETA, RHO)
 -- Function File: polar (THETA, RHO, FMT)
 -- Function File: polar (CPLX)
 -- Function File: polar (CPLX, FMT)
 -- Function File: polar (HAX, ...)
 -- Function File: H = polar (...)
     Create a 2-D plot from polar coordinates THETA and RHO.

     If a single complex input CPLX is given then the real part is used
     for THETA and the imaginary part is used for RHO.

     The optional argument FMT specifies the line format in the same way
     as 'plot'.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     plot.

     See also: rose, compass, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Create a 2-D plot from polar coordinates THETA and RHO.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
quiver3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1668
 -- Function File: quiver3 (U, V, W)
 -- Function File: quiver3 (X, Y, Z, U, V, W)
 -- Function File: quiver3 (..., S)
 -- Function File: quiver3 (..., STYLE)
 -- Function File: quiver3 (..., "filled")
 -- Function File: quiver3 (HAX, ...)
 -- Function File: H = quiver3 (...)

     Plot the (U, V, W) components of a vector field in an (X, Y, Z)
     meshgrid.  If the grid is uniform, you can specify X, Y, and Z as
     vectors.

     If X, Y, and Z are undefined they are assumed to be '(1:M, 1:N,
     1:P)' where '[M, N] = size (U)' and 'P = max (size (W))'.

     The variable S is a scalar defining a scaling factor to use for the
     arrows of the field relative to the mesh spacing.  A value of 0
     disables all scaling.  The default value is 0.9.

     The style to use for the plot can be defined with a line style
     STYLE of the same format as the 'plot' command.  If a marker is
     specified then markers at the grid points of the vectors are drawn
     rather than arrows.  If the argument "filled" is given then the
     markers are filled.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to a quiver
     object.  A quiver object regroups the components of the quiver plot
     (body, arrow, and marker), and allows them to be changed together.

          [x, y, z] = peaks (25);
          surf (x, y, z);
          hold on;
          [u, v, w] = surfnorm (x, y, z / 10);
          h = quiver3 (x, y, z, u, v, w);
          set (h, "maxheadsize", 0.33);

     See also: quiver, compass, feather, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Plot the (U, V, W) components of a vector field in an (X, Y, Z)  meshgrid.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
quiver


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1551
 -- Function File: quiver (U, V)
 -- Function File: quiver (X, Y, U, V)
 -- Function File: quiver (..., S)
 -- Function File: quiver (..., STYLE)
 -- Function File: quiver (..., "filled")
 -- Function File: quiver (HAX, ...)
 -- Function File: H = quiver (...)

     Plot the (U, V) components of a vector field in an (X, Y) meshgrid.
     If the grid is uniform, you can specify X and Y as vectors.

     If X and Y are undefined they are assumed to be '(1:M, 1:N)' where
     '[M, N] = size (U)'.

     The variable S is a scalar defining a scaling factor to use for the
     arrows of the field relative to the mesh spacing.  A value of 0
     disables all scaling.  The default value is 0.9.

     The style to use for the plot can be defined with a line style
     STYLE of the same format as the 'plot' command.  If a marker is
     specified then markers at the grid points of the vectors are drawn
     rather than arrows.  If the argument "filled" is given then the
     markers are filled.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to a quiver
     object.  A quiver object regroups the components of the quiver plot
     (body, arrow, and marker), and allows them to be changed together.

     Example:

          [x, y] = meshgrid (1:2:20);
          h = quiver (x, y, sin (2*pi*x/10), sin (2*pi*y/10));
          set (h, "maxheadsize", 0.33);

     See also: quiver3, compass, feather, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Plot the (U, V) components of a vector field in an (X, Y) meshgrid.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
rectangle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1583
 -- Function File: rectangle ()
 -- Function File: rectangle (..., "Position", POS)
 -- Function File: rectangle (..., "Curvature", CURV)
 -- Function File: rectangle (..., "EdgeColor", EC)
 -- Function File: rectangle (..., "FaceColor", FC)
 -- Function File: rectangle (HAX, ...)
 -- Function File: H = rectangle (...)
     Draw a rectangular patch defined by POS and CURV.

     The variable 'POS(1:2)' defines the lower left-hand corner of the
     patch and 'POS(3:4)' defines its width and height.  By default, the
     value of POS is '[0, 0, 1, 1]'.

     The variable CURV defines the curvature of the sides of the
     rectangle and may be a scalar or two-element vector with values
     between 0 and 1.  A value of 0 represents no curvature of the side,
     whereas a value of 1 means that the side is entirely curved into
     the arc of a circle.  If CURV is a two-element vector, then the
     first element is the curvature along the x-axis of the patch and
     the second along y-axis.

     If CURV is a scalar, it represents the curvature of the shorter of
     the two sides of the rectangle and the curvature of the other side
     is defined by

          min (pos(1:2)) / max (pos(1:2)) * curv

     Additional property/value pairs are passed to the underlying patch
     command.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     rectangle object.

See also: patch, line, cylinder, ellipsoid, sphere.  


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Draw a rectangular patch defined by POS and CURV.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ribbon


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 702
 -- Function File: ribbon (Y)
 -- Function File: ribbon (X, Y)
 -- Function File: ribbon (X, Y, WIDTH)
 -- Function File: ribbon (HAX, ...)
 -- Function File: H = ribbon (...)
     Plot a ribbon plot for the columns of Y vs.  X.

     The optional parameter WIDTH specifies the width of a single ribbon
     (default is 0.75).  If X is omitted, a vector containing the row
     numbers is assumed ('1:rows (Y)').

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a vector of graphics handles to the
     surface objects representing each ribbon.

     See also: surface, waterfall.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Plot a ribbon plot for the columns of Y vs.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
rose


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1179
 -- Function File: rose (TH)
 -- Function File: rose (TH, NBINS)
 -- Function File: rose (TH, BINS)
 -- Function File: rose (HAX, ...)
 -- Function File: H = rose (...)
 -- Function File: [THOUT ROUT] = rose (...)
     Plot an angular histogram.

     With one vector argument, TH, plot the histogram with 20 angular
     bins.  If TH is a matrix then each column of TH produces a separate
     histogram.

     If NBINS is given and is a scalar, then the histogram is produced
     with NBIN bins.  If BINS is a vector, then the center of each bin
     is defined by the values of BINS and the number of bins is given by
     the number of elements in BINS.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a vector of graphics handles to the
     line objects representing each histogram.

     If two output arguments are requested then no plot is made and the
     polar vectors necessary to plot the histogram are returned instead.

          [th, r] = rose ([2*randn(1e5,1), pi + 2*randn(1e5,1)]);
          polar (th, r);

     See also: hist, polar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Plot an angular histogram.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
scatter3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1756
 -- Function File: scatter3 (X, Y, Z)
 -- Function File: scatter3 (X, Y, Z, S)
 -- Function File: scatter3 (X, Y, Z, S, C)
 -- Function File: scatter3 (..., STYLE)
 -- Function File: scatter3 (..., "filled")
 -- Function File: scatter3 (..., PROP, VAL)
 -- Function File: scatter3 (HAX, ...)
 -- Function File: H = scatter3 (...)
     Draw a 3-D scatter plot.

     A marker is plotted at each point defined by the coordinates in the
     vectors X, Y, and Z.

     The size of the markers is determined by S, which can be a scalar
     or a vector of the same length as X, Y, and Z.  If S is not given,
     or is an empty matrix, then a default value of 8 points is used.

     The color of the markers is determined by C, which can be a string
     defining a fixed color; a 3-element vector giving the red, green,
     and blue components of the color; a vector of the same length as X
     that gives a scaled index into the current colormap; or an Nx3
     matrix defining the RGB color of each marker individually.

     The marker to use can be changed with the STYLE argument, that is a
     string defining a marker in the same manner as the 'plot' command.
     If no marker is specified it defaults to "o" or circles.  If the
     argument "filled" is given then the markers are filled.

     Additional property/value pairs are passed directly to the
     underlying patch object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the hggroup
     object representing the points.

          [x, y, z] = peaks (20);
          scatter3 (x(:), y(:), z(:), [], z(:));

     See also: scatter, patch, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Draw a 3-D scatter plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
scatter


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1761
 -- Function File: scatter (X, Y)
 -- Function File: scatter (X, Y, S)
 -- Function File: scatter (X, Y, S, C)
 -- Function File: scatter (..., STYLE)
 -- Function File: scatter (..., "filled")
 -- Function File: scatter (..., PROP, VAL, ...)
 -- Function File: scatter (HAX, ...)
 -- Function File: H = scatter (...)
     Draw a 2-D scatter plot.

     A marker is plotted at each point defined by the coordinates in the
     vectors X and Y.

     The size of the markers is determined by S, which can be a scalar
     or a vector of the same length as X and Y.  If S is not given, or
     is an empty matrix, then a default value of 8 points is used.

     The color of the markers is determined by C, which can be a string
     defining a fixed color; a 3-element vector giving the red, green,
     and blue components of the color; a vector of the same length as X
     that gives a scaled index into the current colormap; or an Nx3
     matrix defining the RGB color of each marker individually.

     The marker to use can be changed with the STYLE argument, that is a
     string defining a marker in the same manner as the 'plot' command.
     If no marker is specified it defaults to "o" or circles.  If the
     argument "filled" is given then the markers are filled.

     Additional property/value pairs are passed directly to the
     underlying patch object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     patch object.

     Example:

          x = randn (100, 1);
          y = randn (100, 1);
          scatter (x, y, [], sqrt (x.^2 + y.^2));

     See also: scatter3, patch, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Draw a 2-D scatter plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
semilogxerr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1132
 -- Function File: semilogxerr (Y, EY)
 -- Function File: semilogxerr (Y, ..., FMT)
 -- Function File: semilogxerr (X, Y, EY)
 -- Function File: semilogxerr (X, Y, ERR, FMT)
 -- Function File: semilogxerr (X, Y, LERR, UERR, FMT)
 -- Function File: semilogxerr (X, Y, EX, EY, FMT)
 -- Function File: semilogxerr (X, Y, LX, UX, LY, UY, FMT)
 -- Function File: semilogxerr (X1, Y1, ..., FMT, XN, YN, ...)
 -- Function File: semilogxerr (HAX, ...)
 -- Function File: H = semilogxerr (...)
     Produce 2-D plots using a logarithmic scale for the x-axis and
     errorbars at each data point.

     Many different combinations of arguments are possible.  The most
     common form is

          semilogxerr (X, Y, EY, FMT)

     which produces a semi-logarithmic plot of Y versus X with errors in
     the Y-scale defined by EY and the plot format defined by FMT.
     *Note errorbar: XREFerrorbar, for available formats and additional
     information.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     See also: errorbar, semilogyerr, loglogerr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Produce 2-D plots using a logarithmic scale for the x-axis and  errorbars at each data point.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
semilogx


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 668
 -- Function File: semilogx (Y)
 -- Function File: semilogx (X, Y)
 -- Function File: semilogx (X, Y, PROPERTY, VALUE, ...)
 -- Function File: semilogx (X, Y, FMT)
 -- Function File: semilogx (HAX, ...)
 -- Function File: H = semilogx (...)
     Produce a 2-D plot using a logarithmic scale for the x-axis.

     See the documentation of 'plot' for a description of the arguments
     that 'semilogx' will accept.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     plot.

     See also: plot, semilogy, loglog.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Produce a 2-D plot using a logarithmic scale for the x-axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
semilogyerr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1132
 -- Function File: semilogyerr (Y, EY)
 -- Function File: semilogyerr (Y, ..., FMT)
 -- Function File: semilogyerr (X, Y, EY)
 -- Function File: semilogyerr (X, Y, ERR, FMT)
 -- Function File: semilogyerr (X, Y, LERR, UERR, FMT)
 -- Function File: semilogyerr (X, Y, EX, EY, FMT)
 -- Function File: semilogyerr (X, Y, LX, UX, LY, UY, FMT)
 -- Function File: semilogyerr (X1, Y1, ..., FMT, XN, YN, ...)
 -- Function File: semilogyerr (HAX, ...)
 -- Function File: H = semilogyerr (...)
     Produce 2-D plots using a logarithmic scale for the y-axis and
     errorbars at each data point.

     Many different combinations of arguments are possible.  The most
     common form is

          semilogyerr (X, Y, EY, FMT)

     which produces a semi-logarithmic plot of Y versus X with errors in
     the Y-scale defined by EY and the plot format defined by FMT.
     *Note errorbar: XREFerrorbar, for available formats and additional
     information.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     See also: errorbar, semilogxerr, loglogerr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Produce 2-D plots using a logarithmic scale for the y-axis and  errorbars at each data point.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
semilogy


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 666
 -- Function File: semilogy (Y)
 -- Function File: semilogy (X, Y)
 -- Function File: semilogy (X, Y, PROPERTY, VALUE, ...)
 -- Function File: semilogy (X, Y, FMT)
 -- Function File: semilogy (H, ...)
 -- Function File: H = semilogy (...)
     Produce a 2-D plot using a logarithmic scale for the y-axis.

     See the documentation of 'plot' for a description of the arguments
     that 'semilogy' will accept.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     plot.

     See also: plot, semilogx, loglog.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Produce a 2-D plot using a logarithmic scale for the y-axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
shrinkfaces


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1471
 -- Function File: shrinkfaces (P, SF)
 -- Function File: NFV = shrinkfaces (P, SF)
 -- Function File: NFV = shrinkfaces (FV, SF)
 -- Function File: NFV = shrinkfaces (F, V, SF)
 -- Function File: [NF, NV] = shrinkfaces (...)

     Reduce the faces area for a given patch, structure or explicit
     faces and points matrices by a scale factor SF.  The structure FV
     must contain the fields "faces" and "vertices".  If the factor SF
     is omitted then a default of 0.3 is used.

     Given a patch handle as the first input argument and no output
     parameters, perform the shrinking of the patch faces in place and
     redraw the patch.

     If called with one output argument, return a structure with fields
     "faces", "vertices", and "facevertexcdata" containing the data
     after shrinking which can then directly be used as an input
     argument for the 'patch' function.

     Performing the shrinking on faces which are not convex can lead to
     undesired results.

     For example,

          [phi r] = meshgrid (linspace (0, 1.5*pi, 16), linspace (1, 2, 4));
          tri = delaunay (phi(:), r(:));
          v = [r(:).*sin(phi(:)) r(:).*cos(phi(:))];
          clf ()
          p = patch ("Faces", tri, "Vertices", v, "FaceColor", "none");
          fv = shrinkfaces (p);
          patch (fv)
          axis equal
          grid on

     draws a triangulated 3/4 circle and the corresponding shrunken
     version.

     See also: patch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
Reduce the faces area for a given patch, structure or explicit  faces and points matrices by a scale factor SF.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
slice


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1970
 -- Function File: slice (X, Y, Z, V, SX, SY, SZ)
 -- Function File: slice (X, Y, Z, V, XI, YI, ZI)
 -- Function File: slice (V, SX, SY, SZ)
 -- Function File: slice (V, XI, YI, ZI)
 -- Function File: slice (..., METHOD)
 -- Function File: slice (HAX, ...)
 -- Function File: H = slice (...)
     Plot slices of 3-D data/scalar fields.

     Each element of the 3-dimensional array V represents a scalar value
     at a location given by the parameters X, Y, and Z.  The parameters
     X, X, and Z are either 3-dimensional arrays of the same size as the
     array V in the "meshgrid" format or vectors.  The parameters XI,
     etc.  respect a similar format to X, etc., and they represent the
     points at which the array VI is interpolated using interp3.  The
     vectors SX, SY, and SZ contain points of orthogonal slices of the
     respective axes.

     If X, Y, Z are omitted, they are assumed to be 'x = 1:size (V, 2)',
     'y = 1:size (V, 1)' and 'z = 1:size (V, 3)'.

     METHOD is one of:

     "nearest"
          Return the nearest neighbor.

     "linear"
          Linear interpolation from nearest neighbors.

     "cubic"
          Cubic interpolation from four nearest neighbors (not
          implemented yet).

     "spline"
          Cubic spline interpolation--smooth first and second
          derivatives throughout the curve.

     The default method is "linear".

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     Examples:

          [x, y, z] = meshgrid (linspace (-8, 8, 32));
          v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
          slice (x, y, z, v, [], 0, []);

          [xi, yi] = meshgrid (linspace (-7, 7));
          zi = xi + yi;
          slice (x, y, z, v, xi, yi, zi);

     See also: interp3, surface, pcolor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Plot slices of 3-D data/scalar fields.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
sombrero


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 731
 -- Function File: sombrero ()
 -- Function File: sombrero (N)
 -- Function File: Z = sombrero (...)
 -- Function File: [X, Y, Z] = sombrero (...)
     Plot the familiar 3-D sombrero function.

     The function plotted is

          z = sin (sqrt (x^2 + y^2)) / (sqrt (x^2 + y^2))

     Called without a return argument, 'sombrero' plots the surface of
     the above function over the meshgrid [-8,8] using 'surf'.

     If N is a scalar the plot is made with N grid lines.  The default
     value for N is 41.

     When called with output arguments, return the data for the function
     evaluated over the meshgrid.  This can subsequently be plotted with
     'surf (X, Y, Z)'.

     See also: peaks, meshgrid, mesh, surf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Plot the familiar 3-D sombrero function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
sphere


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 774
 -- Function File: sphere ()
 -- Function File: sphere (N)
 -- Function File: sphere (HAX, ...)
 -- Function File: [X, Y, Z] = sphere (...)
     Plot a 3-D unit sphere.

     The optional input N determines the number of faces around the the
     circumference of the sphere.  The default value is 20.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     If outputs are requested 'sphere' returns three matrices in
     'meshgrid' format such that 'surf (X, Y, Z)' generates a unit
     sphere.

     Example:

          [x, y, z] = sphere (40);
          surf (3*x, 3*y, 3*z);
          axis equal;
          title ("sphere of radius 3");

     See also: cylinder, ellipsoid, rectangle.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Plot a 3-D unit sphere.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
stairs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1208
 -- Function File: stairs (Y)
 -- Function File: stairs (X, Y)
 -- Function File: stairs (..., STYLE)
 -- Function File: stairs (..., PROP, VAL, ...)
 -- Function File: stairs (HAX, ...)
 -- Function File: H = stairs (...)
 -- Function File: [XSTEP, YSTEP] = stairs (...)
     Produce a stairstep plot.

     The arguments X and Y may be vectors or matrices.  If only one
     argument is given, it is taken as a vector of Y values and the X
     coordinates are taken to be the indices of the elements.

     The style to use for the plot can be defined with a line style
     STYLE of the same format as the 'plot' command.

     Multiple property/value pairs may be specified, but they must
     appear in pairs.

     If the first argument HAX is an axis handle, then plot into this
     axis, rather than the current axis handle returned by 'gca'.

     If one output argument is requested, return a graphics handle to
     the created plot.  If two output arguments are specified, the data
     are generated but not plotted.  For example,

          stairs (x, y);

     and

          [xs, ys] = stairs (x, y);
          plot (xs, ys);

     are equivalent.

     See also: bar, hist, plot, stem.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Produce a stairstep plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
stem3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1399
 -- Function File: stem3 (X, Y, Z)
 -- Function File: stem3 (..., LINESPEC)
 -- Function File: stem3 (..., "filled")
 -- Function File: stem3 (..., PROP, VAL, ...)
 -- Function File: stem3 (HAX, ...)
 -- Function File: H = stem3 (...)
     Plot a 3-D stem graph.

     Stems are drawn from the height Z to the location in the x-y plane
     determined by X and Y.  The default color is "b" (blue), the
     default line style is "-", and the default marker is "o".

     The line style can be altered by the 'linespec' argument in the
     same manner as the 'plot' command.  If the "filled" argument is
     present the markers at the top of the stems will be filled in.

     Optional property/value pairs may be specified to control the
     appearance of the plot.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a handle to the "stem series"
     hggroup containing the line and marker objects used for the plot.
     *Note stem: XREFstem, for a description of the "stem series"
     object.

     Example:

          theta = 0:0.2:6;
          stem3 (cos (theta), sin (theta), theta);

     plots 31 stems with heights from 0 to 6 lying on a circle.

     Implementation Note: Color definitions with RGB-triples are not
     valid.

     See also: stem, bar, hist, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Plot a 3-D stem graph.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
stemleaf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2548
 -- Function File: stemleaf (X, CAPTION)
 -- Function File: stemleaf (X, CAPTION, STEM_SZ)
 -- Function File: PLOTSTR = stemleaf (...)
     Compute and display a stem and leaf plot of the vector X.

     The input X should be a vector of integers.  Any non-integer values
     will be converted to integer by 'X = fix (X)'.  By default each
     element of X will be plotted with the last digit of the element as
     a leaf value and the remaining digits as the stem.  For example,
     123 will be plotted with the stem '12' and the leaf '3'.  The
     second argument, CAPTION, should be a character array which
     provides a description of the data.  It is included as a heading
     for the output.

     The optional input STEM_SZ sets the width of each stem.  The stem
     width is determined by '10^(STEM_SZ + 1)'.  The default stem width
     is 10.

     The output of 'stemleaf' is composed of two parts: a "Fenced Letter
     Display," followed by the stem-and-leaf plot itself.  The Fenced
     Letter Display is described in 'Exploratory Data Analysis'.
     Briefly, the entries are as shown:


                  Fenced Letter Display
          #% nx|___________________     nx = numel (x)
          M% mi|       md         |     mi median index, md median
          H% hi|hl              hu| hs  hi lower hinge index, hl,hu hinges,
          1    |x(1)         x(nx)|     hs h_spreadx(1), x(nx) first
                     _______            and last data value.
               ______|step |_______     step 1.5*h_spread
              f|ifl            ifh|     inner fence, lower and higher
               |nfl            nfh|     no.\ of data points within fences
              F|ofl            ofh|     outer fence, lower and higher
               |nFl            nFh|     no.\ of data points outside outer
                                        fences

     The stem-and-leaf plot shows on each line the stem value followed
     by the string made up of the leaf digits.  If the STEM_SZ is not 1
     the successive leaf values are separated by ",".

     With no return argument, the plot is immediately displayed.  If an
     output argument is provided, the plot is returned as an array of
     strings.

     The leaf digits are not sorted.  If sorted leaf values are desired,
     use 'XS = sort (X)' before calling 'stemleaf (XS)'.

     The stem and leaf plot and associated displays are described in:
     Ch.  3, 'Exploratory Data Analysis' by J. W. Tukey, Addison-Wesley,
     1977.

     See also: hist, printd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Compute and display a stem and leaf plot of the vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
stem


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2903
 -- Function File: stem (Y)
 -- Function File: stem (X, Y)
 -- Function File: stem (..., LINESPEC)
 -- Function File: stem (..., "filled")
 -- Function File: stem (..., PROP, VAL, ...)
 -- Function File: stem (HAX, ...)
 -- Function File: H = stem (...)
     Plot a 2-D stem graph.

     If only one argument is given, it is taken as the y-values and the
     x-coordinates are taken from the indices of the elements.

     If Y is a matrix, then each column of the matrix is plotted as a
     separate stem graph.  In this case X can either be a vector, the
     same length as the number of rows in Y, or it can be a matrix of
     the same size as Y.

     The default color is "b" (blue), the default line style is "-", and
     the default marker is "o".  The line style can be altered by the
     'linespec' argument in the same manner as the 'plot' command.  If
     the "filled" argument is present the markers at the top of the
     stems will be filled in.  For example,

          x = 1:10;
          y = 2*x;
          stem (x, y, "r");

     plots 10 stems with heights from 2 to 20 in red;

     Optional property/value pairs may be specified to control the
     appearance of the plot.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a handle to a "stem series" hggroup.
     The single hggroup handle has all of the graphical elements
     comprising the plot as its children; This allows the properties of
     multiple graphics objects to be changed by modifying just a single
     property of the "stem series" hggroup.

     For example,

          x = [0:10]';
          y = [sin(x), cos(x)]
          h = stem (x, y);
          set (h(2), "color", "g");
          set (h(1), "basevalue", -1)

     changes the color of the second "stem series" and moves the base
     line of the first.

     Stem Series Properties

     linestyle
          The linestyle of the stem.  (Default: "-")

     linewidth
          The width of the stem.  (Default: 0.5)

     color
          The color of the stem, and if not separately specified, the
          marker.  (Default: "b" [blue])

     marker
          The marker symbol to use at the top of each stem.  (Default:
          "o")

     markeredgecolor
          The edge color of the marker.  (Default: "color" property)

     markerfacecolor
          The color to use for "filling" the marker.  (Default: "none"
          [unfilled])

     markersize
          The size of the marker.  (Default: 6)

     baseline
          The handle of the line object which implements the baseline.
          Use 'set' with the returned handle to change graphic
          properties of the baseline.

     basevalue
          The y-value where the baseline is drawn.  (Default: 0)

     See also: stem3, bar, hist, plot, stairs.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Plot a 2-D stem graph.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
surface


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1066
 -- Function File: surface (X, Y, Z, C)
 -- Function File: surface (X, Y, Z)
 -- Function File: surface (Z, C)
 -- Function File: surface (Z)
 -- Function File: surface (..., PROP, VAL, ...)
 -- Function File: surface (HAX, ...)
 -- Function File: H = surface (...)
     Create a surface graphic object given matrices X and Y from
     'meshgrid' and a matrix of values Z corresponding to the X and Y
     coordinates of the surface.

     If X and Y are vectors, then a typical vertex is (X(j), Y(i),
     Z(i,j)).  Thus, columns of Z correspond to different X values and
     rows of Z correspond to different Y values.  If only a single input
     Z is given then X is taken to be '1:rows (Z)' and Y is '1:columns
     (Z)'.

     Any property/value input pairs are assigned to the surface object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     See also: surf, mesh, patch, line.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 154
Create a surface graphic object given matrices X and Y from  'meshgrid' and a matrix of values Z corresponding to the X and Y  coordinates of the surface.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
surfc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1675
 -- Function File: surfc (X, Y, Z)
 -- Function File: surfc (Z)
 -- Function File: surfc (..., C)
 -- Function File: surfc (..., PROP, VAL, ...)
 -- Function File: surfc (HAX, ...)
 -- Function File: H = surfc (...)
     Plot a 3-D surface mesh with underlying contour lines.

     The surface mesh is plotted using shaded rectangles.  The vertices
     of the rectangles [X, Y] are typically the output of 'meshgrid'.
     over a 2-D rectangular region in the x-y plane.  Z determines the
     height above the plane of each vertex.  If only a single Z matrix
     is given, then it is plotted over the meshgrid 'X = 1:columns (Z),
     Y = 1:rows (Z)'.  Thus, columns of Z correspond to different X
     values and rows of Z correspond to different Y values.

     The color of the surface is computed by linearly scaling the Z
     values to fit the range of the current colormap.  Use 'caxis'
     and/or change the colormap to control the appearance.

     Optionally, the color of the surface can be specified independently
     of Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying
     surface object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     Note: The exact appearance of the surface can be controlled with
     the 'shading' command or by using 'set' to control surface object
     properties.

     See also: ezsurfc, surf, surfl, surfnorm, trisurf, contour, mesh,
     surface, meshgrid, hidden, shading, colormap, caxis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Plot a 3-D surface mesh with underlying contour lines.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
surfl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2090
 -- Function File: surfl (Z)
 -- Function File: surfl (X, Y, Z)
 -- Function File: surfl (..., LSRC)
 -- Function File: surfl (X, Y, Z, LSRC, P)
 -- Function File: surfl (..., "cdata")
 -- Function File: surfl (..., "light")
 -- Function File: surfl (HAX, ...)
 -- Function File: H = surfl (...)

     Plot a 3-D surface using shading based on various lighting models.

     The surface mesh is plotted using shaded rectangles.  The vertices
     of the rectangles [X, Y] are typically the output of 'meshgrid'.
     over a 2-D rectangular region in the x-y plane.  Z determines the
     height above the plane of each vertex.  If only a single Z matrix
     is given, then it is plotted over the meshgrid 'X = 1:columns (Z),
     Y = 1:rows (Z)'.  Thus, columns of Z correspond to different X
     values and rows of Z correspond to different Y values.

     The default lighting mode "cdata", changes the cdata property of
     the surface object to give the impression of a lighted surface.
     *Warning:* The alternative mode "light" mode which creates a light
     object to illuminate the surface is not implemented (yet).

     The light source location can be specified using LSRC.  It can be
     given as a 2-element vector [azimuth, elevation] in degrees, or as
     a 3-element vector [lx, ly, lz].  The default value is rotated 45
     degrees counterclockwise to the current view.

     The material properties of the surface can specified using a
     4-element vector P = [AM D SP EXP] which defaults to P = [0.55 0.6
     0.4 10].

     "AM" strength of ambient light

     "D" strength of diffuse reflection

     "SP" strength of specular reflection

     "EXP" specular exponent

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     Example:

          colormap (bone (64));
          surfl (peaks);
          shading interp;

     See also: diffuse, specular, surf, shading, colormap, caxis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Plot a 3-D surface using shading based on various lighting models.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
surf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1639
 -- Function File: surf (X, Y, Z)
 -- Function File: surf (Z)
 -- Function File: surf (..., C)
 -- Function File: surf (..., PROP, VAL, ...)
 -- Function File: surf (HAX, ...)
 -- Function File: H = surf (...)
     Plot a 3-D surface mesh.

     The surface mesh is plotted using shaded rectangles.  The vertices
     of the rectangles [X, Y] are typically the output of 'meshgrid'.
     over a 2-D rectangular region in the x-y plane.  Z determines the
     height above the plane of each vertex.  If only a single Z matrix
     is given, then it is plotted over the meshgrid 'X = 1:columns (Z),
     Y = 1:rows (Z)'.  Thus, columns of Z correspond to different X
     values and rows of Z correspond to different Y values.

     The color of the surface is computed by linearly scaling the Z
     values to fit the range of the current colormap.  Use 'caxis'
     and/or change the colormap to control the appearance.

     Optionally, the color of the surface can be specified independently
     of Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying
     surface object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     Note: The exact appearance of the surface can be controlled with
     the 'shading' command or by using 'set' to control surface object
     properties.

     See also: ezsurf, surfc, surfl, surfnorm, trisurf, contour, mesh,
     surface, meshgrid, hidden, shading, colormap, caxis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Plot a 3-D surface mesh.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
surfnorm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1139
 -- Function File: surfnorm (X, Y, Z)
 -- Function File: surfnorm (Z)
 -- Function File: [NX, NY, NZ] = surfnorm (...)
 -- Function File: surfnorm (H, ...)
     Find the vectors normal to a meshgridded surface.  The meshed
     gridded surface is defined by X, Y, and Z.  If X and Y are not
     defined, then it is assumed that they are given by

          [X, Y] = meshgrid (1:rows (Z),
                             1:columns (Z));

     If no return arguments are requested, a surface plot with the
     normal vectors to the surface is plotted.  Otherwise the components
     of the normal vectors at the mesh gridded points are returned in
     NX, NY, and NZ.

     The normal vectors are calculated by taking the cross product of
     the diagonals of each of the quadrilaterals in the meshgrid to find
     the normal vectors of the centers of these quadrilaterals.  The
     four nearest normal vectors to the meshgrid points are then
     averaged to obtain the normal to the surface at the meshgridded
     points.

     An example of the use of 'surfnorm' is

          surfnorm (peaks (25));

     See also: surf, quiver3.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Find the vectors normal to a meshgridded surface.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
tetramesh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1371
 -- Function File: tetramesh (T, X)
 -- Function File: tetramesh (T, X, C)
 -- Function File: tetramesh (..., PROPERTY, VAL, ...)
 -- Function File: H = tetramesh (...)
     Display the tetrahedrons defined in the m-by-4 matrix T as 3-D
     patches.

     T is typically the output of a Delaunay triangulation of a 3-D set
     of points.  Every row of T contains four indices into the n-by-3
     matrix X of the vertices of a tetrahedron.  Every row in X
     represents one point in 3-D space.

     The vector C specifies the color of each tetrahedron as an index
     into the current colormap.  The default value is 1:m where m is the
     number of tetrahedrons; the indices are scaled to map to the full
     range of the colormap.  If there are more tetrahedrons than colors
     in the colormap then the values in C are cyclically repeated.

     Calling 'tetramesh (..., "property", "value", ...)' passes all
     property/value pairs directly to the patch function as additional
     arguments.

     The optional return value H is a vector of patch handles where each
     handle represents one tetrahedron in the order given by T.  A
     typical use case for H is to turn the respective patch "visible"
     property "on" or "off".

     Type 'demo tetramesh' to see examples on using 'tetramesh'.

     See also: trimesh, delaunay3, delaunayn, patch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Display the tetrahedrons defined in the m-by-4 matrix T as 3-D  patches.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
trimesh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1427
 -- Function File: trimesh (TRI, X, Y, Z, C)
 -- Function File: trimesh (TRI, X, Y, Z)
 -- Function File: trimesh (TRI, X, Y)
 -- Function File: trimesh (..., PROP, VAL, ...)
 -- Function File: H = trimesh (...)
     Plot a 3-D triangular wireframe mesh.

     In contrast to 'mesh', which plots a mesh using rectangles,
     'trimesh' plots the mesh using triangles.

     TRI is typically the output of a Delaunay triangulation over the
     grid of X, Y.  Every row of TRI represents one triangle and
     contains three indices into [X, Y] which are the vertices of the
     triangles in the x-y plane.  Z determines the height above the
     plane of each vertex.  If no Z input is given then the triangles
     are plotted as a 2-D figure.

     The color of the trimesh is computed by linearly scaling the Z
     values to fit the range of the current colormap.  Use 'caxis'
     and/or change the colormap to control the appearance.

     Optionally, the color of the mesh can be specified independently of
     Z by supplying a color matrix, C.  If Z has N elements, then C
     should be an Nx1 vector for colormap data or an Nx3 matrix for RGB
     data.

     Any property/value pairs are passed directly to the underlying
     patch object.

     The optional return value H is a graphics handle to the created
     patch object.

     See also: mesh, tetramesh, triplot, trisurf, delaunay, patch,
     hidden.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Plot a 3-D triangular wireframe mesh.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
triplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 668
 -- Function File: triplot (TRI, X, Y)
 -- Function File: triplot (TRI, X, Y, LINESPEC)
 -- Function File: H = triplot (...)
     Plot a 2-D triangular mesh.

     TRI is typically the output of a Delaunay triangulation over the
     grid of X, Y.  Every row of TRI represents one triangle and
     contains three indices into [X, Y] which are the vertices of the
     triangles in the x-y plane.

     The linestyle to use for the plot can be defined with the argument
     LINESPEC of the same format as the 'plot' command.

     The optional return value H is a graphics handle to the created
     patch object.

     See also: plot, trimesh, trisurf, delaunay.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Plot a 2-D triangular mesh.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
trisurf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1297
 -- Function File: trisurf (TRI, X, Y, Z, C)
 -- Function File: trisurf (TRI, X, Y, Z)
 -- Function File: trisurf (..., PROP, VAL, ...)
 -- Function File: H = trisurf (...)
     Plot a 3-D triangular surface.

     In contrast to 'surf', which plots a surface mesh using rectangles,
     'trisurf' plots the mesh using triangles.

     TRI is typically the output of a Delaunay triangulation over the
     grid of X, Y.  Every row of TRI represents one triangle and
     contains three indices into [X, Y] which are the vertices of the
     triangles in the x-y plane.  Z determines the height above the
     plane of each vertex.

     The color of the trimesh is computed by linearly scaling the Z
     values to fit the range of the current colormap.  Use 'caxis'
     and/or change the colormap to control the appearance.

     Optionally, the color of the mesh can be specified independently of
     Z by supplying a color matrix, C.  If Z has N elements, then C
     should be an Nx1 vector for colormap data or an Nx3 matrix for RGB
     data.

     Any property/value pairs are passed directly to the underlying
     patch object.

     The optional return value H is a graphics handle to the created
     patch object.

     See also: surf, triplot, trimesh, delaunay, patch, shading.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Plot a 3-D triangular surface.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
waterfall


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1608
 -- Function File: waterfall (X, Y, Z)
 -- Function File: waterfall (Z)
 -- Function File: waterfall (..., C)
 -- Function File: waterfall (..., PROP, VAL, ...)
 -- Function File: waterfall (HAX, ...)
 -- Function File: H = waterfall (...)
     Plot a 3-D waterfall plot.

     A waterfall plot is similar to a 'meshz' plot except only mesh
     lines for the rows of Z (x-values) are shown.

     The wireframe mesh is plotted using rectangles.  The vertices of
     the rectangles [X, Y] are typically the output of 'meshgrid'.  over
     a 2-D rectangular region in the x-y plane.  Z determines the height
     above the plane of each vertex.  If only a single Z matrix is
     given, then it is plotted over the meshgrid 'X = 1:columns (Z), Y =
     1:rows (Z)'.  Thus, columns of Z correspond to different X values
     and rows of Z correspond to different Y values.

     The color of the mesh is computed by linearly scaling the Z values
     to fit the range of the current colormap.  Use 'caxis' and/or
     change the colormap to control the appearance.

     Optionally the color of the mesh can be specified independently of
     Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying
     surface object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by 'gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     See also: meshz, mesh, meshc, contour, surf, surface, ribbon,
     meshgrid, hidden, shading, colormap, caxis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Plot a 3-D waterfall plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
allchild


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 451
 -- Function File: H = allchild (HANDLES)
     Find all children, including hidden children, of a graphics object.

     This function is similar to 'get (h, "children")', but also returns
     hidden objects (HandleVisibility = "off").  If HANDLES is a scalar,
     H will be a vector.  Otherwise, H will be a cell matrix of the same
     size as HANDLES and each cell will contain a vector of handles.

     See also: findall, findobj, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Find all children, including hidden children, of a graphics object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ancestor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 625
 -- Function File: PARENT = ancestor (H, TYPE)
 -- Function File: PARENT = ancestor (H, TYPE, "toplevel")
     Return the first ancestor of handle object H whose type matches
     TYPE, where TYPE is a character string.  If TYPE is a cell array of
     strings, return the first parent whose type matches any of the
     given type strings.

     If the handle object H itself is of type TYPE, return H.

     If "toplevel" is given as a third argument, return the highest
     parent in the object hierarchy that matches the condition, instead
     of the first (nearest) one.

     See also: findobj, findall, allchild.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
Return the first ancestor of handle object H whose type matches  TYPE, where TYPE is a character string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
axes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 743
 -- Function File: axes ()
 -- Function File: axes (PROPERTY, VALUE, ...)
 -- Function File: axes (HAX)
 -- Function File: H = axes (...)
     Create an axes object and return a handle to it, or set the current
     axes to HAX.

     Called without any arguments, or with PROPERTY/VALUE pairs,
     construct a new axes.  For accepted properties and corresponding
     values, *note set: XREFset.

     Called with a single axes handle argument HAX, the function makes
     HAX the current axis.  It also restacks the axes in the
     corresponding figure so that HAX is the first entry in the list of
     children.  This causes HAX to be displayed on top of any other axes
     objects (Z-order stacking).

     See also: gca, set, get.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 81
Create an axes object and return a handle to it, or set the current  axes to HAX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
cla


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 658
 -- Command: cla
 -- Command: cla reset
 -- Function File: cla (HAX)
 -- Function File: cla (HAX, "reset")
     Clear the current axes.

     'cla' operates by deleting child graphic objects with visible
     handles (HandleVisibility = "on").

     If the optional argument "reset" is specified, delete all child
     objects including those with hidden handles and reset all axis
     properties to their defaults.  However, the following properties
     are not reset: Position, Units.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by 'gca'.

     See also: clf, delete, reset.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Clear the current axes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
clf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 846
 -- Command: clf
 -- Command: clf reset
 -- Function File: clf (HFIG)
 -- Function File: clf (HFIG, "reset")
 -- Function File: H = clf (...)
     Clear the current figure window.

     'clf' operates by deleting child graphics objects with visible
     handles (HandleVisibility = "on").

     If the optional argument "reset" is specified, delete all child
     objects including those with hidden handles and reset all figure
     properties to their defaults.  However, the following properties
     are not reset: Position, Units, PaperPosition, PaperUnits.

     If the first argument HFIG is a figure handle, then operate on this
     figure rather than the current figure returned by 'gcf'.

     The optional return value H is the graphics handle of the figure
     window that was cleared.

     See also: cla, close, delete, reset.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Clear the current figure window.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
close


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1043
 -- Command: close
 -- Command: close (H)
 -- Command: close all
 -- Command: close all hidden
     Close figure window(s).

     When called with no arguments, close the current figure.  This is
     equivalent to 'close (gcf)'.  If the input H is a graphic handle,
     or vector of graphics handles, then close each figure in H.

     If the argument "all" is given then all figures with visible
     handles (HandleVisibility = "on") are closed.

     If the argument "all hidden" is given then all figures, including
     hidden ones, are closed.

     Implementation Note: 'close' operates by calling the function
     specified by the "closerequestfcn" property for each figure.  By
     default, the function 'closereq' is used.  It is possible that the
     function invoked will delay or abort removing the figure.  To
     remove a figure without executing any callback functions use
     'delete'.  When writing a callback function to close a window do
     not use 'close' to avoid recursion.

     See also: closereq, delete.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Close figure window(s).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
closereq


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 252
 -- Function File: closereq ()
     Close the current figure and delete all graphics objects associated
     with it.

     By default, the "closerequestfcn" property of a new plot figure
     points to this function.

     See also: close, delete.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Close the current figure and delete all graphics objects associated  with it.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
colstyle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 230
 -- Function File: [STYLE, COLOR, MARKER, MSG] = colstyle (LINESPEC)
     Parse LINESPEC and return the line style, color, and markers given.
     In the case of an error, the string MSG will return the text of the
     error.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Parse LINESPEC and return the line style, color, and markers given.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
copyobj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 409
 -- Function File: HNEW = copyobj (HORIG)
 -- Function File: HNEW = copyobj (HORIG, HPARENT)
     Construct a copy of the graphic object associated with handle HORIG
     and return a handle HNEW to the new object.

     If a parent handle HPARENT (root, figure, axes, or hggroup) is
     specified, the copied object will be created as a child of HPARENT.

     See also: struct2hdl, hdl2struct, findobj.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Construct a copy of the graphic object associated with handle HORIG  and return a handle HNEW to the new object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
figure


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 793
 -- Command: figure
 -- Command: figure N
 -- Function File: figure (N)
 -- Function File: figure (..., "PROPERTY", VALUE, ...)
 -- Function File: H = figure (...)
     Create a new figure window for plotting.

     If no arguments are specified, a new figure with the next available
     number is created.

     If called with an integer N, and no such numbered figure exists,
     then a new figure with the specified number is created.  If the
     figure already exists then it is made visible and becomes the
     current figure for plotting.

     Multiple property-value pairs may be specified for the figure
     object, but they must appear in pairs.

     The optional return value H is a graphics handle to the created
     figure object.

     See also: axes, gcf, clf, close.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Create a new figure window for plotting.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
findall


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 862
 -- Function File: H = findall ()
 -- Function File: H = findall (PROP_NAME, PROP_VALUE, ...)
 -- Function File: H = findall (PROP_NAME, PROP_VALUE, "-LOGICAL_OP",
          PROP_NAME, PROP_VALUE)
 -- Function File: H = findall ("-property", PROP_NAME)
 -- Function File: H = findall ("-regexp", PROP_NAME, PATTERN)
 -- Function File: H = findall (HLIST, ...)
 -- Function File: H = findall (HLIST, "flat", ...)
 -- Function File: H = findall (HLIST, "-depth", D, ...)
     Find graphics object, including hidden ones, with specified
     property values.

     The return value H is a list of handles to the found graphic
     objects.

     'findall' performs the same search as 'findobj', but it includes
     hidden objects (HandleVisibility = "off").  For full documentation,
     *note findobj: XREFfindobj.

     See also: findobj, allchild, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
PROP_NAME, PROP_VALUE)  Find graphics object, including hidden ones, with specified  property values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
findfigs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 178
 -- Function File: findfigs ()
     Find all visible figures that are currently off the screen and move
     them onto the screen.

     See also: allchild, figure, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Find all visible figures that are currently off the screen and move  them onto the screen.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
findobj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2078
 -- Function File: H = findobj ()
 -- Function File: H = findobj (PROP_NAME, PROP_VALUE, ...)
 -- Function File: H = findobj (PROP_NAME, PROP_VALUE, "-LOGICAL_OP",
          PROP_NAME, PROP_VALUE)
 -- Function File: H = findobj ("-property", PROP_NAME)
 -- Function File: H = findobj ("-regexp", PROP_NAME, PATTERN)
 -- Function File: H = findobj (HLIST, ...)
 -- Function File: H = findobj (HLIST, "flat", ...)
 -- Function File: H = findobj (HLIST, "-depth", D, ...)
     Find graphics object with specified property values.

     The simplest form is

          findobj (PROP_NAME, PROP_VALUE)

     which returns the handles of all objects which have a property
     named PROP_NAME that has the value PROP_VALUE.  If multiple
     property/value pairs are specified then only objects meeting all of
     the conditions are returned.

     The search can be limited to a particular set of objects and their
     descendants, by passing a handle or set of handles HLIST as the
     first argument.

     The depth of the object hierarchy to search can be limited with the
     "-depth" argument.  An example of searching only three generations
     of children is:

          findobj (HLIST, "-depth", 3, PROP_NAME, PROP_VALUE)

     Specifying a depth D of 0, limits the search to the set of objects
     passed in HLIST.  A depth D of 0 is equivalent to the "flat"
     argument.

     A specified logical operator may be applied to the pairs of
     PROP_NAME and PROP_VALUE.  The supported logical operators are:
     "-and", "-or", "-xor", "-not".

     Objects may also be matched by comparing a regular expression to
     the property values, where property values that match 'regexp
     (PROP_VALUE, PATTERN)' are returned.

     Finally, objects may be matched by property name only by using the
     "-property" option.

     Implementation Note: The search only includes objects with visible
     handles (HandleVisibility = "on").  *Note findall: XREFfindall, to
     search for all objects including hidden ones.

     See also: findall, allchild, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
PROP_NAME, PROP_VALUE)  Find graphics object with specified property values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
gca


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 869
 -- Function File: H = gca ()
     Return a handle to the current axis object.

     The current axis is the default target for graphics output.  In the
     case of a figure with multiple axes, 'gca' returns the last created
     axes or the last axes that was clicked on with the mouse.

     If no current axes object exists, create one and return its handle.
     The handle may then be used to examine or set properties of the
     axes.  For example,

          ax = gca ();
          set (ax, "position", [0.5, 0.5, 0.5, 0.5]);

     creates an empty axes object and then changes its location and size
     in the figure window.

     Note: To find the current axis without creating a new axes object
     if it does not exist, query the "CurrentAxes" property of a figure.

          get (gcf, "currentaxes");

     See also: gcf, gco, gcbf, gcbo, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Return a handle to the current axis object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
gcbf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 360
 -- Function File: FIG = gcbf ()
     Return a handle to the figure containing the object whose callback
     is currently executing.

     If no callback is executing, this function returns the empty
     matrix.  The handle returned by this function is the same as the
     second output argument of 'gcbo'.

     See also: gcbo, gcf, gco, gca, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
Return a handle to the figure containing the object whose callback  is currently executing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
gcbo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 592
 -- Function File: H = gcbo ()
 -- Function File: [H, FIG] = gcbo ()
     Return a handle to the object whose callback is currently
     executing.

     If no callback is executing, this function returns the empty
     matrix.  This handle is obtained from the root object property
     "CallbackObject".

     When called with a second output argument, return the handle of the
     figure containing the object whose callback is currently executing.
     If no callback is executing the second output is also set to the
     empty matrix.

     See also: gcbf, gco, gca, gcf, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Return a handle to the object whose callback is currently  executing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
gcf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 949
 -- Function File: H = gcf ()
     Return a handle to the current figure.

     The current figure is the default target for graphics output.  If
     multiple figures exist, 'gcf' returns the last created figure or
     the last figure that was clicked on with the mouse.

     If a current figure does not exist, create one and return its
     handle.  The handle may then be used to examine or set properties
     of the figure.  For example,

          fplot (@sin, [-10, 10]);
          fig = gcf ();
          set (fig, "numbertitle", "off", "name", "sin plot")

     plots a sine wave, finds the handle of the current figure, and then
     renames the figure window to describe the contents.

     Note: To find the current figure without creating a new one if it
     does not exist, query the "CurrentFigure" property of the root
     graphics object.

          get (0, "currentfigure");

     See also: gca, gco, gcbf, gcbo, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return a handle to the current figure.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
gco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 895
 -- Function File: H = gco ()
 -- Function File: H = gco (FIG)
     Return a handle to the current object of the current figure, or a
     handle to the current object of the figure with handle FIG.

     The current object of a figure is the object that was last clicked
     on.  It is stored in the "CurrentObject" property of the target
     figure.

     If the last mouse click did not occur on any child object of the
     figure, then the current object is the figure itself.

     If no mouse click occurred in the target figure, this function
     returns an empty matrix.

     Programming Note: The value returned by this function is not
     necessarily the same as the one returned by 'gcbo' during callback
     execution.  An executing callback can be interrupted by another
     callback and the current object may be changed.

     See also: gcbo, gca, gcf, gcbf, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
Return a handle to the current object of the current figure, or a  handle to the current object of the figure with handle FIG.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ginput


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 670
 -- Function File: [X, Y, BUTTONS] = ginput (N)
 -- Function File: [X, Y, BUTTONS] = ginput ()
     Return the position and type of mouse button clicks and/or key
     strokes in the current figure window.

     If N is defined, then capture N events before returning.  When N is
     not defined 'ginput' will loop until the return key <RET> is
     pressed.

     The return values X, Y are the coordinates where the mouse was
     clicked in the units of the current axes.  The return value BUTTON
     is 1, 2, or 3 for the left, middle, or right button.  If a key is
     pressed the ASCII value is returned in BUTTON.

     See also: gtext, waitforbuttonpress.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
Return the position and type of mouse button clicks and/or key  strokes in the current figure window.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
graphics_toolkit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 852
 -- Function File: NAME = graphics_toolkit ()
 -- Function File: NAME = graphics_toolkit (HLIST)
 -- Function File: graphics_toolkit (NAME)
 -- Function File: graphics_toolkit (HLIST, NAME)
     Query or set the default graphics toolkit which is assigned to new
     figures.

     With no inputs, return the current default graphics toolkit.  If
     the input is a list of figure graphic handles, HLIST, then return
     the name of the graphics toolkit in use for each figure.

     When called with a single input NAME set the default graphics
     toolkit to NAME.  If the toolkit is not already loaded, it is
     initialized by calling the function '__init_NAME__'.  If the first
     input is a list of figure handles, HLIST, then the graphics toolkit
     is set to NAME for these figures only.

     See also: available_graphics_toolkits.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Query or set the default graphics toolkit which is assigned to new  figures.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
hdl2struct


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 316
 -- Function File: S = hdl2struct (H)
     Return a structure, S, whose fields describe the properties of the
     object, and its children, associated with the handle, H.

     The fields of the structure S are "type", "handle", "properties",
     "children", and "special".

     See also: struct2hdl, findobj.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
Return a structure, S, whose fields describe the properties of the  object, and its children, associated with the handle, H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hggroup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 920
 -- Function File: hggroup ()
 -- Function File: hggroup (HAX)
 -- Function File: hggroup (..., PROPERTY, VALUE, ...)
 -- Function File: H = hggroup (...)
     Create handle graphics group object with axes parent HAX.

     If no parent is specified, the group is created in the current
     axes.

     Multiple property/value pairs may be specified for the hggroup, but
     they must appear in pairs.

     The optional return value H is a graphics handle to the created
     hggroup object.

     Programming Note: An hggroup is a way to group base graphics
     objects such as line objects or patch objects into a single unit
     which can react appropriately.  For example, the individual lines
     of a contour plot are collected into a single hggroup so that they
     can be made visible/invisible with a single command, 'set
     (hg_handle, "visible", "off")'.

     See also: addproperty, addlistener.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Create handle graphics group object with axes parent HAX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
hold


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1097
 -- Command: hold
 -- Command: hold on
 -- Command: hold off
 -- Command: hold all
 -- Function File: hold (HAX, ...)
     Toggle or set the "hold" state of the plotting engine which
     determines whether new graphic objects are added to the plot or
     replace the existing objects.

     'hold on'
          Retain plot data and settings so that subsequent plot commands
          are displayed on a single graph.

     'hold all'
          Retain plot line color, line style, data, and settings so that
          subsequent plot commands are displayed on a single graph with
          the next line color and style.

     'hold off'
          Restore default graphics settings which clear the graph and
          reset axis properties before each new plot command.
          (default).

     'hold'
          Toggle the current hold state.

     When given the additional argument HAX, the hold state is modified
     for this axis rather than the current axes returned by 'gca'.

     To query the current hold state use the 'ishold' function.

     See also: ishold, cla, clf, newplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 155
Toggle or set the "hold" state of the plotting engine which  determines whether new graphic objects are added to the plot or  replace the existing objects.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isaxes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 292
 -- Function File: isaxes (H)
     Return true if H is an axes graphics handle and false otherwise.

     If H is a matrix then return a logical array which is true where
     the elements of H are axes graphics handles and false where they
     are not.

     See also: isaxes, ishandle.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return true if H is an axes graphics handle and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isfigure


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 297
 -- Function File: isfigure (H)
     Return true if H is a figure graphics handle and false otherwise.

     If H is a matrix then return a logical array which is true where
     the elements of H are figure graphics handles and false where they
     are not.

     See also: isaxes, ishandle.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return true if H is a figure graphics handle and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
ishghandle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 227
 -- Function File: ishghandle (H)
     Return true if H is a graphics handle and false otherwise.

     This function is equivalent to 'ishandle' and is provided for
     compatibility with MATLAB.

     See also: ishandle.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Return true if H is a graphics handle and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ishold


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 404
 -- Command: ishold
 -- Function File: ishold (HAX)
 -- Function File: ishold (HFIG)
     Return true if the next plot will be added to the current plot, or
     false if the plot device will be cleared before drawing the next
     plot.

     If the first argument is an axes handle HAX or figure handle HFIG
     then operate on this plot rather than the current one.

     See also: hold, newplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 139
Return true if the next plot will be added to the current plot, or  false if the plot device will be cleared before drawing the next  plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isprop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 302
 -- Function File: RES = isprop (H, "PROP")
     Return true if PROP is a property of the object with handle H.

     H may also be an array of handles in which case RES will be a
     logical array indicating whether each handle has the property PROP.

     See also: get, set, ismethod, isobject.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return true if PROP is a property of the object with handle H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
linkprop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 728
 -- Function File: HLINK = linkprop (H, PROP)
 -- Function File: HLINK = linkprop (H, {PROP1, PROP2, ...})
     Link graphics object properties, such that a change in one is
     propagated to the others.

     PROP can be a string for a single property, or a cell array of
     strings for multiple properties.  H is an array of graphics handles
     which will have their properties linked.

     An example of the use of 'linkprop' is

          x = 0:0.1:10;
          subplot (1,2,1);
          h1 = plot (x, sin (x));
          subplot (1,2,2);
          h2 = plot (x, cos (x));
          hlink = linkprop ([h1, h2], {"color","linestyle"});
          set (h1, "color", "green");
          set (h2, "linestyle", "--");

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
Link graphics object properties, such that a change in one is  propagated to the others.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
meshgrid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1587
 -- Function File: [XX, YY] = meshgrid (X, Y)
 -- Function File: [XX, YY, ZZ] = meshgrid (X, Y, Z)
 -- Function File: [XX, YY] = meshgrid (X)
 -- Function File: [XX, YY, ZZ] = meshgrid (X)
     Given vectors of X and Y coordinates, return matrices XX and YY
     corresponding to a full 2-D grid.

     The rows of XX are copies of X, and the columns of YY are copies of
     Y.  If Y is omitted, then it is assumed to be the same as X.

     If the optional Z input is given, or ZZ is requested, then the
     output will be a full 3-D grid.

     'meshgrid' is most frequently used to produce input for a 2-D or
     3-D function that will be plotted.  The following example creates a
     surface plot of the "sombrero" function.

          f = @(x,y) sin (sqrt (x.^2 + y.^2)) ./ sqrt (x.^2 + y.^2);
          range = linspace (-8, 8, 41);
          [X, Y] = meshgrid (range, range);
          Z = f (X, Y);
          surf (X, Y, Z);

     Programming Note: 'meshgrid' is restricted to 2-D or 3-D grid
     generation.  The 'ndgrid' function will generate 1-D through N-D
     grids.  However, the functions are not completely equivalent.  If X
     is a vector of length M and Y is a vector of length N, then
     'meshgrid' will produce an output grid which is NxM.  'ndgrid' will
     produce an output which is MxN (transpose) for the same input.
     Some core functions expect 'meshgrid' input and others expect
     'ndgrid' input.  Check the documentation for the function in
     question to determine the proper input format.

     See also: ndgrid, mesh, contour, surf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Given vectors of X and Y coordinates, return matrices XX and YY  corresponding to a full 2-D grid.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ndgrid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 895
 -- Function File: [Y1, Y2, ..., Yn] = ndgrid (X1, X2, ..., Xn)
 -- Function File: [Y1, Y2, ..., Yn] = ndgrid (X)
     Given n vectors X1, ..., Xn, 'ndgrid' returns n arrays of dimension
     n.  The elements of the i-th output argument contains the elements
     of the vector Xi repeated over all dimensions different from the
     i-th dimension.  Calling ndgrid with only one input argument X is
     equivalent to calling ndgrid with all n input arguments equal to X:

     [Y1, Y2, ..., Yn] = ndgrid (X, ..., X)

     Programming Note: 'ndgrid' is very similar to the function
     'meshgrid' except that the first two dimensions are transposed in
     comparison to 'meshgrid'.  Some core functions expect 'meshgrid'
     input and others expect 'ndgrid' input.  Check the documentation
     for the function in question to determine the proper input format.

     See also: meshgrid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Given n vectors X1, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
newplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2682
 -- Function File: newplot ()
 -- Function File: newplot (HFIG)
 -- Function File: newplot (HAX)
 -- Function File: HAX = newplot (...)
     Prepare graphics engine to produce a new plot.

     This function is called at the beginning of all high-level plotting
     functions.  It is not normally required in user programs.
     'newplot' queries the "NextPlot" field of the current figure and
     axis to determine what to do.

     Figure NextPlot    Action
     --------------------------------------------------------------------------
     "new"              Create a new figure and make it the current figure.
                        
     "add" (default)    Add new graphic objects to the current figure.
                        
     "replacechildren"  Delete child objects whose HandleVisibility is set
                        to "on".  Set NextPlot property to "add".  This
                        typically clears a figure, but leaves in place
                        hidden objects such as menubars.  This is equivalent
                        to 'clf'.
                        
     "replace"          Delete all child objects of the figure and reset all
                        figure properties to their defaults.  However, the
                        following four properties are not reset: Position,
                        Units, PaperPosition, PaperUnits.  This is
                        equivalent to 'clf reset'.

     Axis NextPlot      Action
     --------------------------------------------------------------------------
     "add"              Add new graphic objects to the current axes.  This
                        is equivalent to 'hold on'.
                        
     "replacechildren"  Delete child objects whose HandleVisibility is set
                        to "on", but leave axis properties unmodified.  This
                        typically clears a plot, but preserves special
                        settings such as log scaling for axes.  This is
                        equivalent to 'cla'.
                        
     "replace"          Delete all child objects of the axis and reset all
     (default)          axis properties to their defaults.  However, the
                        following properties are not reset: Position, Units.
                        This is equivalent to 'cla reset'.

     If the optional input HFIG or HAX is given then prepare the
     specified figure or axes rather than the current figure and axes.

     The optional return value HAX is a graphics handle to the created
     axes object (not figure).

     *Caution:* Calling 'newplot' may change the current figure and
     current axis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Prepare graphics engine to produce a new plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
printd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 418
 -- Function File: printd (OBJ, FILENAME)
 -- Function File: OUT_FILE = printd (...)

     Convert any object acceptable to 'disp' into the format selected by
     the suffix of FILENAME.  If the return argument OUT_FILE is given,
     the name of the created file is returned.

     This function is intended to facilitate manipulation of the output
     of functions such as 'stemleaf'.

     See also: stemleaf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
Convert any object acceptable to 'disp' into the format selected by  the suffix of FILENAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
print


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7735
 -- Function File: print ()
 -- Function File: print (OPTIONS)
 -- Function File: print (FILENAME, OPTIONS)
 -- Function File: print (H, FILENAME, OPTIONS)
     Print a plot, or save it to a file.

     Both output formatted for printing (PDF and PostScript), and many
     bitmapped and vector image formats are supported.

     FILENAME defines the name of the output file.  If the file name has
     no suffix, one is inferred from the specified device and appended
     to the file name.  If no filename is specified, the output is sent
     to the printer.

     H specifies the handle of the figure to print.  If no handle is
     specified the current figure is used.

     For output to a printer, PostScript file, or PDF file, the paper
     size is specified by the figure's 'papersize' property.  The
     location and size of the image on the page are specified by the
     figure's 'paperposition' property.  The orientation of the page is
     specified by the figure's 'paperorientation' property.

     The width and height of images are specified by the figure's
     'paperpositon(3:4)' property values.

     The 'print' command supports many OPTIONS:

     '-fH'
          Specify the handle, H, of the figure to be printed.  The
          default is the current figure.

     '-PPRINTER'
          Set the PRINTER name to which the plot is sent if no FILENAME
          is specified.

     '-GGHOSTSCRIPT_COMMAND'
          Specify the command for calling Ghostscript.  For Unix and
          Windows the defaults are "gs" and "gswin32c", respectively.

     '-color'
     '-mono'
          Color or monochrome output.

     '-solid'
     '-dashed'
          Force all lines to be solid or dashed, respectively.

     '-portrait'
     '-landscape'
          Specify the orientation of the plot for printed output.  For
          non-printed output the aspect ratio of the output corresponds
          to the plot area defined by the "paperposition" property in
          the orientation specified.  This option is equivalent to
          changing the figure's "paperorientation" property.

     '-TextAlphaBits=N'
     '-GraphicsAlphaBits=N'
          Octave is able to produce output for various printers,
          bitmaps, and vector formats by using Ghostscript.  For bitmap
          and printer output anti-aliasing is applied using
          Ghostscript's TextAlphaBits and GraphicsAlphaBits options.
          The default number of bits for each is 4.  Allowed values for
          N are 1, 2, or 4.

     '-dDEVICE'
          The available output format is specified by the option DEVICE,
          and is one of:

          'ps'
          'ps2'
          'psc'
          'psc2'
               PostScript (level 1 and 2, mono and color).  The FLTK
               graphics toolkit generates PostScript level 3.0.

          'eps'
          'eps2'
          'epsc'
          'epsc2'
               Encapsulated PostScript (level 1 and 2, mono and color).
               The FLTK graphic toolkit generates PostScript level 3.0.

          'tex'
          'epslatex'
          'epslatexstandalone'
          'pstex'
          'pslatex'
          'pdflatex'
               Generate a LaTeX (or TeX) file for labels and eps/ps/pdf
               for graphics.  The file produced by 'epslatexstandalone'
               can be processed directly by LaTeX.  The other formats
               are intended to be included in a LaTeX (or TeX) document.
               The 'tex' device is the same as the 'epslatex' device.
               The 'pdflatex' device is only available for the FLTK
               graphics toolkit.

          'tikz'
               Generate a LaTeX file using PGF/TikZ.  For the FLTK
               toolkit the result is PGF.

          'ill'
          'aifm'
               Adobe Illustrator (Obsolete for Gnuplot versions > 4.2)

          'cdr'
          'corel'
               CorelDraw

          'dxf'
               AutoCAD

          'emf'
          'meta'
               Microsoft Enhanced Metafile

          'fig'
               XFig.  For the Gnuplot graphics toolkit, the additional
               options '-textspecial' or '-textnormal' can be used to
               control whether the special flag should be set for the
               text in the figure.  (default is '-textnormal')

          'hpgl'
               HP plotter language

          'mf'
               Metafont

          'png'
               Portable network graphics

          'jpg'
          'jpeg'
               JPEG image

          'gif'
               GIF image (only available for the Gnuplot graphics
               toolkit)

          'pbm'
               PBMplus

          'svg'
               Scalable vector graphics

          'pdf'
               Portable document format

          If the device is omitted, it is inferred from the file
          extension, or if there is no filename it is sent to the
          printer as PostScript.

     '-dGHOSTSCRIPT_DEVICE'
          Additional devices are supported by Ghostscript.  Some
          examples are;

          'ljet2p'
               HP LaserJet IIP

          'ljet3'
               HP LaserJet III

          'deskjet'
               HP DeskJet and DeskJet Plus

          'cdj550'
               HP DeskJet 550C

          'paintjet'
               HP PointJet

          'pcx24b'
               24-bit color PCX file format

          'ppm'
               Portable Pixel Map file format

          'pdfwrite'
               Produces pdf output from eps

          For a complete list, type 'system ("gs -h")' to see what
          formats and devices are available.

          When Ghostscript output is sent to a printer the size is
          determined by the figure's "papersize" property.  When the
          output is sent to a file the size is determined by the plot
          box defined by the figure's "paperposition" property.

     '-append'
          Append PostScript or PDF output to a pre-existing file of the
          same type.

     '-rNUM'
          Resolution of bitmaps in pixels per inch.  For both metafiles
          and SVG the default is the screen resolution; for other
          formats it is 150 dpi.  To specify screen resolution, use
          "-r0".

     '-loose'
     '-tight'
          Force a tight or loose bounding box for eps files.  The
          default is loose.

     '-PREVIEW'
          Add a preview to eps files.  Supported formats are:

          '-interchange'
               Provide an interchange preview.

          '-metalfile'
               Provide a metafile preview.

          '-pict'
               Provide pict preview.

          '-tiff'
               Provide a tiff preview.

     '-SXSIZE,YSIZE'
          Plot size in pixels for EMF, GIF, JPEG, PBM, PNG, and SVG.
          For PS, EPS, PDF, and other vector formats the plot size is in
          points.  This option is equivalent to changing the size of the
          plot box associated with the "paperposition" property.  When
          using the command form of the print function you must quote
          the XSIZE,YSIZE option.  For example, by writing "-S640,480".

     '-FFONTNAME'
     '-FFONTNAME:SIZE'
     '-F:SIZE'
          Use FONTNAME and/or FONTSIZE for all text.  FONTNAME is
          ignored for some devices: dxf, fig, hpgl, etc.

     The filename and options can be given in any order.

     Example: Print to a file using the svg device.

          figure (1);
          clf ();
          surf (peaks);
          print -dsvg figure1.svg

     Example: Print to an HP DeskJet 550C.

          clf ();
          surf (peaks);
          print -dcdj550

     See also: saveas, orient, figure.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Print a plot, or save it to a file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
refreshdata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 973
 -- Function File: refreshdata ()
 -- Function File: refreshdata (H)
 -- Function File: refreshdata (H, WORKSPACE)
     Evaluate any 'datasource' properties of the current figure and
     update the plot if the corresponding data has changed.

     If the first argument H is a list of graphic handles, then operate
     on these objects rather than the current figure returned by 'gcf'.

     The optional second argument WORKSPACE can take the following
     values:

     "base"
          Evaluate the datasource properties in the base workspace.
          (default).

     "caller"
          Evaluate the datasource properties in the workspace of the
          function that called 'refreshdata'.

     An example of the use of 'refreshdata' is:

          x = 0:0.1:10;
          y = sin (x);
          plot (x, y, "ydatasource", "y");
          for i = 1 : 100
            pause (0.1);
            y = sin (x + 0.1*i);
            refreshdata ();
          endfor
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 118
Evaluate any 'datasource' properties of the current figure and  update the plot if the corresponding data has changed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
refresh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 268
 -- Function File: refresh ()
 -- Function File: refresh (H)
     Refresh a figure, forcing it to be redrawn.

     When called without an argument the current figure is redrawn.
     Otherwise, the figure with graphic handle H is redrawn.

     See also: drawnow.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Refresh a figure, forcing it to be redrawn.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
saveas


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 722
 -- Function File: saveas (H, FILENAME)
 -- Function File: saveas (H, FILENAME, FMT)
     Save graphic object H to the file FILENAME in graphic format FMT.

     FMT should be one of the following formats:

     'ps'
          PostScript

     'eps'
          Encapsulated PostScript

     'jpg'
          JPEG Image

     'png'
          PNG Image

     'emf'
          Enhanced Meta File

     'pdf'
          Portable Document Format

     All device formats specified in 'print' may also be used.  If FMT
     is omitted it is extracted from the extension of FILENAME.  The
     default format is "pdf".

          clf ();
          surf (peaks);
          saveas (1, "figure1.png");

     See also: print, orient.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Save graphic object H to the file FILENAME in graphic format FMT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
shg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 139
 -- Command: shg
     Show the graph window.

     Currently, this is the same as executing 'drawnow'.

     See also: drawnow, figure.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Show the graph window.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
struct2hdl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 808
 -- Function File: H = struct2hdl (S)
 -- Function File: H = struct2hdl (S, P)
 -- Function File: H = struct2hdl (S, P, HILEV)
     Construct a graphics handle object H from the structure S.

     The structure must contain the fields "handle", "type", "children",
     "properties", and "special".  If the handle of an existing figure
     or axes is specified, P, the new object will be created as a child
     of that object.  If no parent handle is provided then a new figure
     and the necessary children will be constructed using the default
     values from the root figure.

     A third boolean argument HILEV can be passed to specify whether the
     function should preserve listeners/callbacks, e.g., for legends or
     hggroups.  The default is false.

     See also: hdl2struct, findobj.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Construct a graphics handle object H from the structure S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
subplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2256
 -- Function File: subplot (ROWS, COLS, INDEX)
 -- Function File: subplot (RCN)
 -- Function File: subplot (HAX)
 -- Function File: subplot (..., "align")
 -- Function File: subplot (..., "replace")
 -- Function File: subplot (..., "position", POS)
 -- Function File: subplot (..., PROP, VAL, ...)
 -- Function File: HAX = subplot (...)
     Set up a plot grid with ROWS by COLS subwindows and set the current
     axes for plotting ('gca') to the location given by INDEX.

     If only one numeric argument is supplied, then it must be a three
     digit value specifying the number of rows in digit 1, the number of
     columns in digit 2, and the plot index in digit 3.

     The plot index runs row-wise; First, all columns in a row are
     numbered and then the next row is filled.

     For example, a plot with 2x3 grid will have plot indices running as
     follows:

          +-----+-----+-----+
          |  1  |  2  |  3  |
          +-----+-----+-----+
          |  4  |  5  |  6  |
          +-----+-----+-----+

     INDEX may also be a vector.  In this case, the new axis will
     enclose the grid locations specified.  The first demo illustrates
     this:

          demo ("subplot", 1)

     The index of the subplot to make active may also be specified by
     its axes handle, HAX, returned from a previous 'subplot' command.

     If the option "align" is given then the plot boxes of the
     subwindows will align, but this may leave no room for axis tick
     marks or labels.

     If the option "replace" is given then the subplot axis will be
     reset, rather than just switching the current axis for plotting to
     the requested subplot.

     The "position" property can be used to exactly position the subplot
     axes within the current figure.  The option POS is a 4-element
     vector [x, y, width, height] that determines the location and size
     of the axes.  The values in POS are normalized in the range [0,1].

     Any property/value pairs are passed directly to the underlying axes
     object.

     If the output HAX is requested, subplot returns the axis handle for
     the subplot.  This is useful for modifying the properties of a
     subplot using 'set'.

     See also: axes, plot, gca, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
Set up a plot grid with ROWS by COLS subwindows and set the current  axes for plotting ('gca') to the location given by INDEX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
compan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 879
 -- Function File: compan (C)
     Compute the companion matrix corresponding to polynomial
     coefficient vector C.

     The companion matrix is

               _                                                        _
              |  -c(2)/c(1)   -c(3)/c(1)  ...  -c(N)/c(1)  -c(N+1)/c(1)  |
              |       1            0      ...       0             0      |
              |       0            1      ...       0             0      |
          A = |       .            .      .         .             .      |
              |       .            .       .        .             .      |
              |       .            .        .       .             .      |
              |_      0            0      ...       1             0     _|

     The eigenvalues of the companion matrix are equal to the roots of
     the polynomial.

     See also: roots, poly, eig.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Compute the companion matrix corresponding to polynomial  coefficient vector C.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
conv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 622
 -- Function File: conv (A, B)
 -- Function File: conv (A, B, SHAPE)
     Convolve two vectors A and B.

     The output convolution is a vector with length equal to 'length (A)
     + length (B) - 1'.  When A and B are the coefficient vectors of two
     polynomials, the convolution represents the coefficient vector of
     the product polynomial.

     The optional SHAPE argument may be

     SHAPE = "full"
          Return the full convolution.  (default)

     SHAPE = "same"
          Return the central part of the convolution with the same size
          as A.

     See also: deconv, conv2, convn, fftconv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Convolve two vectors A and B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
deconv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 360
 -- Function File: deconv (Y, A)
     Deconvolve two vectors.

     '[b, r] = deconv (y, a)' solves for B and R such that 'y = conv (a,
     b) + r'.

     If Y and A are polynomial coefficient vectors, B will contain the
     coefficients of the polynomial quotient and R will be a remainder
     polynomial of lowest order.

     See also: conv, residue.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Deconvolve two vectors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
mkpp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1042
 -- Function File: PP = mkpp (BREAKS, COEFS)
 -- Function File: PP = mkpp (BREAKS, COEFS, D)

     Construct a piecewise polynomial (pp) structure from sample points
     BREAKS and coefficients COEFS.  BREAKS must be a vector of strictly
     increasing values.  The number of intervals is given by 'NI =
     length (BREAKS) - 1'.  When M is the polynomial order COEFS must be
     of size: NI x M + 1.

     The i-th row of COEFS, 'COEFS (I,:)', contains the coefficients for
     the polynomial over the I-th interval, ordered from highest (M) to
     lowest (0).

     COEFS may also be a multi-dimensional array, specifying a
     vector-valued or array-valued polynomial.  In that case the
     polynomial order is defined by the length of the last dimension of
     COEFS.  The size of first dimension(s) are given by the scalar or
     vector D.  If D is not given it is set to '1'.  In any case COEFS
     is reshaped to a 2-D matrix of size '[NI*prod(D M)] '

     See also: unmkpp, ppval, spline, pchip, ppder, ppint, ppjumps.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Construct a piecewise polynomial (pp) structure from sample points  BREAKS and coefficients COEFS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mpoles


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 910
 -- Function File: [MULTP, IDXP] = mpoles (P)
 -- Function File: [MULTP, IDXP] = mpoles (P, TOL)
 -- Function File: [MULTP, IDXP] = mpoles (P, TOL, REORDER)
     Identify unique poles in P and their associated multiplicity.  The
     output is ordered from largest pole to smallest pole.

     If the relative difference of two poles is less than TOL then they
     are considered to be multiples.  The default value for TOL is
     0.001.

     If the optional parameter REORDER is zero, poles are not sorted.

     The output MULTP is a vector specifying the multiplicity of the
     poles.  'MULTP(n)' refers to the multiplicity of the Nth pole
     'P(IDXP(n))'.

     For example:

          p = [2 3 1 1 2];
          [m, n] = mpoles (p)
             => m = [1; 1; 2; 1; 2]
             => n = [2; 5; 1; 4; 3]
             => p(n) = [3, 2, 2, 1, 1]

     See also: residue, poly, roots, conv, deconv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Identify unique poles in P and their associated multiplicity.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
pchip


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1119
 -- Function File: PP = pchip (X, Y)
 -- Function File: YI = pchip (X, Y, XI)
     Return the Piecewise Cubic Hermite Interpolating Polynomial (pchip)
     of points X and Y.

     If called with two arguments, return the piecewise polynomial PP
     that may be used with 'ppval' to evaluate the polynomial at
     specific points.  When called with a third input argument, 'pchip'
     evaluates the pchip polynomial at the points XI.  The third calling
     form is equivalent to 'ppval (pchip (X, Y), XI)'.

     The variable X must be a strictly monotonic vector (either
     increasing or decreasing) of length N.  Y can be either a vector or
     array.  If Y is a vector then it must be the same length N as X.
     If Y is an array then the size of Y must have the form '[S1, S2,
     ..., SK, N]' The array is reshaped internally to a matrix where the
     leading dimension is given by 'S1 * S2 * ... * SK' and each row of
     this matrix is then treated separately.  Note that this is exactly
     opposite to 'interp1' but is done for MATLAB compatibility.

     See also: spline, ppval, mkpp, unmkpp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Return the Piecewise Cubic Hermite Interpolating Polynomial (pchip)  of points X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
poly


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 978
 -- Function File: poly (A)
 -- Function File: poly (X)
     If A is a square N-by-N matrix, 'poly (A)' is the row vector of the
     coefficients of 'det (z * eye (N) - A)', the characteristic
     polynomial of A.  For example, the following code finds the
     eigenvalues of A which are the roots of 'poly (A)'.

          roots (poly (eye (3)))
              => 1.00001 + 0.00001i
                 1.00001 - 0.00001i
                 0.99999 + 0.00000i

     In fact, all three eigenvalues are exactly 1 which emphasizes that
     for numerical performance the 'eig' function should be used to
     compute eigenvalues.

     If X is a vector, 'poly (X)' is a vector of the coefficients of the
     polynomial whose roots are the elements of X.  That is, if C is a
     polynomial, then the elements of 'D = roots (poly (C))' are
     contained in C.  The vectors C and D are not identical, however,
     due to sorting and numerical errors.

     See also: roots, eig.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 146
If A is a square N-by-N matrix, 'poly (A)' is the row vector of the  coefficients of 'det (z * eye (N) - A)', the characteristic  polynomial of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
polyaffine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 328
 -- Function File: polyaffine (F, MU)
     Return the coefficients of the polynomial vector F after an affine
     transformation.  If F is the vector representing the polynomial
     f(x), then 'G = polyaffine (F, MU)' is the vector representing:

          g(x) = f( (x - MU(1)) / MU(2) )

     See also: polyval, polyfit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
Return the coefficients of the polynomial vector F after an affine  transformation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
polyder


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 531
 -- Function File: polyder (P)
 -- Function File: [K] = polyder (A, B)
 -- Function File: [Q, D] = polyder (B, A)
     Return the coefficients of the derivative of the polynomial whose
     coefficients are given by the vector P.  If a pair of polynomials
     is given, return the derivative of the product A*B.  If two inputs
     and two outputs are given, return the derivative of the polynomial
     quotient B/A.  The quotient numerator is in Q and the denominator
     in D.

     See also: polyint, polyval, polyreduce.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 106
Return the coefficients of the derivative of the polynomial whose  coefficients are given by the vector P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
polyeig


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 523
 -- Function File: Z = polyeig (C0, C1, ..., CL)
 -- Function File: [V, Z] = polyeig (C0, C1, ..., CL)

     Solve the polynomial eigenvalue problem of degree L.

     Given an N*N matrix polynomial 'C(s) = C0 + C1 s + ... + CL s^l'
     polyeig solves the eigenvalue problem '(C0 + C1 + ... + CL)v = 0'.
     Note that the eigenvalues Z are the zeros of the matrix polynomial.
     Z is an LXN vector and V is an (N x N)l matrix with columns that
     correspond to the eigenvectors.

     See also: eig, eigs, compan.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Solve the polynomial eigenvalue problem of degree L.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
polyfit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1637
 -- Function File: P = polyfit (X, Y, N)
 -- Function File: [P, S] = polyfit (X, Y, N)
 -- Function File: [P, S, MU] = polyfit (X, Y, N)
     Return the coefficients of a polynomial P(X) of degree N that
     minimizes the least-squares-error of the fit to the points '[X,
     Y]'.  If N is a logical vector, it is used as a mask to selectively
     force the corresponding polynomial coefficients to be used or
     ignored.

     The polynomial coefficients are returned in a row vector.

     The optional output S is a structure containing the following
     fields:

     'R'
          Triangular factor R from the QR decomposition.

     'X'
          The Vandermonde matrix used to compute the polynomial
          coefficients.

     'C'
          The unscaled covariance matrix, formally equal to the inverse
          of X'*X, but computed in a way minimizing roundoff error
          propagation.

     'df'
          The degrees of freedom.

     'normr'
          The norm of the residuals.

     'yf'
          The values of the polynomial for each value of X.

     The second output may be used by 'polyval' to calculate the
     statistical error limits of the predicted values.  In particular,
     the standard deviation of P coefficients is given by
     'sqrt (diag (s.C)/s.df)*s.normr'.

     When the third output, MU, is present the coefficients, P, are
     associated with a polynomial in XHAT = (X-MU(1))/MU(2).  Where
     MU(1) = mean (X), and MU(2) = std (X).  This linear transformation
     of X improves the numerical stability of the fit.

     See also: polyval, polyaffine, roots, vander, zscore.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
Return the coefficients of a polynomial P(X) of degree N that  minimizes the least-squares-error of the fit to the points '[X,  Y]'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
polygcd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 737
 -- Function File: Q = polygcd (B, A)
 -- Function File: Q = polygcd (B, A, TOL)

     Find the greatest common divisor of two polynomials.  This is
     equivalent to the polynomial found by multiplying together all the
     common roots.  Together with deconv, you can reduce a ratio of two
     polynomials.  The tolerance TOL defaults to 'sqrt (eps)'.

     *Caution:* This is a numerically unstable algorithm and should not
     be used on large polynomials.

     Example code:

          polygcd (poly (1:8), poly (3:12)) - poly (3:8)
          => [ 0, 0, 0, 0, 0, 0, 0 ]
          deconv (poly (1:8), polygcd (poly (1:8), poly (3:12))) - poly (1:2)
          => [ 0, 0, 0 ]

     See also: poly, roots, conv, deconv, residue.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Find the greatest common divisor of two polynomials.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
polyint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 308
 -- Function File: polyint (P)
 -- Function File: polyint (P, K)
     Return the coefficients of the integral of the polynomial whose
     coefficients are represented by the vector P.  The variable K is
     the constant of integration, which by default is set to zero.

     See also: polyder, polyval.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
Return the coefficients of the integral of the polynomial whose  coefficients are represented by the vector P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
polyout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 336
 -- Function File: polyout (C)
 -- Function File: polyout (C, X)
 -- Function File: STR = polyout (...)
     Write formatted polynomial

          c(x) = c(1) * x^n + ... + c(n) x + c(n+1)

     and return it as a string or write it to the screen (if NARGOUT is
     zero).  X defaults to the string "s".

     See also: polyreduce.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Write formatted polynomial 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
polyreduce


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 176
 -- Function File: polyreduce (C)
     Reduce a polynomial coefficient vector to a minimum number of terms
     by stripping off any leading zeros.

     See also: polyout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
Reduce a polynomial coefficient vector to a minimum number of terms  by stripping off any leading zeros.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
polyval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 775
 -- Function File: Y = polyval (P, X)
 -- Function File: Y = polyval (P, X, [], MU)
 -- Function File: [Y, DY] = polyval (P, X, S)
 -- Function File: [Y, DY] = polyval (P, X, S, MU)

     Evaluate the polynomial P at the specified values of X.  When MU is
     present, evaluate the polynomial for (X-MU(1))/MU(2).  If X is a
     vector or matrix, the polynomial is evaluated for each of the
     elements of X.

     In addition to evaluating the polynomial, the second output
     represents the prediction interval, Y +/- DY, which contains at
     least 50% of the future predictions.  To calculate the prediction
     interval, the structured variable S, originating from 'polyfit',
     must be supplied.

     See also: polyvalm, polyaffine, polyfit, roots, poly.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Evaluate the polynomial P at the specified values of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
polyvalm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 357
 -- Function File: polyvalm (C, X)
     Evaluate a polynomial in the matrix sense.

     'polyvalm (C, X)' will evaluate the polynomial in the matrix sense,
     i.e., matrix multiplication is used instead of element by element
     multiplication as used in 'polyval'.

     The argument X must be a square matrix.

     See also: polyval, roots, poly.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Evaluate a polynomial in the matrix sense.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ppval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 411
 -- Function File: YI = ppval (PP, XI)
     Evaluate the piecewise polynomial structure PP at the points XI.
     If PP describes a scalar polynomial function, the result is an
     array of the same shape as XI.  Otherwise, the size of the result
     is '[pp.dim, length(XI)]' if XI is a vector, or '[pp.dim,
     size(XI)]' if it is a multi-dimensional array.

     See also: mkpp, unmkpp, spline, pchip.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Evaluate the piecewise polynomial structure PP at the points XI.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ppder


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 252
 -- Function File: ppd = ppder (pp)
 -- Function File: ppd = ppder (pp, m)
     Compute the piecewise M-th derivative of a piecewise polynomial
     struct PP.  If M is omitted the first derivative is calculated.

     See also: mkpp, ppval, ppint.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Compute the piecewise M-th derivative of a piecewise polynomial  struct PP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ppint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 230
 -- Function File: PPI = ppint (PP)
 -- Function File: PPI = ppint (PP, C)
     Compute the integral of the piecewise polynomial struct PP.  C, if
     given, is the constant of integration.

     See also: mkpp, ppval, ppder.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Compute the integral of the piecewise polynomial struct PP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ppjumps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 244
 -- Function File: JUMPS = ppjumps (PP)
     Evaluate the boundary jumps of a piecewise polynomial.  If there
     are n intervals, and the dimensionality of PP is d, the resulting
     array has dimensions '[d, n-1]'.

     See also: mkpp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Evaluate the boundary jumps of a piecewise polynomial.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
residue


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2404
 -- Function File: [R, P, K, E] = residue (B, A)
 -- Function File: [B, A] = residue (R, P, K)
 -- Function File: [B, A] = residue (R, P, K, E)
     The first calling form computes the partial fraction expansion for
     the quotient of the polynomials, B and A.

          B(s)    M       r(m)         N
          ---- = SUM -------------  + SUM k(i)*s^(N-i)
          A(s)   m=1 (s-p(m))^e(m)    i=1

     where M is the number of poles (the length of the R, P, and E), the
     K vector is a polynomial of order N-1 representing the direct
     contribution, and the E vector specifies the multiplicity of the
     m-th residue's pole.

     For example,

          b = [1, 1, 1];
          a = [1, -5, 8, -4];
          [r, p, k, e] = residue (b, a)
             => r = [-2; 7; 3]
             => p = [2; 2; 1]
             => k = [](0x0)
             => e = [1; 2; 1]

     which represents the following partial fraction expansion

                  s^2 + s + 1       -2        7        3
             ------------------- = ----- + ------- + -----
             s^3 - 5s^2 + 8s - 4   (s-2)   (s-2)^2   (s-1)

     The second calling form performs the inverse operation and computes
     the reconstituted quotient of polynomials, B(s)/A(s), from the
     partial fraction expansion; represented by the residues, poles, and
     a direct polynomial specified by R, P and K, and the pole
     multiplicity E.

     If the multiplicity, E, is not explicitly specified the
     multiplicity is determined by the function 'mpoles'.

     For example:

          r = [-2; 7; 3];
          p = [2; 2; 1];
          k = [1, 0];
          [b, a] = residue (r, p, k)
             => b = [1, -5, 9, -3, 1]
             => a = [1, -5, 8, -4]

          where mpoles is used to determine e = [1; 2; 1]

     Alternatively the multiplicity may be defined explicitly, for
     example,

          r = [7; 3; -2];
          p = [2; 1; 2];
          k = [1, 0];
          e = [2; 1; 1];
          [b, a] = residue (r, p, k, e)
             => b = [1, -5, 9, -3, 1]
             => a = [1, -5, 8, -4]

     which represents the following partial fraction expansion

           -2        7        3         s^4 - 5s^3 + 9s^2 - 3s + 1
          ----- + ------- + ----- + s = --------------------------
          (s-2)   (s-2)^2   (s-1)          s^3 - 5s^2 + 8s - 4

     See also: mpoles, poly, roots, conv, deconv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
The first calling form computes the partial fraction expansion for  the quotient of the polynomials, B and A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
roots


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 487
 -- Function File: roots (V)

     For a vector V with N components, return the roots of the
     polynomial

          v(1) * z^(N-1) + ... + v(N-1) * z + v(N)

     As an example, the following code finds the roots of the quadratic
     polynomial

          p(x) = x^2 - 5.

          c = [1, 0, -5];
          roots (c)
          =>  2.2361
          => -2.2361

     Note that the true result is +/- sqrt(5) which is roughly +/-
     2.2361.

     See also: poly, compan, fzero.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
For a vector V with N components, return the roots of the  polynomial 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
spline


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1331
 -- Function File: PP = spline (X, Y)
 -- Function File: YI = spline (X, Y, XI)
     Return the cubic spline interpolant of points X and Y.

     When called with two arguments, return the piecewise polynomial PP
     that may be used with 'ppval' to evaluate the polynomial at
     specific points.  When called with a third input argument, 'spline'
     evaluates the spline at the points XI.  The third calling form
     'spline (X, Y, XI)' is equivalent to 'ppval (spline (X, Y), XI)'.

     The variable X must be a vector of length N.  Y can be either a
     vector or array.  If Y is a vector it must have a length of either
     N or 'N + 2'.  If the length of Y is N, then the "not-a-knot" end
     condition is used.  If the length of Y is 'N + 2', then the first
     and last values of the vector Y are the values of the first
     derivative of the cubic spline at the endpoints.

     If Y is an array, then the size of Y must have the form '[S1, S2,
     ..., SK, N]' or '[S1, S2, ..., SK, N + 2]'.  The array is reshaped
     internally to a matrix where the leading dimension is given by 'S1
     * S2 * ... * SK' and each row of this matrix is then treated
     separately.  Note that this is exactly opposite to 'interp1' but is
     done for MATLAB compatibility.

     See also: pchip, ppval, mkpp, unmkpp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Return the cubic spline interpolant of points X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
splinefit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2809
 -- Function File: PP = splinefit (X, Y, BREAKS)
 -- Function File: PP = splinefit (X, Y, P)
 -- Function File: PP = splinefit (..., "periodic", PERIODIC)
 -- Function File: PP = splinefit (..., "robust", ROBUST)
 -- Function File: PP = splinefit (..., "beta", BETA)
 -- Function File: PP = splinefit (..., "order", ORDER)
 -- Function File: PP = splinefit (..., "constraints", CONSTRAINTS)

     Fit a piecewise cubic spline with breaks (knots) BREAKS to the
     noisy data, X and Y.  X is a vector, and Y is a vector or N-D
     array.  If Y is an N-D array, then X(j) is matched to Y(:,...,:,j).

     The fitted spline is returned as a piecewise polynomial, PP, and
     may be evaluated using 'ppval'.

     P is a positive integer defining the number of intervals along X,
     and P+1 is the number of breaks.  The number of points in each
     interval differ by no more than 1.

     The optional property PERIODIC is a logical value which specifies
     whether a periodic boundary condition is applied to the spline.
     The length of the period is 'max (BREAKS) - min (BREAKS)'.  The
     default value is 'false'.

     The optional property ROBUST is a logical value which specifies if
     robust fitting is to be applied to reduce the influence of outlying
     data points.  Three iterations of weighted least squares are
     performed.  Weights are computed from previous residuals.  The
     sensitivity of outlier identification is controlled by the property
     BETA.  The value of BETA is stricted to the range, 0 < BETA < 1.
     The default value is BETA = 1/2.  Values close to 0 give all data
     equal weighting.  Increasing values of BETA reduce the influence of
     outlying data.  Values close to unity may cause instability or rank
     deficiency.

     The splines are constructed of polynomials with degree ORDER.  The
     default is a cubic, ORDER=3.  A spline with P pieces has P+ORDER
     degrees of freedom.  With periodic boundary conditions the degrees
     of freedom are reduced to P.

     The optional property, CONSTAINTS, is a structure specifying linear
     constraints on the fit.  The structure has three fields, "xc",
     "yc", and "cc".

     "xc"
          Vector of the x-locations of the constraints.

     "yc"
          Constraining values at the locations XC.  The default is an
          array of zeros.

     "cc"
          Coefficients (matrix).  The default is an array of ones.  The
          number of rows is limited to the order of the piecewise
          polynomials, ORDER.

     Constraints are linear combinations of derivatives of order 0 to
     ORDER-1 according to

          cc(1,j) * y(xc(j)) + cc(2,j) * y'(xc(j)) + ... = yc(:,...,:,j).

     See also: interp1, unmkpp, ppval, spline, pchip, ppder, ppint,
     ppjumps.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Fit a piecewise cubic spline with breaks (knots) BREAKS to the  noisy data, X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
unmkpp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 706
 -- Function File: [X, P, N, K, D] = unmkpp (PP)

     Extract the components of a piecewise polynomial structure PP.  The
     components are:

     X
          Sample points.

     P
          Polynomial coefficients for points in sample interval.  'P (I,
          :)' contains the coefficients for the polynomial over interval
          I ordered from highest to lowest.  If 'D > 1', 'P (R, I, :)'
          contains the coefficients for the r-th polynomial defined on
          interval I.

     N
          Number of polynomial pieces.

     K
          Order of the polynomial plus 1.

     D
          Number of polynomials defined for each interval.

     See also: mkpp, ppval, spline, pchip.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Extract the components of a piecewise polynomial structure PP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
__splinefit__ This function is private because it is maintained by


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 158
Jonas Lundgren separtely from Octave.  Please do not reformat to match
Octave coding conventions as that would make it harder to integrate
upstream changes.  


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Jonas Lundgren separtely from Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
addpref


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 509
 -- Function File: addpref (GROUP, PREF, VAL)
     Add a preference PREF and associated value VAL to the named
     preference group GROUP.

     The named preference group must be a character string.

     The preference PREF may be a character string or a cell array of
     character strings.  The corresponding value VAL may be any value,
     or, if PREF is a cell array of strings, VAL must be a cell array of
     values with the same size as PREF.

     See also: setpref, getpref, ispref, rmpref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Add a preference PREF and associated value VAL to the named  preference group GROUP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
getpref


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 868
 -- Function File: getpref (GROUP, PREF, DEFAULT)
     Return the preference value corresponding to the named preference
     PREF in the preference group GROUP.

     The named preference group must be a character string.

     If PREF does not exist in GROUP and DEFAULT is specified, return
     DEFAULT.

     The preference PREF may be a character string or a cell array of
     character strings.  The corresponding default value DEFAULT may be
     any value, or, if PREF is a cell array of strings, DEFAULT must be
     a cell array of values with the same size as PREF.

     If neither PREF nor DEFAULT are specified, return a structure of
     preferences for the preference group GROUP.

     If no arguments are specified, return a structure containing all
     groups of preferences and their values.

     See also: addpref, setpref, ispref, rmpref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
Return the preference value corresponding to the named preference  PREF in the preference group GROUP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ispref


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 426
 -- Function File: ispref (GROUP, PREF)
     Return true if the named preference PREF exists in the preference
     group GROUP.

     The named preference group must be a character string.

     The preference PREF may be a character string or a cell array of
     character strings.

     If PREF is not specified, return true if the preference group GROUP
     exists.

     See also: getpref, addpref, setpref, rmpref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Return true if the named preference PREF exists in the preference  group GROUP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
prefdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 316
 -- Command: prefdir
 -- Command: DIR = prefdir
     Return the directory that contains the preferences for Octave.

     Examples:

     Display the preferences directory

          prefdir

     Change to the preferences folder

          cd (prefdir)

     See also: getpref, setpref, addpref, rmpref, ispref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return the directory that contains the preferences for Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
preferences


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
 -- Command: preferences
     Display the GUI preferences dialog window for Octave.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Display the GUI preferences dialog window for Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rmpref


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 476
 -- Function File: rmpref (GROUP)
 -- Function File: rmpref (GROUP, PREF)
     Remove the named preference PREF from the preference group GROUP.

     The named preference group must be a character string.

     The preference PREF may be a character string or cell array of
     strings.

     If PREF is not specified, remove the preference group GROUP.

     It is an error to remove a nonexistent preference or group.

     See also: addpref, ispref, setpref, getpref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Remove the named preference PREF from the preference group GROUP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
setpref


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 569
 -- Function File: setpref (GROUP, PREF, VAL)
     Set a preference PREF to the given VAL in the named preference
     group GROUP.

     The named preference group must be a character string.

     The preference PREF may be a character string or a cell array of
     character strings.  The corresponding value VAL may be any value,
     or, if PREF is a cell array of strings, VAL must be a cell array of
     values with the same size as PREF.

     If the named preference or group does not exist, it is added.

     See also: addpref, getpref, ispref, rmpref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Set a preference PREF to the given VAL in the named preference  group GROUP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
loadprefs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
 -- Function File: loadprefs ()
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
prefsfile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
 -- Function File: prefsfile ()
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
saveprefs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
 -- Function File: saveprefs ()
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
intersect


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 424
 -- Function File: intersect (A, B)
 -- Function File: [C, IA, IB] = intersect (A, B)

     Return the elements in both A and B, sorted in ascending order.  If
     A and B are both column vectors return a column vector, otherwise
     return a row vector.  A, B may be cell arrays of string(s).

     Return index vectors IA and IB such that 'a(ia)==c' and 'b(ib)==c'.

See also: unique, union, setxor, setdiff, ismember.  


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return the elements in both A and B, sorted in ascending order.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ismember


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1168
 -- Function File: TF = ismember (A, S)
 -- Function File: [TF, S_IDX] = ismember (A, S)
 -- Function File: [TF, S_IDX] = ismember (A, S, "rows")
     Return a logical matrix TF with the same shape as A which is true
     (1) if 'A(i,j)' is in S and false (0) if it is not.  If a second
     output argument is requested, the index into S of each of the
     matching elements is also returned.

          a = [3, 10, 1];
          s = [0:9];
          [tf, s_idx] = ismember (a, s)
               => tf = [1, 0, 1]
               => s_idx = [4, 0, 2]

     The inputs, A and S, may also be cell arrays.

          a = {"abc"};
          s = {"abc", "def"};
          [tf, s_idx] = ismember (a, s)
               => tf = [1, 0]
               => s_idx = [1, 0]

     With the optional third argument "rows", and matrices A and S with
     the same number of columns, compare rows in A with the rows in S.

          a = [1:3; 5:7; 4:6];
          s = [0:2; 1:3; 2:4; 3:5; 4:6];
          [tf, s_idx] = ismember (a, s, "rows")
               => tf = logical ([1; 0; 1])
               => s_idx = [2; 0; 5];

     See also: unique, union, intersect, setxor, setdiff.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 118
Return a logical matrix TF with the same shape as A which is true  (1) if 'A(i,j)' is in S and false (0) if it is not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
powerset


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 508
 -- Function File: powerset (A)
 -- Function File: powerset (A, "rows")
     Compute the powerset (all subsets) of the set A.

     The set A must be a numerical matrix or a cell array of strings.
     The output will always be a cell array of either vectors or
     strings.

     With the optional second argument "rows", each row of the set A is
     considered one element of the set.  As a result, A must then be a
     numerical 2-D matrix.

     See also: unique, union, setxor, setdiff, ismember.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Compute the powerset (all subsets) of the set A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
setdiff


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 582
 -- Function File: setdiff (A, B)
 -- Function File: setdiff (A, B, "rows")
 -- Function File: [C, I] = setdiff (A, B)
     Return the elements in A that are not in B, sorted in ascending
     order.  If A and B are both column vectors return a column vector,
     otherwise return a row vector.  A, B may be cell arrays of
     string(s).

     Given the optional third argument "rows", return the rows in A that
     are not in B, sorted in ascending order by rows.

     If requested, return I such that 'c = a(i)'.

     See also: unique, union, intersect, setxor, ismember.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Return the elements in A that are not in B, sorted in ascending  order.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
setxor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 540
 -- Function File: setxor (A, B)
 -- Function File: setxor (A, B, "rows")
 -- Function File: [C, IA, IB] = setxor (A, B)

     Return the elements exclusive to A or B, sorted in ascending order.
     If A and B are both column vectors return a column vector,
     otherwise return a row vector.  A, B may be cell arrays of
     string(s).

     With three output arguments, return index vectors IA and IB such
     that 'a(ia)' and 'b(ib)' are disjoint sets whose union is C.

     See also: unique, union, intersect, setdiff, ismember.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Return the elements exclusive to A or B, sorted in ascending order.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
union


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 785
 -- Function File: union (A, B)
 -- Function File: union (A, B, "rows")
 -- Function File: [C, IA, IB] = union (A, B)

     Return the set of elements that are in either of the sets A and B.
     A, B may be cell arrays of strings.  For example:

          union ([1, 2, 4], [2, 3, 5])
              => [1, 2, 3, 4, 5]

     If the optional third input argument is the string "rows" then each
     row of the matrices A and B will be considered as a single set
     element.  For example:

          union ([1, 2; 2, 3], [1, 2; 3, 4], "rows")
             =>  1   2
                 2   3
                 3   4

     The optional outputs IA and IB are index vectors such that 'a(ia)'
     and 'b(ib)' are disjoint sets whose union is C.

     See also: intersect, setdiff, unique.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Return the set of elements that are in either of the sets A and B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
unique


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1022
 -- Function File: unique (X)
 -- Function File: unique (X, "rows")
 -- Function File: unique (..., "first")
 -- Function File: unique (..., "last")
 -- Function File: [Y, I, J] = unique (...)
     Return the unique elements of X, sorted in ascending order.  If the
     input X is a vector then the output is also a vector with the same
     orientation (row or column) as the input.  For a matrix input the
     output is always a column vector.  X may also be a cell array of
     strings.

     If the optional argument "rows" is supplied, return the unique rows
     of X, sorted in ascending order.

     If requested, return index vectors I and J such that 'x(i)==y' and
     'y(j)==x'.

     Additionally, if I is a requested output then one of "first" or
     "last" may be given as an input.  If "last" is specified, return
     the highest possible indices in I, otherwise, if "first" is
     specified, return the lowest.  The default is "last".

     See also: union, intersect, setdiff, setxor, ismember.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Return the unique elements of X, sorted in ascending order.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
arch_fit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 894
 -- Function File: [A, B] = arch_fit (Y, X, P, ITER, GAMMA, A0, B0)
     Fit an ARCH regression model to the time series Y using the scoring
     algorithm in Engle's original ARCH paper.  The model is

          y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),
          h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(p+1) * e(t-p)^2

     in which e(t) is N(0, h(t)), given a time-series vector Y up to
     time t-1 and a matrix of (ordinary) regressors X up to t.  The
     order of the regression of the residual variance is specified by P.

     If invoked as 'arch_fit (Y, K, P)' with a positive integer K, fit
     an ARCH(K, P) process, i.e., do the above with the t-th row of X
     given by

          [1, y(t-1), ..., y(t-k)]

     Optionally, one can specify the number of iterations ITER, the
     updating factor GAMMA, and initial values a0 and b0 for the scoring
     algorithm.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
Fit an ARCH regression model to the time series Y using the scoring  algorithm in Engle's original ARCH paper.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
arch_rnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 380
 -- Function File: arch_rnd (A, B, T)
     Simulate an ARCH sequence of length T with AR coefficients B and CH
     coefficients A.  I.e., the result y(t) follows the model

          y(t) = b(1) + b(2) * y(t-1) + ... + b(lb) * y(t-lb+1) + e(t),

     where e(t), given Y up to time t-1, is N(0, h(t)), with

          h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(la) * e(t-la+1)^2
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Simulate an ARCH sequence of length T with AR coefficients B and CH  coefficients A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
arch_test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 969
 -- Function File: [PVAL, LM] = arch_test (Y, X, P)
     For a linear regression model

          y = x * b + e

     perform a Lagrange Multiplier (LM) test of the null hypothesis of
     no conditional heteroscedascity against the alternative of CH(P).

     I.e., the model is

          y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),

     given Y up to t-1 and X up to t, e(t) is N(0, h(t)) with

          h(t) = v + a(1) * e(t-1)^2 + ... + a(p) * e(t-p)^2,

     and the null is a(1) == ... == a(p) == 0.

     If the second argument is a scalar integer, k, perform the same
     test in a linear autoregression model of order k, i.e., with

          [1, y(t-1), ..., y(t-K)]

     as the t-th row of X.

     Under the null, LM approximately has a chisquare distribution with
     P degrees of freedom and PVAL is the p-value (1 minus the CDF of
     this distribution at LM) of the test.

     If no output argument is given, the p-value is displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
For a linear regression model 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
arma_rnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 581
 -- Function File: arma_rnd (A, B, V, T, N)
     Return a simulation of the ARMA model

          x(n) = a(1) * x(n-1) + ... + a(k) * x(n-k)
               + e(n) + b(1) * e(n-1) + ... + b(l) * e(n-l)

     in which K is the length of vector A, L is the length of vector B
     and E is Gaussian white noise with variance V.  The function
     returns a vector of length T.

     The optional parameter N gives the number of dummy X(I) used for
     initialization, i.e., a sequence of length T+N is generated and
     X(N+1:T+N) is returned.  If N is omitted, N = 100 is used.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return a simulation of the ARMA model 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
autoreg_matrix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 356
 -- Function File: autoreg_matrix (Y, K)
     Given a time series (vector) Y, return a matrix with ones in the
     first column and the first K lagged values of Y in the other
     columns.  I.e., for T > K, '[1, Y(T-1), ..., Y(T-K)]' is the t-th
     row of the result.  The resulting matrix may be used as a regressor
     matrix in autoregressions.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 136
Given a time series (vector) Y, return a matrix with ones in the  first column and the first K lagged values of Y in the other  columns.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
bartlett


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 253
 -- Function File: bartlett (M)
     Return the filter coefficients of a Bartlett (triangular) window of
     length M.

     For a definition of the Bartlett window, see e.g., A. V. Oppenheim
     & R. W. Schafer, 'Discrete-Time Signal Processing'.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Return the filter coefficients of a Bartlett (triangular) window of  length M.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
blackman


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 235
 -- Function File: blackman (M)
     Return the filter coefficients of a Blackman window of length M.

     For a definition of the Blackman window, see e.g., A. V. Oppenheim
     & R. W. Schafer, 'Discrete-Time Signal Processing'.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return the filter coefficients of a Blackman window of length M.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
detrend


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 570
 -- Function File: detrend (X, P)
     If X is a vector, 'detrend (X, P)' removes the best fit of a
     polynomial of order P from the data X.

     If X is a matrix, 'detrend (X, P)' does the same for each column in
     X.

     The second argument is optional.  If it is not specified, a value
     of 1 is assumed.  This corresponds to removing a linear trend.

     The order of the polynomial can also be given as a string, in which
     case P must be either "constant" (corresponds to 'P=0') or "linear"
     (corresponds to 'P=1').

     See also: polyfit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
If X is a vector, 'detrend (X, P)' removes the best fit of a  polynomial of order P from the data X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
diffpara


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 732
 -- Function File: [D, DD] = diffpara (X, A, B)
     Return the estimator D for the differencing parameter of an
     integrated time series.

     The frequencies from [2*pi*a/t, 2*pi*b/T] are used for the
     estimation.  If B is omitted, the interval [2*pi/T, 2*pi*a/T] is
     used.  If both B and A are omitted then a = 0.5 * sqrt (T) and b =
     1.5 * sqrt (T) is used, where T is the sample size.  If X is a
     matrix, the differencing parameter of each column is estimated.

     The estimators for all frequencies in the intervals described above
     is returned in DD.  The value of D is simply the mean of DD.

     Reference: P.J. Brockwell & R.A. Davis.  'Time Series: Theory and
     Methods'.  Springer 1987.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Return the estimator D for the differencing parameter of an  integrated time series.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
durbinlevinson


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 404
 -- Function File: durbinlevinson (C, OLDPHI, OLDV)
     Perform one step of the Durbin-Levinson algorithm.

     The vector C specifies the autocovariances '[gamma_0, ...,
     gamma_t]' from lag 0 to T, OLDPHI specifies the coefficients based
     on C(T-1) and OLDV specifies the corresponding error.

     If OLDPHI and OLDV are omitted, all steps from 1 to T of the
     algorithm are performed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Perform one step of the Durbin-Levinson algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
fftconv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 550
 -- Function File: fftconv (X, Y)
 -- Function File: fftconv (X, Y, N)
     Convolve two vectors using the FFT for computation.

     'c = fftconv (X, Y)' returns a vector of length equal to 'length
     (X) + length (Y) - 1'.  If X and Y are the coefficient vectors of
     two polynomials, the returned value is the coefficient vector of
     the product polynomial.

     The computation uses the FFT by calling the function 'fftfilt'.  If
     the optional argument N is specified, an N-point FFT is used.

     See also: deconv, conv, conv2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Convolve two vectors using the FFT for computation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
fftfilt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 607
 -- Function File: fftfilt (B, X)
 -- Function File: fftfilt (B, X, N)

     With two arguments, 'fftfilt' filters X with the FIR filter B using
     the FFT.

     Given the optional third argument, N, 'fftfilt' uses the
     overlap-add method to filter X with B using an N-point FFT.  The
     FFT size must be an even power of 2 and must be greater than or
     equal to the length of B.  If the specified N does not meet these
     criteria, it is automatically adjusted to the nearest value that
     does.

     If X is a matrix, filter each column of the matrix.

     See also: filter, filter2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
With two arguments, 'fftfilt' filters X with the FIR filter B using  the FFT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
fftshift


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 707
 -- Function File: fftshift (X)
 -- Function File: fftshift (X, DIM)
     Perform a shift of the vector X, for use with the 'fft' and 'ifft'
     functions, in order the move the frequency 0 to the center of the
     vector or matrix.

     If X is a vector of N elements corresponding to N time samples
     spaced by dt, then 'fftshift (fft (X))' corresponds to frequencies

          f = [ -(ceil((N-1)/2):-1:1)*df 0 (1:floor((N-1)/2))*df ]

     where df = 1 / dt.

     If X is a matrix, the same holds for rows and columns.  If X is an
     array, then the same holds along each dimension.

     The optional DIM argument can be used to limit the dimension along
     which the permutation occurs.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
Perform a shift of the vector X, for use with the 'fft' and 'ifft'  functions, in order the move the frequency 0 to the center of the  vector or matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
filter2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 562
 -- Function File: Y = filter2 (B, X)
 -- Function File: Y = filter2 (B, X, SHAPE)
     Apply the 2-D FIR filter B to X.  If the argument SHAPE is
     specified, return an array of the desired shape.  Possible values
     are:

     "full"
          pad X with zeros on all sides before filtering.

     "same"
          unpadded X (default)

     "valid"
          trim X after filtering so edge effects are no included.

     Note this is just a variation on convolution, with the parameters
     reversed and B rotated 180 degrees.

     See also: conv2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Apply the 2-D FIR filter B to X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
fractdiff


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
 -- Function File: fractdiff (X, D)
     Compute the fractional differences (1-L)^d x where L denotes the
     lag-operator and d is greater than -1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
Compute the fractional differences (1-L)^d x where L denotes the  lag-operator and d is greater than -1.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
freqz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1463
 -- Function File: [H, W] = freqz (B, A, N, "whole")
 -- Function File: [H, W] = freqz (B)
 -- Function File: [H, W] = freqz (B, A)
 -- Function File: [H, W] = freqz (B, A, N)
 -- Function File: H = freqz (B, A, W)
 -- Function File: [...] = freqz (..., FS)
 -- Function File: freqz (...)

     Return the complex frequency response H of the rational IIR filter
     whose numerator and denominator coefficients are B and A,
     respectively.  The response is evaluated at N angular frequencies
     between 0 and 2*pi.

     The output value W is a vector of the frequencies.

     If A is omitted, the denominator is assumed to be 1 (this
     corresponds to a simple FIR filter).

     If N is omitted, a value of 512 is assumed.  For fastest
     computation, N should factor into a small number of small primes.

     If the fourth argument, "whole", is omitted the response is
     evaluated at frequencies between 0 and pi.

     'freqz (B, A, W)'

     Evaluate the response at the specific frequencies in the vector W.
     The values for W are measured in radians.

     '[...] = freqz (..., FS)'

     Return frequencies in Hz instead of radians assuming a sampling
     rate FS.  If you are evaluating the response at specific
     frequencies W, those frequencies should be requested in Hz rather
     than radians.

     'freqz (...)'

     Plot the magnitude and phase response of H rather than returning
     them.

     See also: freqz_plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 140
Return the complex frequency response H of the rational IIR filter  whose numerator and denominator coefficients are B and A,  respectively.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
freqz_plot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 345
 -- Function File: freqz_plot (W, H)
 -- Function File: freqz_plot (W, H, FREQ_NORM)
     Plot the magnitude and phase response of H.

     If the optional FREQ_NORM argument is true, the frequency vector W
     is in units of normalized radians.  If FREQ_NORM is false, or not
     given, then W is measured in Hertz.

     See also: freqz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Plot the magnitude and phase response of H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hamming


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 232
 -- Function File: hamming (M)
     Return the filter coefficients of a Hamming window of length M.

     For a definition of the Hamming window, see e.g., A. V. Oppenheim &
     R. W. Schafer, 'Discrete-Time Signal Processing'.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return the filter coefficients of a Hamming window of length M.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hanning


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 230
 -- Function File: hanning (M)
     Return the filter coefficients of a Hanning window of length M.

     For a definition of this window type, see e.g., A. V. Oppenheim &
     R. W. Schafer, 'Discrete-Time Signal Processing'.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return the filter coefficients of a Hanning window of length M.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
hurst


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 193
 -- Function File: hurst (X)
     Estimate the Hurst parameter of sample X via the rescaled range
     statistic.  If X is a matrix, the parameter is estimated for every
     single column.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Estimate the Hurst parameter of sample X via the rescaled range  statistic.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
ifftshift


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 212
 -- Function File: ifftshift (X)
 -- Function File: ifftshift (X, DIM)
     Undo the action of the 'fftshift' function.  For even length X,
     'fftshift' is its own inverse, but odd lengths differ slightly.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Undo the action of the 'fftshift' function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
periodogram


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1266
 -- Function File: [Pxx, W] = periodogram (X)
     For a data matrix X from a sample of size N, return the
     periodogram.  The angular frequency is returned in W.

     [Pxx,w] = periodogram (X).

     [Pxx,w] = periodogram (X,win).

     [Pxx,w] = periodogram (X,win,nfft).

     [Pxx,f] = periodogram (X,win,nfft,Fs).

     [Pxx,f] = periodogram (X,win,nfft,Fs,"range").

        * x: data; if real-valued a one-sided spectrum is estimated, if
          complex-valued or range indicates "twosided", the full
          spectrum is estimated.

        * win: weight data with window, x.*win is used for further
          computation, if window is empty, a rectangular window is used.

        * nfft: number of frequency bins, default max (256, 2.^ceil
          (log2 (length (x)))).

        * Fs: sampling rate, default 1.

        * range: "onesided" computes spectrum from [0..nfft/2+1].
          "twosided" computes spectrum from [0..nfft-1].  These strings
          can appear at any position in the list input arguments after
          window.

        * Pxx: one-, or two-sided power spectrum.

        * w: angular frequency [0..2*pi) (two-sided) or [0..pi]
          one-sided.

        * f: frequency [0..Fs) (two-sided) or [0..Fs/2] one-sided.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
For a data matrix X from a sample of size N, return the  periodogram.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sinc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
 -- Function File: sinc (X)
     Return sin (pi*x) / (pi*x).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Return sin (pi*x) / (pi*x).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
sinetone


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 295
 -- Function File: sinetone (FREQ, RATE, SEC, AMPL)
     Return a sinetone of frequency FREQ with length of SEC seconds at
     sampling rate RATE and with amplitude AMPL.  The arguments FREQ and
     AMPL may be vectors of common size.

     Defaults are RATE = 8000, SEC = 1 and AMPL = 64.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
Return a sinetone of frequency FREQ with length of SEC seconds at  sampling rate RATE and with amplitude AMPL.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
sinewave


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 204
 -- Function File: sinewave (M, N, D)
     Return an M-element vector with I-th element given by 'sin (2 * pi
     * (I+D-1) / N)'.

     The default value for D is 0 and the default value for N is M.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Return an M-element vector with I-th element given by 'sin (2 * pi  * (I+D-1) / N)'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
spectral_adf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 494
 -- Function File: spectral_adf (C)
 -- Function File: spectral_adf (C, WIN)
 -- Function File: spectral_adf (C, WIN, B)
     Return the spectral density estimator given a vector of
     autocovariances C, window name WIN, and bandwidth, B.

     The window name, e.g., "triangle" or "rectangle" is used to search
     for a function called 'WIN_lw'.

     If WIN is omitted, the triangle window is used.  If B is omitted,
     '1 / sqrt (length (X))' is used.

     See also: spectral_xdf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
Return the spectral density estimator given a vector of  autocovariances C, window name WIN, and bandwidth, B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
spectral_xdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 480
 -- Function File: spectral_xdf (X)
 -- Function File: spectral_xdf (X, WIN)
 -- Function File: spectral_xdf (X, WIN, B)
     Return the spectral density estimator given a data vector X, window
     name WIN, and bandwidth, B.

     The window name, e.g., "triangle" or "rectangle" is used to search
     for a function called 'WIN_sw'.

     If WIN is omitted, the triangle window is used.  If B is omitted,
     '1 / sqrt (length (X))' is used.

     See also: spectral_adf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Return the spectral density estimator given a data vector X, window  name WIN, and bandwidth, B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
spencer


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
 -- Function File: spencer (X)
     Return Spencer's 15 point moving average of each column of X.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Return Spencer's 15 point moving average of each column of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
stft


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1244
 -- Function File: Y = stft (X)
 -- Function File: Y = stft (X, WIN_SIZE)
 -- Function File: Y = stft (X, WIN_SIZE, INC)
 -- Function File: Y = stft (X, WIN_SIZE, INC, NUM_COEF)
 -- Function File: Y = stft (X, WIN_SIZE, INC, NUM_COEF, WIN_TYPE)
 -- Function File: [Y, C] = stft (...)
     Compute the short-time Fourier transform of the vector X with
     NUM_COEF coefficients by applying a window of WIN_SIZE data points
     and an increment of INC points.

     Before computing the Fourier transform, one of the following
     windows is applied:

     "hanning"
          win_type = 1

     "hamming"
          win_type = 2

     "rectangle"
          win_type = 3

     The window names can be passed as strings or by the WIN_TYPE
     number.

     The following defaults are used for unspecified arguments: WIN_SIZE
     = 80, INC = 24, NUM_COEF = 64, and WIN_TYPE = 1.

     'Y = stft (X, ...)' returns the absolute values of the Fourier
     coefficients according to the NUM_COEF positive frequencies.

     '[Y, C] = stft (x, ...)' returns the entire STFT-matrix Y and a
     3-element vector C containing the window size, increment, and
     window type, which is needed by the 'synthesis' function.

     See also: synthesis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 162
Compute the short-time Fourier transform of the vector X with  NUM_COEF coefficients by applying a window of WIN_SIZE data points  and an increment of INC points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
synthesis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 292
 -- Function File: X = synthesis (Y, C)
     Compute a signal from its short-time Fourier transform Y and a
     3-element vector C specifying window size, increment, and window
     type.

     The values Y and C can be derived by

          [Y, C] = stft (X , ...)

     See also: stft.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
Compute a signal from its short-time Fourier transform Y and a  3-element vector C specifying window size, increment, and window  type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
unwrap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 376
 -- Function File: B = unwrap (X)
 -- Function File: B = unwrap (X, TOL)
 -- Function File: B = unwrap (X, TOL, DIM)

     Unwrap radian phases by adding multiples of 2*pi as appropriate to
     remove jumps greater than TOL.  TOL defaults to pi.

     Unwrap will work along the dimension DIM.  If DIM is unspecified it
     defaults to the first non-singleton dimension.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Unwrap radian phases by adding multiples of 2*pi as appropriate to  remove jumps greater than TOL.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
yulewalker


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 240
 -- Function File: [A, V] = yulewalker (C)
     Fit an AR (p)-model with Yule-Walker estimates given a vector C of
     autocovariances '[gamma_0, ..., gamma_p]'.

     Returns the AR coefficients, A, and the variance of white noise, V.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Fit an AR (p)-model with Yule-Walker estimates given a vector C of  autocovariances '[gamma_0, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
rectangle_lw


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
 -- Function File: rectangle_lw (N, B)
     Rectangular lag window.  Subfunction used for spectral density
     estimation.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Rectangular lag window.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
rectangle_sw


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
 -- Function File: rectangle_sw (N, B)
     Rectangular spectral window.  Subfunction used for spectral density
     estimation.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Rectangular spectral window.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
triangle_lw


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
 -- Function File: triangle_lw (N, B)
     Triangular lag window.  Subfunction used for spectral density
     estimation.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Triangular lag window.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
triangle_sw


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 130
 -- Function File: triangle_sw (N, B)
     Triangular spectral window.  Subfunction used for spectral density
     estimation.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Triangular spectral window.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
bicg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1706
 -- Function File: X = bicg (A, B, RTOL, MAXIT, M1, M2, X0)
 -- Function File: X = bicg (A, B, RTOL, MAXIT, P)
 -- Function File: [X, FLAG, RELRES, ITER, RESVEC] = bicg (A, B, ...)
     Solve 'A x = b' using the Bi-conjugate gradient iterative method.

        - RTOL is the relative tolerance, if not given or set to [] the
          default value 1e-6 is used.

        - MAXIT the maximum number of outer iterations, if not given or
          set to [] the default value 'min (20, numel (b))' is used.

        - X0 the initial guess, if not given or set to [] the default
          value 'zeros (size (b))' is used.

     A can be passed as a matrix or as a function handle or inline
     function 'f' such that 'f(x, "notransp") = A*x' and 'f(x, "transp")
     = A'*x'.

     The preconditioner P is given as 'P = M1 * M2'.  Both M1 and M2 can
     be passed as a matrix or as a function handle or inline function
     'g' such that 'g(x, "notransp") = M1 \ x' or 'g(x, "notransp") = M2
     \ x' and 'g(x, "transp") = M1' \ x' or 'g(x, "transp") = M2' \ x'.

     If called with more than one output parameter

        - FLAG indicates the exit status:

             - 0: iteration converged to the within the chosen tolerance

             - 1: the maximum number of iterations was reached before
               convergence

             - 3: the algorithm reached stagnation

          (the value 2 is unused but skipped for compatibility).

        - RELRES is the final value of the relative residual.

        - ITER is the number of iterations performed.

        - RESVEC is a vector containing the relative residual at each
          iteration.

     See also: bicgstab, cgs, gmres, pcg.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Solve 'A x = b' using the Bi-conjugate gradient iterative method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
bicgstab


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1606
 -- Function File: X = bicgstab (A, B, RTOL, MAXIT, M1, M2, X0)
 -- Function File: X = bicgstab (A, B, RTOL, MAXIT, P)
 -- Function File: [X, FLAG, RELRES, ITER, RESVEC] = bicgstab (A, B,
          ...)
     Solve 'A x = b' using the stabilizied Bi-conjugate gradient
     iterative method.

        - RTOL is the relative tolerance, if not given or set to [] the
          default value 1e-6 is used.

        - MAXIT the maximum number of outer iterations, if not given or
          set to [] the default value 'min (20, numel (b))' is used.

        - X0 the initial guess, if not given or set to [] the default
          value 'zeros (size (b))' is used.

     A can be passed as a matrix or as a function handle or inline
     function 'f' such that 'f(x) = A*x'.

     The preconditioner P is given as 'P = M1 * M2'.  Both M1 and M2 can
     be passed as a matrix or as a function handle or inline function
     'g' such that 'g(x) = M1 \ x' or 'g(x) = M2 \ x'.

     If called with more than one output parameter

        - FLAG indicates the exit status:

             - 0: iteration converged to the within the chosen tolerance

             - 1: the maximum number of iterations was reached before
               convergence

             - 3: the algorithm reached stagnation

          (the value 2 is unused but skipped for compatibility).

        - RELRES is the final value of the relative residual.

        - ITER is the number of iterations performed.

        - RESVEC is a vector containing the relative residual at each
          iteration.

     See also: bicg, cgs, gmres, pcg.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
cgs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1598
 -- Function File: X = cgs (A, B, RTOL, MAXIT, M1, M2, X0)
 -- Function File: X = cgs (A, B, RTOL, MAXIT, P)
 -- Function File: [X, FLAG, RELRES, ITER, RESVEC] = cgs (A, B, ...)
     Solve 'A x = b', where A is a square matrix, using the Conjugate
     Gradients Squared method.

        - RTOL is the relative tolerance, if not given or set to [] the
          default value 1e-6 is used.

        - MAXIT the maximum number of outer iterations, if not given or
          set to [] the default value 'min (20, numel (b))' is used.

        - X0 the initial guess, if not given or set to [] the default
          value 'zeros (size (b))' is used.

     A can be passed as a matrix or as a function handle or inline
     function 'f' such that 'f(x) = A*x'.

     The preconditioner P is given as 'P = M1 * M2'.  Both M1 and M2 can
     be passed as a matrix or as a function handle or inline function
     'g' such that 'g(x) = M1 \ x' or 'g(x) = M2 \ x'.

     If called with more than one output parameter

        - FLAG indicates the exit status:

             - 0: iteration converged to the within the chosen tolerance

             - 1: the maximum number of iterations was reached before
               convergence

             - 3: the algorithm reached stagnation

          (the value 2 is unused but skipped for compatibility).

        - RELRES is the final value of the relative residual.

        - ITER is the number of iterations performed.

        - RESVEC is a vector containing the relative residual at each
          iteration.

     See also: pcg, bicgstab, bicg, gmres.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
Solve 'A x = b', where A is a square matrix, using the Conjugate  Gradients Squared method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
colperm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 319
 -- Function File: P = colperm (S)
     Return the column permutations such that the columns of 'S (:, P)'
     are ordered in terms of increase number of non-zero elements.  If S
     is symmetric, then P is chosen such that 'S (P, P)' orders the rows
     and columns with increasing number of non zeros elements.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
Return the column permutations such that the columns of 'S (:, P)'  are ordered in terms of increase number of non-zero elements.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
eigs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5895
 -- Function File: D = eigs (A)
 -- Function File: D = eigs (A, K)
 -- Function File: D = eigs (A, K, SIGMA)
 -- Function File: D = eigs (A, K, SIGMA, OPTS)
 -- Function File: D = eigs (A, B)
 -- Function File: D = eigs (A, B, K)
 -- Function File: D = eigs (A, B, K, SIGMA)
 -- Function File: D = eigs (A, B, K, SIGMA, OPTS)
 -- Function File: D = eigs (AF, N)
 -- Function File: D = eigs (AF, N, B)
 -- Function File: D = eigs (AF, N, K)
 -- Function File: D = eigs (AF, N, B, K)
 -- Function File: D = eigs (AF, N, K, SIGMA)
 -- Function File: D = eigs (AF, N, B, K, SIGMA)
 -- Function File: D = eigs (AF, N, K, SIGMA, OPTS)
 -- Function File: D = eigs (AF, N, B, K, SIGMA, OPTS)
 -- Function File: [V, D] = eigs (A, ...)
 -- Function File: [V, D] = eigs (AF, N, ...)
 -- Function File: [V, D, FLAG] = eigs (A, ...)
 -- Function File: [V, D, FLAG] = eigs (AF, N, ...)
     Calculate a limited number of eigenvalues and eigenvectors of A,
     based on a selection criteria.  The number of eigenvalues and
     eigenvectors to calculate is given by K and defaults to 6.

     By default, 'eigs' solve the equation 'A * v = lambda * v', where
     'lambda' is a scalar representing one of the eigenvalues, and 'v'
     is the corresponding eigenvector.  If given the positive definite
     matrix B then 'eigs' solves the general eigenvalue equation 'A * v
     = lambda * B * v'.

     The argument SIGMA determines which eigenvalues are returned.
     SIGMA can be either a scalar or a string.  When SIGMA is a scalar,
     the K eigenvalues closest to SIGMA are returned.  If SIGMA is a
     string, it must have one of the following values.

     "lm"
          Largest Magnitude (default).

     "sm"
          Smallest Magnitude.

     "la"
          Largest Algebraic (valid only for real symmetric problems).

     "sa"
          Smallest Algebraic (valid only for real symmetric problems).

     "be"
          Both Ends, with one more from the high-end if K is odd (valid
          only for real symmetric problems).

     "lr"
          Largest Real part (valid only for complex or unsymmetric
          problems).

     "sr"
          Smallest Real part (valid only for complex or unsymmetric
          problems).

     "li"
          Largest Imaginary part (valid only for complex or unsymmetric
          problems).

     "si"
          Smallest Imaginary part (valid only for complex or unsymmetric
          problems).

     If OPTS is given, it is a structure defining possible options that
     'eigs' should use.  The fields of the OPTS structure are:

     'issym'
          If AF is given, then flags whether the function AF defines a
          symmetric problem.  It is ignored if A is given.  The default
          is false.

     'isreal'
          If AF is given, then flags whether the function AF defines a
          real problem.  It is ignored if A is given.  The default is
          true.

     'tol'
          Defines the required convergence tolerance, calculated as 'tol
          * norm (A)'.  The default is 'eps'.

     'maxit'
          The maximum number of iterations.  The default is 300.

     'p'
          The number of Lanzcos basis vectors to use.  More vectors will
          result in faster convergence, but a greater use of memory.
          The optimal value of 'p' is problem dependent and should be in
          the range K to N.  The default value is '2 * K'.

     'v0'
          The starting vector for the algorithm.  An initial vector
          close to the final vector will speed up convergence.  The
          default is for ARPACK to randomly generate a starting vector.
          If specified, 'v0' must be an N-by-1 vector where 'N = rows
          (A)'

     'disp'
          The level of diagnostic printout (0|1|2).  If 'disp' is 0 then
          diagnostics are disabled.  The default value is 0.

     'cholB'
          Flag if 'chol (B)' is passed rather than B.  The default is
          false.

     'permB'
          The permutation vector of the Cholesky factorization of B if
          'cholB' is true.  That is 'chol (B(permB, permB))'.  The
          default is '1:N'.

     It is also possible to represent A by a function denoted AF.  AF
     must be followed by a scalar argument N defining the length of the
     vector argument accepted by AF.  AF can be a function handle, an
     inline function, or a string.  When AF is a string it holds the
     name of the function to use.

     AF is a function of the form 'y = af (x)' where the required return
     value of AF is determined by the value of SIGMA.  The four possible
     forms are

     'A * x'
          if SIGMA is not given or is a string other than "sm".

     'A \ x'
          if SIGMA is 0 or "sm".

     '(A - sigma * I) \ x'
          for the standard eigenvalue problem, where 'I' is the identity
          matrix of the same size as A.

     '(A - sigma * B) \ x'
          for the general eigenvalue problem.

     The return arguments of 'eigs' depend on the number of return
     arguments requested.  With a single return argument, a vector D of
     length K is returned containing the K eigenvalues that have been
     found.  With two return arguments, V is a N-by-K matrix whose
     columns are the K eigenvectors corresponding to the returned
     eigenvalues.  The eigenvalues themselves are returned in D in the
     form of a N-by-K matrix, where the elements on the diagonal are the
     eigenvalues.

     Given a third return argument FLAG, 'eigs' returns the status of
     the convergence.  If FLAG is 0 then all eigenvalues have converged.
     Any other value indicates a failure to converge.

     This function is based on the ARPACK package, written by R.
     Lehoucq, K. Maschhoff, D. Sorensen, and C. Yang.  For more
     information see <http://www.caam.rice.edu/software/ARPACK/>.

     See also: eig, svds.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Calculate a limited number of eigenvalues and eigenvectors of A,  based on a selection criteria.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
etreeplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 290
 -- Function File: etreeplot (A)
 -- Function File: etreeplot (A, NODE_STYLE, EDGE_STYLE)
     Plot the elimination tree of the matrix A or A+A' if A in not
     symmetric.  The optional parameters NODE_STYLE and EDGE_STYLE
     define the output style.

     See also: treeplot, gplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Plot the elimination tree of the matrix A or A+A' if A in not  symmetric.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
gmres


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1758
 -- Function File: X = gmres (A, B, M, RTOL, MAXIT, M1, M2, X0)
 -- Function File: X = gmres (A, B, M, RTOL, MAXIT, P)
 -- Function File: [X, FLAG, RELRES, ITER, RESVEC] = gmres (...)
     Solve 'A x = b' using the Preconditioned GMRES iterative method
     with restart, a.k.a.  PGMRES(m).

        - RTOL is the relative tolerance, if not given or set to [] the
          default value 1e-6 is used.

        - MAXIT is the maximum number of outer iterations, if not given
          or set to [] the default value 'min (10, numel (b) / restart)'
          is used.

        - X0 is the initial guess, if not given or set to [] the default
          value 'zeros (size (b))' is used.

        - M is the restart parameter, if not given or set to [] the
          default value 'numel (b)' is used.

     Argument A can be passed as a matrix, function handle, or inline
     function 'f' such that 'f(x) = A*x'.

     The preconditioner P is given as 'P = M1 * M2'.  Both M1 and M2 can
     be passed as a matrix, function handle, or inline function 'g' such
     that 'g(x) = M1\x' or 'g(x) = M2\x'.

     Besides the vector X, additional outputs are:

        - FLAG indicates the exit status:

          0 : iteration converged to within the specified tolerance

          1 : maximum number of iterations exceeded

          2 : unused, but skipped for compatibility

          3 : algorithm reached stagnation (no change between iterations)

        - RELRES is the final value of the relative residual.

        - ITER is a vector containing the number of outer iterations and
          total iterations performed.

        - RESVEC is a vector containing the relative residual at each
          iteration.

     See also: bicg, bicgstab, cgs, pcg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 81
Solve 'A x = b' using the Preconditioned GMRES iterative method  with restart, a.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
gplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 592
 -- Function File: gplot (A, XY)
 -- Function File: gplot (A, XY, LINE_STYLE)
 -- Function File: [X, Y] = gplot (A, XY)
     Plot a graph defined by A and XY in the graph theory sense.  A is
     the adjacency matrix of the array to be plotted and XY is an N-by-2
     matrix containing the coordinates of the nodes of the graph.

     The optional parameter LINE_STYLE defines the output style for the
     plot.  Called with no output arguments the graph is plotted
     directly.  Otherwise, return the coordinates of the plot in X and
     Y.

     See also: treeplot, etreeplot, spy.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Plot a graph defined by A and XY in the graph theory sense.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
nonzeros


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 130
 -- Function File: nonzeros (S)
     Return a vector of the non-zero values of the sparse matrix S.

     See also: find, nnz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return a vector of the non-zero values of the sparse matrix S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
pcg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6017
 -- Function File: X = pcg (A, B, TOL, MAXIT, M1, M2, X0, ...)
 -- Function File: [X, FLAG, RELRES, ITER, RESVEC, EIGEST] = pcg (...)

     Solve the linear system of equations 'A * X = B' by means of the
     Preconditioned Conjugate Gradient iterative method.  The input
     arguments are

        * A can be either a square (preferably sparse) matrix or a
          function handle, inline function or string containing the name
          of a function which computes 'A * X'.  In principle, A should
          be symmetric and positive definite; if 'pcg' finds A not to be
          positive definite, a warning is printed and the FLAG output
          will be set.

        * B is the right-hand side vector.

        * TOL is the required relative tolerance for the residual error,
          'B - A * X'.  The iteration stops if
          'norm (B - A * X)' <= TOL * norm (B).  If TOL is omitted or
          empty then a tolerance of 1e-6 is used.

        * MAXIT is the maximum allowable number of iterations; if MAXIT
          is omitted or empty then a value of 20 is used.

        * M = M1 * M2 is the (left) preconditioning matrix, so that the
          iteration is (theoretically) equivalent to solving by 'pcg'
          'P * X = M \ B', with 'P = M \ A'.  Note that a proper choice
          of the preconditioner may dramatically improve the overall
          performance of the method.  Instead of matrices M1 and M2, the
          user may pass two functions which return the results of
          applying the inverse of M1 and M2 to a vector (usually this is
          the preferred way of using the preconditioner).  If M1 is
          omitted or empty '[]' then no preconditioning is applied.  If
          M2 is omitted, M = M1 will be used as a preconditioner.

        * X0 is the initial guess.  If X0 is omitted or empty then the
          function sets X0 to a zero vector by default.

     The arguments which follow X0 are treated as parameters, and passed
     in a proper way to any of the functions (A or M) which are passed
     to 'pcg'.  See the examples below for further details.  The output
     arguments are

        * X is the computed approximation to the solution of
          'A * X = B'.

        * FLAG reports on the convergence.  A value of 0 means the
          solution converged and the tolerance criterion given by TOL is
          satisfied.  A value of 1 means that the MAXIT limit for the
          iteration count was reached.  A value of 3 indicates that the
          (preconditioned) matrix was found not to be positive definite.

        * RELRES is the ratio of the final residual to its initial
          value, measured in the Euclidean norm.

        * ITER is the actual number of iterations performed.

        * RESVEC describes the convergence history of the method.
          'RESVEC(i,1)' is the Euclidean norm of the residual, and
          'RESVEC(i,2)' is the preconditioned residual norm, after the
          (I-1)-th iteration, 'I = 1, 2, ..., ITER+1'.  The
          preconditioned residual norm is defined as 'norm (R) ^ 2 = R'
          * (M \ R)' where 'R = B - A * X', see also the description of
          M.  If EIGEST is not required, only 'RESVEC(:,1)' is returned.

        * EIGEST returns the estimate for the smallest 'EIGEST(1)' and
          largest 'EIGEST(2)' eigenvalues of the preconditioned matrix
          'P = M \ A'.  In particular, if no preconditioning is used,
          the estimates for the extreme eigenvalues of A are returned.
          'EIGEST(1)' is an overestimate and 'EIGEST(2)' is an
          underestimate, so that 'EIGEST(2) / EIGEST(1)' is a lower
          bound for 'cond (P, 2)', which nevertheless in the limit
          should theoretically be equal to the actual value of the
          condition number.  The method which computes EIGEST works only
          for symmetric positive definite A and M, and the user is
          responsible for verifying this assumption.

     Let us consider a trivial problem with a diagonal matrix (we
     exploit the sparsity of A)

          n = 10;
          A = diag (sparse (1:n));
          b = rand (n, 1);
          [l, u, p, q] = luinc (A, 1.e-3);

     EXAMPLE 1: Simplest use of 'pcg'

          x = pcg (A, b)

     EXAMPLE 2: 'pcg' with a function which computes 'A * X'

          function y = apply_a (x)
            y = [1:N]' .* x;
          endfunction

          x = pcg ("apply_a", b)

     EXAMPLE 3: 'pcg' with a preconditioner: L * U

          x = pcg (A, b, 1.e-6, 500, l*u)

     EXAMPLE 4: 'pcg' with a preconditioner: L * U.  Faster than EXAMPLE
     3 since lower and upper triangular matrices are easier to invert

          x = pcg (A, b, 1.e-6, 500, l, u)

     EXAMPLE 5: Preconditioned iteration, with full diagnostics.  The
     preconditioner (quite strange, because even the original matrix A
     is trivial) is defined as a function

          function y = apply_m (x)
            k = floor (length (x) - 2);
            y = x;
            y(1:k) = x(1:k) ./ [1:k]';
          endfunction

          [x, flag, relres, iter, resvec, eigest] = ...
                             pcg (A, b, [], [], "apply_m");
          semilogy (1:iter+1, resvec);

     EXAMPLE 6: Finally, a preconditioner which depends on a parameter
     K.

          function y = apply_M (x, varargin)
            K = varargin{1};
            y = x;
            y(1:K) = x(1:K) ./ [1:K]';
          endfunction

          [x, flag, relres, iter, resvec, eigest] = ...
               pcg (A, b, [], [], "apply_m", [], [], 3)

     References:

       1. C.T. Kelley, 'Iterative Methods for Linear and Nonlinear
          Equations', SIAM, 1995.  (the base PCG algorithm)

       2. Y. Saad, 'Iterative Methods for Sparse Linear Systems', PWS
          1996.  (condition number estimate from PCG) Revised version of
          this book is available online at
          <http://www-users.cs.umn.edu/~saad/books.html>

     See also: sparse, pcr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
Solve the linear system of equations 'A * X = B' by means of the  Preconditioned Conjugate Gradient iterative method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
pcr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4357
 -- Function File: X = pcr (A, B, TOL, MAXIT, M, X0, ...)
 -- Function File: [X, FLAG, RELRES, ITER, RESVEC] = pcr (...)

     Solve the linear system of equations 'A * X = B' by means of the
     Preconditioned Conjugate Residuals iterative method.  The input
     arguments are

        * A can be either a square (preferably sparse) matrix or a
          function handle, inline function or string containing the name
          of a function which computes 'A * X'.  In principle A should
          be symmetric and non-singular; if 'pcr' finds A to be
          numerically singular, you will get a warning message and the
          FLAG output parameter will be set.

        * B is the right hand side vector.

        * TOL is the required relative tolerance for the residual error,
          'B - A * X'.  The iteration stops if 'norm (B - A * X) <= TOL
          * norm (B - A * X0)'.  If TOL is empty or is omitted, the
          function sets 'TOL = 1e-6' by default.

        * MAXIT is the maximum allowable number of iterations; if '[]'
          is supplied for 'maxit', or 'pcr' has less arguments, a
          default value equal to 20 is used.

        * M is the (left) preconditioning matrix, so that the iteration
          is (theoretically) equivalent to solving by 'pcr' 'P * X = M \
          B', with 'P = M \ A'.  Note that a proper choice of the
          preconditioner may dramatically improve the overall
          performance of the method.  Instead of matrix M, the user may
          pass a function which returns the results of applying the
          inverse of M to a vector (usually this is the preferred way of
          using the preconditioner).  If '[]' is supplied for M, or M is
          omitted, no preconditioning is applied.

        * X0 is the initial guess.  If X0 is empty or omitted, the
          function sets X0 to a zero vector by default.

     The arguments which follow X0 are treated as parameters, and passed
     in a proper way to any of the functions (A or M) which are passed
     to 'pcr'.  See the examples below for further details.  The output
     arguments are

        * X is the computed approximation to the solution of 'A * X =
          B'.

        * FLAG reports on the convergence.  'FLAG = 0' means the
          solution converged and the tolerance criterion given by TOL is
          satisfied.  'FLAG = 1' means that the MAXIT limit for the
          iteration count was reached.  'FLAG = 3' reports t 'pcr'
          breakdown, see [1] for details.

        * RELRES is the ratio of the final residual to its initial
          value, measured in the Euclidean norm.

        * ITER is the actual number of iterations performed.

        * RESVEC describes the convergence history of the method, so
          that 'RESVEC (i)' contains the Euclidean norms of the residual
          after the (I-1)-th iteration, 'I = 1,2, ..., ITER+1'.

     Let us consider a trivial problem with a diagonal matrix (we
     exploit the sparsity of A)

          n = 10;
          A = sparse (diag (1:n));
          b = rand (N, 1);

     EXAMPLE 1: Simplest use of 'pcr'

          x = pcr (A, b)

     EXAMPLE 2: 'pcr' with a function which computes 'A * X'.

          function y = apply_a (x)
            y = [1:10]' .* x;
          endfunction

          x = pcr ("apply_a", b)

     EXAMPLE 3: Preconditioned iteration, with full diagnostics.  The
     preconditioner (quite strange, because even the original matrix A
     is trivial) is defined as a function

          function y = apply_m (x)
            k = floor (length (x) - 2);
            y = x;
            y(1:k) = x(1:k) ./ [1:k]';
          endfunction

          [x, flag, relres, iter, resvec] = ...
                             pcr (A, b, [], [], "apply_m")
          semilogy ([1:iter+1], resvec);

     EXAMPLE 4: Finally, a preconditioner which depends on a parameter
     K.

          function y = apply_m (x, varargin)
            k = varargin{1};
            y = x;
            y(1:k) = x(1:k) ./ [1:k]';
          endfunction

          [x, flag, relres, iter, resvec] = ...
                             pcr (A, b, [], [], "apply_m"', [], 3)

     References:

     [1] W. Hackbusch, 'Iterative Solution of Large Sparse Systems of
     Equations', section 9.5.4; Springer, 1994

     See also: sparse, pcg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 118
Solve the linear system of equations 'A * X = B' by means of the  Preconditioned Conjugate Residuals iterative method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
spaugment


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1329
 -- Function File: S = spaugment (A, C)
     Create the augmented matrix of A.

     This is given by

          [C * eye(M, M), A;
                      A', zeros(N, N)]

     This is related to the least squares solution of 'A \ B', by

          S * [ R / C; x] = [ B, zeros(N, columns(B)) ]

     where R is the residual error

          R = B - A * X

     As the matrix S is symmetric indefinite it can be factorized with
     'lu', and the minimum norm solution can therefore be found without
     the need for a 'qr' factorization.  As the residual error will be
     'zeros (M, M)' for underdetermined problems, and example can be

          m = 11; n = 10; mn = max (m, n);
          A = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],
                       [-1, 0, 1], m, n);
          x0 = A \ ones (m,1);
          s = spaugment (A);
          [L, U, P, Q] = lu (s);
          x1 = Q * (U \ (L \ (P  * [ones(m,1); zeros(n,1)])));
          x1 = x1(end - n + 1 : end);

     To find the solution of an overdetermined problem needs an estimate
     of the residual error R and so it is more complex to formulate a
     minimum norm solution using the 'spaugment' function.

     In general the left division operator is more stable and faster
     than using the 'spaugment' function.

     See also: mldivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Create the augmented matrix of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
spconvert


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 444
 -- Function File: X = spconvert (M)
     Convert a simple sparse matrix format easily generated by other
     programs into Octave's internal sparse format.

     The input M is either a 3 or 4 column real matrix, containing the
     row, column, real, and imaginary parts of the elements of the
     sparse matrix.  An element with a zero real and imaginary part can
     be used to force a particular matrix size.

     See also: sparse.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
Convert a simple sparse matrix format easily generated by other  programs into Octave's internal sparse format.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
spdiags


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1072
 -- Function File: [B, C] = spdiags (A)
 -- Function File: B = spdiags (A, C)
 -- Function File: B = spdiags (V, C, A)
 -- Function File: B = spdiags (V, C, M, N)
     A generalization of the function 'diag'.  Called with a single
     input argument, the non-zero diagonals C of A are extracted.  With
     two arguments the diagonals to extract are given by the vector C.

     The other two forms of 'spdiags' modify the input matrix by
     replacing the diagonals.  They use the columns of V to replace the
     columns represented by the vector C.  If the sparse matrix A is
     defined then the diagonals of this matrix are replaced.  Otherwise
     a matrix of M by N is created with the diagonals given by V.

     Negative values of C represent diagonals below the main diagonal,
     and positive values of C diagonals above the main diagonal.

     For example:

          spdiags (reshape (1:12, 4, 3), [-1 0 1], 5, 4)
             => 5 10  0  0
                1  6 11  0
                0  2  7 12
                0  0  3  8
                0  0  0  4

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
A generalization of the function 'diag'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
speye


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 516
 -- Function File: S = speye (M, N)
 -- Function File: S = speye (M)
 -- Function File: S = speye (SZ)
     Return a sparse identity matrix of size MxN.

     The implementation is significantly more efficient than 'sparse
     (eye (M))' as the full matrix is not constructed.

     Called with a single argument a square matrix of size M-by-M is
     created.  If called with a single vector argument SZ, this argument
     is taken to be the size of the matrix to create.

     See also: sparse, spdiags, eye.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return a sparse identity matrix of size MxN.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
spfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 293
 -- Function File: Y = spfun (F, S)
     Compute 'f(S)' for the non-zero values of S.  This results in a
     sparse matrix with the same structure as S.  The function F can be
     passed as a string, a function handle, or an inline function.

     See also: arrayfun, cellfun, structfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Compute 'f(S)' for the non-zero values of S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
spones


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 216
 -- Function File: R = spones (S)
     Replace the non-zero entries of S with ones.  This creates a sparse
     matrix with the same structure as S.

     See also: sparse, sprand, sprandn, sprandsym, spfun, spy.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Replace the non-zero entries of S with ones.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
sprand


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 459
 -- Function File: sprand (M, N, D)
 -- Function File: sprand (S)
     Generate a random sparse matrix.  The size of the matrix will be
     MxN, with a density of values given by D.  D must be between 0 and
     1 inclusive.  Values will be uniformly distributed between 0 and 1.

     If called with a single matrix argument, a random sparse matrix is
     generated wherever the matrix S is non-zero.

     See also: sprandn, sprandsym, spones, sparse.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Generate a random sparse matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
sprandn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 488
 -- Function File: sprandn (M, N, D)
 -- Function File: sprandn (S)
     Generate a random sparse matrix.  The size of the matrix will be
     MxN, with a density of values given by D.  D must be between 0 and
     1 inclusive.  Values will be normally distributed with a mean of
     zero and a variance of 1.

     If called with a single matrix argument, a random sparse matrix is
     generated wherever the matrix S is non-zero.

     See also: sprand, sprandsym, spones, sparse.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Generate a random sparse matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
sprandsym


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 531
 -- Function File: sprandsym (N, D)
 -- Function File: sprandsym (S)
     Generate a symmetric random sparse matrix.

     The size of the matrix will be NxN, with a density of values given
     by D.  D must be between 0 and 1 inclusive.  Values will be
     normally distributed with a mean of zero and a variance of 1.

     If called with a single matrix argument, a random sparse matrix is
     generated wherever the matrix S is non-zero in its lower triangular
     part.

     See also: sprand, sprandn, spones, sparse.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Generate a symmetric random sparse matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
spstats


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 599
 -- Function File: [COUNT, MEAN, VAR] = spstats (S)
 -- Function File: [COUNT, MEAN, VAR] = spstats (S, J)
     Return the stats for the non-zero elements of the sparse matrix S.
     COUNT is the number of non-zeros in each column, MEAN is the mean
     of the non-zeros in each column, and VAR is the variance of the
     non-zeros in each column.

     Called with two input arguments, if S is the data and J is the bin
     number for the data, compute the stats for each bin.  In this case,
     bins can contain data values of zero, whereas with 'spstats (S)'
     the zeros may disappear.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Return the stats for the non-zero elements of the sparse matrix S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
spy


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 423
 -- Function File: spy (X)
 -- Function File: spy (..., MARKERSIZE)
 -- Function File: spy (..., LINE_SPEC)
     Plot the sparsity pattern of the sparse matrix X.

     If the argument MARKERSIZE is given as a scalar value, it is used
     to determine the point size in the plot.  If the string LINE_SPEC
     is given it is passed to 'plot' and determines the appearance of
     the plot.

     See also: plot, gplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Plot the sparsity pattern of the sparse matrix X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
svds


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2301
 -- Function File: S = svds (A)
 -- Function File: S = svds (A, K)
 -- Function File: S = svds (A, K, SIGMA)
 -- Function File: S = svds (A, K, SIGMA, OPTS)
 -- Function File: [U, S, V] = svds (...)
 -- Function File: [U, S, V, FLAG] = svds (...)

     Find a few singular values of the matrix A.  The singular values
     are calculated using

          [M, N] = size (A);
          S = eigs ([sparse(M, M), A;
                               A', sparse(N, N)])

     The eigenvalues returned by 'eigs' correspond to the singular
     values of A.  The number of singular values to calculate is given
     by K and defaults to 6.

     The argument SIGMA specifies which singular values to find.  When
     SIGMA is the string 'L', the default, the largest singular values
     of A are found.  Otherwise, SIGMA must be a real scalar and the
     singular values closest to SIGMA are found.  As a corollary, 'SIGMA
     = 0' finds the smallest singular values.  Note that for relatively
     small values of SIGMA, there is a chance that the requested number
     of singular values will not be found.  In that case SIGMA should be
     increased.

     OPTS is a structure defining options that 'svds' will pass to
     'eigs'.  The possible fields of this structure are documented in
     'eigs'.  By default, 'svds' sets the following three fields:

     'tol'
          The required convergence tolerance for the singular values.
          The default value is 1e-10.  'eigs' is passed 'TOL / sqrt(2)'.

     'maxit'
          The maximum number of iterations.  The default is 300.

     'disp'
          The level of diagnostic printout (0|1|2).  If 'disp' is 0 then
          diagnostics are disabled.  The default value is 0.

     If more than one output is requested then 'svds' will return an
     approximation of the singular value decomposition of A

          A_approx = U*S*V'

     where A_approx is a matrix of size A but only rank K.

     FLAG returns 0 if the algorithm has succesfully converged, and 1
     otherwise.  The test for convergence is

          norm (A*V - U*S, 1) <= TOL * norm (A, 1)

     'svds' is best for finding only a few singular values from a large
     sparse matrix.  Otherwise, 'svd (full (A))' will likely be more
     efficient.

See also: svd, eigs.  


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Find a few singular values of the matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
treelayout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 400
 -- Function File: treelayout (TREE)
 -- Function File: treelayout (TREE, PERMUTATION)
     treelayout lays out a tree or a forest.  The first argument TREE is
     a vector of predecessors, optional parameter PERMUTATION is an
     optional postorder permutation.  The complexity of the algorithm is
     O(n) in terms of time and memory requirements.

     See also: etreeplot, gplot, treeplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
treelayout lays out a tree or a forest.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
treeplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 390
 -- Function File: treeplot (TREE)
 -- Function File: treeplot (TREE, NODE_STYLE, EDGE_STYLE)
     Produce a graph of tree or forest.  The first argument is vector of
     predecessors, optional parameters NODE_STYLE and EDGE_STYLE define
     the output style.  The complexity of the algorithm is O(n) in terms
     of is time and memory requirements.

     See also: etreeplot, gplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Produce a graph of tree or forest.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bessel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2156
 -- Loadable Function: [J, IERR] = besselj (ALPHA, X, OPT)
 -- Loadable Function: [Y, IERR] = bessely (ALPHA, X, OPT)
 -- Loadable Function: [I, IERR] = besseli (ALPHA, X, OPT)
 -- Loadable Function: [K, IERR] = besselk (ALPHA, X, OPT)
 -- Loadable Function: [H, IERR] = besselh (ALPHA, K, X, OPT)
     Compute Bessel or Hankel functions of various kinds:

     'besselj'
          Bessel functions of the first kind.  If the argument OPT is
          supplied, the result is multiplied by 'exp (-abs (imag (x)))'.

     'bessely'
          Bessel functions of the second kind.  If the argument OPT is
          supplied, the result is multiplied by 'exp (-abs (imag (x)))'.

     'besseli'
          Modified Bessel functions of the first kind.  If the argument
          OPT is supplied, the result is multiplied by 'exp (-abs (real
          (x)))'.

     'besselk'
          Modified Bessel functions of the second kind.  If the argument
          OPT is supplied, the result is multiplied by 'exp (x)'.

     'besselh'
          Compute Hankel functions of the first (K = 1) or second (K =
          2) kind.  If the argument OPT is supplied, the result is
          multiplied by 'exp (-I*X)' for K = 1 or 'exp (I*X)' for K = 2.

     If ALPHA is a scalar, the result is the same size as X.  If X is a
     scalar, the result is the same size as ALPHA.  If ALPHA is a row
     vector and X is a column vector, the result is a matrix with
     'length (X)' rows and 'length (ALPHA)' columns.  Otherwise, ALPHA
     and X must conform and the result will be the same size.

     The value of ALPHA must be real.  The value of X may be complex.

     If requested, IERR contains the following status information and is
     the same size as the result.

       0. Normal return.

       1. Input error, return 'NaN'.

       2. Overflow, return 'Inf'.

       3. Loss of significance by argument reduction results in less
          than half of machine accuracy.

       4. Complete loss of significance by argument reduction, return
          'NaN'.

       5. Error--no computation, algorithm termination condition not
          met, return 'NaN'.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute Bessel or Hankel functions of various kinds: 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
beta


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 182
 -- Mapping Function: beta (A, B)
     For real inputs, return the Beta function,

          beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).

     See also: betaln, betainc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
For real inputs, return the Beta function, 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
betaln


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 245
 -- Mapping Function: betaln (A, B)
     Return the natural logarithm of the Beta function,

          betaln (a, b) = log (beta (a, b))

     calculated in a way to reduce the occurrence of underflow.

     See also: beta, betainc, gammaln.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return the natural logarithm of the Beta function, 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ellipke


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 627
 -- Function File: K = ellipke (M)
 -- Function File: K = ellipke (M, TOL)
 -- Function File: [K, E] = ellipke (...)
     Compute complete elliptic integrals of the first K(M) and second
     E(M) kind.

     M must be a scalar or real array with -Inf <= M <= 1.

     The optional input TOL is currently ignored (MATLAB uses this to
     allow a faster, less accurate approximation).

     Called with only one output, elliptic integrals of the first kind
     are returned.

     Reference: Milton Abramowitz and Irene A. Stegun, 'Handbook of
     Mathematical Functions', Chapter 17, Dover, 1965.

     See also: ellipj.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Compute complete elliptic integrals of the first K(M) and second  E(M) kind.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
expint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 655
 -- Function File: expint (X)
     Compute the exponential integral:

                     infinity
                    /
          E_1 (x) = | exp (-t)/t dt
                    /
                   x

     Note: For compatibility, this functions uses the MATLAB definition
     of the exponential integral.  Most other sources refer to this
     particular value as E_1 (x), and the exponential integral is

                      infinity
                     /
          Ei (x) = - | exp (-t)/t dt
                     /
                   -x

     The two definitions are related, for positive real values of X, by
     'E_1 (-x) = -Ei (x) - i*pi'.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Compute the exponential integral: 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
factor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 495
 -- Function File: P = factor (Q)
 -- Function File: [P, N] = factor (Q)

     Return the prime factorization of Q.  That is, 'prod (P) == Q' and
     every element of P is a prime number.  If 'Q == 1', return 1.

     With two output arguments, return the unique primes P and their
     multiplicities.  That is, 'prod (P .^ N) == Q'.

     Implementation Note: The input Q must not be greater than 'bitmax'
     (9.0072e+15) in order to factor correctly.

     See also: gcd, lcm, isprime.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Return the prime factorization of Q.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
factorial


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 347
 -- Function File: factorial (N)
     Return the factorial of N where N is a positive integer.  If N is a
     scalar, this is equivalent to 'prod (1:N)'.  For vector or matrix
     arguments, return the factorial of each element in the array.  For
     non-integers see the generalized factorial function 'gamma'.

     See also: prod, gamma.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Return the factorial of N where N is a positive integer.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isprime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 369
 -- Function File: isprime (X)
     Return a logical array which is true where the elements of X are
     prime numbers and false where they are not.

     If the maximum value in X is very large, then you should be using
     special purpose factorization code.

          isprime (1:6)
              => [0, 1, 1, 0, 1, 0]

     See also: primes, factor, gcd, lcm.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
Return a logical array which is true where the elements of X are  prime numbers and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
lcm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 239
 -- Mapping Function: lcm (X, Y)
 -- Mapping Function: lcm (X, Y, ...)
     Compute the least common multiple of X and Y, or of the list of all
     arguments.  All elements must be the same size or scalar.

     See also: factor, gcd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Compute the least common multiple of X and Y, or of the list of all  arguments.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
legendre


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2273
 -- Function File: L = legendre (N, X)
 -- Function File: L = legendre (N, X, NORMALIZATION)
     Compute the Legendre function of degree N and order M = 0 ... N.
     The optional argument, NORMALIZATION, may be one of "unnorm",
     "sch", or "norm".  The default is "unnorm".  The value of N must be
     a non-negative scalar integer.

     If the optional argument NORMALIZATION is missing or is "unnorm",
     compute the Legendre function of degree N and order M and return
     all values for M = 0 ... N.  The return value has one dimension
     more than X.

     The Legendre Function of degree N and order M:

           m        m       2  m/2   d^m
          P(x) = (-1) * (1-x  )    * ----  P(x)
           n                         dx^m   n

     with Legendre polynomial of degree N:

                    1    d^n   2    n
          P(x) = ------ [----(x - 1) ]
           n     2^n n!  dx^n

     'legendre (3, [-1.0, -0.9, -0.8])' returns the matrix:

           x  |   -1.0   |   -0.9   |   -0.8
          ------------------------------------
          m=0 | -1.00000 | -0.47250 | -0.08000
          m=1 |  0.00000 | -1.99420 | -1.98000
          m=2 |  0.00000 | -2.56500 | -4.32000
          m=3 |  0.00000 | -1.24229 | -3.24000

     If the optional argument 'normalization' is "sch", compute the
     Schmidt semi-normalized associated Legendre function.  The Schmidt
     semi-normalized associated Legendre function is related to the
     unnormalized Legendre functions by the following:

     For Legendre functions of degree n and order 0:

            0      0
          SP(x) = P(x)
            n      n

     For Legendre functions of degree n and order m:

            m      m         m    2(n-m)! 0.5
          SP(x) = P(x) * (-1)  * [-------]
            n      n              (n+m)!

     If the optional argument NORMALIZATION is "norm", compute the fully
     normalized associated Legendre function.  The fully normalized
     associated Legendre function is related to the unnormalized
     Legendre functions by the following:

     For Legendre functions of degree N and order M

            m      m         m    (n+0.5)(n-m)! 0.5
          NP(x) = P(x) * (-1)  * [-------------]
            n      n                  (n+m)!

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Compute the Legendre function of degree N and order M = 0 .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
nchoosek


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1304
 -- Function File: C = nchoosek (N, K)
 -- Function File: C = nchoosek (SET, K)

     Compute the binomial coefficient or all combinations of a set of
     items.

     If N is a scalar then calculate the binomial coefficient of N and K
     which is defined as

           /   \
           | n |    n (n-1) (n-2) ... (n-k+1)       n!
           |   |  = ------------------------- =  ---------
           | k |               k!                k! (n-k)!
           \   /

     This is the number of combinations of N items taken in groups of
     size K.

     If the first argument is a vector, SET, then generate all
     combinations of the elements of SET, taken K at a time, with one
     row per combination.  The result C has K columns and 'nchoosek (length (SET), K)'
     rows.

     For example:

     How many ways can three items be grouped into pairs?

          nchoosek (3, 2)
             => 3

     What are the possible pairs?

          nchoosek (1:3, 2)
             =>  1   2
                 1   3
                 2   3

     'nchoosek' works only for non-negative, integer arguments.  Use
     'bincoeff' for non-integer and negative scalar arguments, or for
     computing many binomial coefficients at once with vector inputs for
     N or K.

     See also: bincoeff, perms.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Compute the binomial coefficient or all combinations of a set of  items.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nthroot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 414
 -- Function File: nthroot (X, N)

     Compute the n-th root of X, returning real results for real
     components of X.  For example:

          nthroot (-1, 3)
          => -1
          (-1) ^ (1 / 3)
          => 0.50000 - 0.86603i

     X must have all real entries.  N must be a scalar.  If N is an even
     integer and X has negative entries, an error is produced.

     See also: realsqrt, sqrt, cbrt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Compute the n-th root of X, returning real results for real  components of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
perms


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 363
 -- Function File: perms (V)

     Generate all permutations of V, one row per permutation.  The
     result has size 'factorial (N) * N', where N is the length of V.

     As an example, 'perms ([1, 2, 3])' returns the matrix

            1   2   3
            2   1   3
            1   3   2
            2   3   1
            3   1   2
            3   2   1
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Generate all permutations of V, one row per permutation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
pow2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 212
 -- Mapping Function: pow2 (X)
 -- Mapping Function: pow2 (F, E)
     With one argument, computes 2 .^ x for each element of X.

     With two arguments, returns f .* (2 .^ e).

     See also: log2, nextpow2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
With one argument, computes 2 .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
primes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 433
 -- Function File: primes (N)

     Return all primes up to N.

     The algorithm used is the Sieve of Eratosthenes.

     Note that if you need a specific number of primes you can use the
     fact that the distance from one prime to the next is, on average,
     proportional to the logarithm of the prime.  Integrating, one finds
     that there are about k primes less than k*log (5*k).

     See also: list_primes, isprime.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Return all primes up to N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
reallog


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 213
 -- Function File: reallog (X)
     Return the real-valued natural logarithm of each element of X.
     Report an error if any element results in a complex return value.

     See also: log, realpow, realsqrt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return the real-valued natural logarithm of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
realpow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 251
 -- Function File: realpow (X, Y)
     Compute the real-valued, element-by-element power operator.  This
     is equivalent to 'X .^ Y', except that 'realpow' reports an error
     if any return value is complex.

     See also: reallog, realsqrt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Compute the real-valued, element-by-element power operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
realsqrt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 209
 -- Function File: realsqrt (X)
     Return the real-valued square root of each element of X.  Report an
     error if any element results in a complex return value.

     See also: sqrt, realpow, reallog.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Return the real-valued square root of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
gallery


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10911
 -- Function File: gallery (NAME)
 -- Function File: gallery (NAME, ARGS)
     Create interesting matrices for testing.

 -- Function File: C = gallery ("cauchy", X)
 -- Function File: C = gallery ("cauchy", X, Y)
     Create a Cauchy matrix.

 -- Function File: C = gallery ("chebspec", N)
 -- Function File: C = gallery ("chebspec", N, K)
     Create a Chebyshev spectral differentiation matrix.

 -- Function File: C = gallery ("chebvand", P)
 -- Function File: C = gallery ("chebvand", M, P)
     Create a Vandermonde-like matrix for the Chebyshev polynomials.

 -- Function File: A = gallery ("chow", N)
 -- Function File: A = gallery ("chow", N, ALPHA)
 -- Function File: A = gallery ("chow", N, ALPHA, DELTA)
     Create a Chow matrix - a singular Toeplitz lower Hessenberg matrix.

 -- Function File: C = gallery ("circul", V)
     Create a circulant matrix.

 -- Function File: A = gallery ("clement", N)
 -- Function File: A = gallery ("clement", N, K)
     Create a tridiagonal matrix with zero diagonal entries.

 -- Function File: C = gallery ("compar", A)
 -- Function File: C = gallery ("compar", A, K)
     Create a comparison matrix.

 -- Function File: A = gallery ("condex", N)
 -- Function File: A = gallery ("condex", N, K)
 -- Function File: A = gallery ("condex", N, K, THETA)
     Create a 'counterexample' matrix to a condition estimator.

 -- Function File: A = gallery ("cycol", [M N])
 -- Function File: A = gallery ("cycol", N)
 -- Function File: A = gallery (..., K)
     Create a matrix whose columns repeat cyclically.

 -- Function File: [C, D, E] = gallery ("dorr", N)
 -- Function File: [C, D, E] = gallery ("dorr", N, THETA)
 -- Function File: A = gallery ("dorr", ...)
     Create a diagonally dominant, ill conditioned, tridiagonal matrix.

 -- Function File: A = gallery ("dramadah", N)
 -- Function File: A = gallery ("dramadah", N, K)
     Create a (0, 1) matrix whose inverse has large integer entries.

 -- Function File: A = gallery ("fiedler", C)
     Create a symmetric Fiedler matrix.

 -- Function File: A = gallery ("forsythe", N)
 -- Function File: A = gallery ("forsythe", N, ALPHA)
 -- Function File: A = gallery ("forsythe", N, ALPHA, LAMBDA)
     Create a Forsythe matrix (a perturbed Jordan block).

 -- Function File: F = gallery ("frank", N)
 -- Function File: F = gallery ("frank", N, K)
     Create a Frank matrix (ill conditioned eigenvalues).

 -- Function File: C = gallery ("gcdmat", N)
     Create a greatest common divisor matrix.

     C is an N-by-N matrix whose values correspond to the greatest
     common divisor of its coordinate values, i.e., C(i,j) correspond
     'gcd (i, j)'.

 -- Function File: A = gallery ("gearmat", N)
 -- Function File: A = gallery ("gearmat", N, I)
 -- Function File: A = gallery ("gearmat", N, I, J)
     Create a Gear matrix.

 -- Function File: G = gallery ("grcar", N)
 -- Function File: G = gallery ("grcar", N, K)
     Create a Toeplitz matrix with sensitive eigenvalues.

 -- Function File: A = gallery ("hanowa", N)
 -- Function File: A = gallery ("hanowa", N, D)
     Create a matrix whose eigenvalues lie on a vertical line in the
     complex plane.

 -- Function File: V = gallery ("house", X)
 -- Function File: [V, BETA] = gallery ("house", X)
     Create a householder matrix.

 -- Function File: A = gallery ("integerdata", IMAX, [M N ...], J)
 -- Function File: A = gallery ("integerdata", IMAX, M, N, ..., J)
 -- Function File: A = gallery ("integerdata", [IMIN, IMAX], [M N ...],
          J)
 -- Function File: A = gallery ("integerdata", [IMIN, IMAX], M, N, ...,
          J)
 -- Function File: A = gallery ("integerdata", ..., "CLASS")
     Create a matrix with random integers in the range [1, IMAX].  If
     IMIN is given then the integers are in the range [IMIN, IMAX].

     The second input is a matrix of dimensions describing the size of
     the output.  The dimensions can also be input as comma-separated
     arguments.

     The input J is an integer index in the range [0, 2^32-1].  The
     values of the output matrix are always exactly the same
     (reproducibility) for a given size input and J index.

     The final optional argument determines the class of the resulting
     matrix.  Possible values for CLASS: "uint8", "uint16", "uint32",
     "int8", "int16", int32", "single", "double".  The default is
     "double".

 -- Function File: A = gallery ("invhess", X)
 -- Function File: A = gallery ("invhess", X, Y)
     Create the inverse of an upper Hessenberg matrix.

 -- Function File: A = gallery ("invol", N)
     Create an involutory matrix.

 -- Function File: A = gallery ("ipjfact", N)
 -- Function File: A = gallery ("ipjfact", N, K)
     Create an Hankel matrix with factorial elements.

 -- Function File: A = gallery ("jordbloc", N)
 -- Function File: A = gallery ("jordbloc", N, LAMBDA)
     Create a Jordan block.

 -- Function File: U = gallery ("kahan", N)
 -- Function File: U = gallery ("kahan", N, THETA)
 -- Function File: U = gallery ("kahan", N, THETA, PERT)
     Create a Kahan matrix (upper trapezoidal).

 -- Function File: A = gallery ("kms", N)
 -- Function File: A = gallery ("kms", N, RHO)
     Create a Kac-Murdock-Szego Toeplitz matrix.

 -- Function File: B = gallery ("krylov", A)
 -- Function File: B = gallery ("krylov", A, X)
 -- Function File: B = gallery ("krylov", A, X, J)
     Create a Krylov matrix.

 -- Function File: A = gallery ("lauchli", N)
 -- Function File: A = gallery ("lauchli", N, MU)
     Create a Lauchli matrix (rectangular).

 -- Function File: A = gallery ("lehmer", N)
     Create a Lehmer matrix (symmetric positive definite).

 -- Function File: T = gallery ("lesp", N)
     Create a tridiagonal matrix with real, sensitive eigenvalues.

 -- Function File: A = gallery ("lotkin", N)
     Create a Lotkin matrix.

 -- Function File: A = gallery ("minij", N)
     Create a symmetric positive definite matrix MIN(i,j).

 -- Function File: A = gallery ("moler", N)
 -- Function File: A = gallery ("moler", N, ALPHA)
     Create a Moler matrix (symmetric positive definite).

 -- Function File: [A, T] = gallery ("neumann", N)
     Create a singular matrix from the discrete Neumann problem
     (sparse).

 -- Function File: A = gallery ("normaldata", [M N ...], J)
 -- Function File: A = gallery ("normaldata", M, N, ..., J)
 -- Function File: A = gallery ("normaldata", ..., "CLASS")
     Create a matrix with random samples from the standard normal
     distribution (mean = 0, std = 1).

     The first input is a matrix of dimensions describing the size of
     the output.  The dimensions can also be input as comma-separated
     arguments.

     The input J is an integer index in the range [0, 2^32-1].  The
     values of the output matrix are always exactly the same
     (reproducibility) for a given size input and J index.

     The final optional argument determines the class of the resulting
     matrix.  Possible values for CLASS: "single", "double".  The
     default is "double".

 -- Function File: Q = gallery ("orthog", N)
 -- Function File: Q = gallery ("orthog", N, K)
     Create orthogonal and nearly orthogonal matrices.

 -- Function File: A = gallery ("parter", N)
     Create a Parter matrix (a Toeplitz matrix with singular values near
     pi).

 -- Function File: P = gallery ("pei", N)
 -- Function File: P = gallery ("pei", N, ALPHA)
     Create a Pei matrix.

 -- Function File: A = gallery ("Poisson", N)
     Create a block tridiagonal matrix from Poisson's equation (sparse).

 -- Function File: A = gallery ("prolate", N)
 -- Function File: A = gallery ("prolate", N, W)
     Create a prolate matrix (symmetric, ill-conditioned Toeplitz
     matrix).

 -- Function File: H = gallery ("randhess", X)
     Create a random, orthogonal upper Hessenberg matrix.

 -- Function File: A = gallery ("rando", N)
 -- Function File: A = gallery ("rando", N, K)
     Create a random matrix with elements -1, 0 or 1.

 -- Function File: A = gallery ("randsvd", N)
 -- Function File: A = gallery ("randsvd", N, KAPPA)
 -- Function File: A = gallery ("randsvd", N, KAPPA, MODE)
 -- Function File: A = gallery ("randsvd", N, KAPPA, MODE, KL)
 -- Function File: A = gallery ("randsvd", N, KAPPA, MODE, KL, KU)
     Create a random matrix with pre-assigned singular values.

 -- Function File: A = gallery ("redheff", N)
     Create a zero and ones matrix of Redheffer associated with the
     Riemann hypothesis.

 -- Function File: A = gallery ("riemann", N)
     Create a matrix associated with the Riemann hypothesis.

 -- Function File: A = gallery ("ris", N)
     Create a symmetric Hankel matrix.

 -- Function File: A = gallery ("smoke", N)
 -- Function File: A = gallery ("smoke", N, K)
     Create a complex matrix, with a 'smoke ring' pseudospectrum.

 -- Function File: T = gallery ("toeppd", N)
 -- Function File: T = gallery ("toeppd", N, M)
 -- Function File: T = gallery ("toeppd", N, M, W)
 -- Function File: T = gallery ("toeppd", N, M, W, THETA)
     Create a symmetric positive definite Toeplitz matrix.

 -- Function File: P = gallery ("toeppen", N)
 -- Function File: P = gallery ("toeppen", N, A)
 -- Function File: P = gallery ("toeppen", N, A, B)
 -- Function File: P = gallery ("toeppen", N, A, B, C)
 -- Function File: P = gallery ("toeppen", N, A, B, C, D)
 -- Function File: P = gallery ("toeppen", N, A, B, C, D, E)
     Create a pentadiagonal Toeplitz matrix (sparse).

 -- Function File: A = gallery ("tridiag", X, Y, Z)
 -- Function File: A = gallery ("tridiag", N)
 -- Function File: A = gallery ("tridiag", N, C, D, E)
     Create a tridiagonal matrix (sparse).

 -- Function File: T = gallery ("triw", N)
 -- Function File: T = gallery ("triw", N, ALPHA)
 -- Function File: T = gallery ("triw", N, ALPHA, K)
     Create an upper triangular matrix discussed by Kahan, Golub and
     Wilkinson.

 -- Function File: A = gallery ("uniformdata", [M N ...], J)
 -- Function File: A = gallery ("uniformdata", M, N, ..., J)
 -- Function File: A = gallery ("uniformdata", ..., "CLASS")
     Create a matrix with random samples from the standard uniform
     distribution (range [0,1]).

     The first input is a matrix of dimensions describing the size of
     the output.  The dimensions can also be input as comma-separated
     arguments.

     The input J is an integer index in the range [0, 2^32-1].  The
     values of the output matrix are always exactly the same
     (reproducibility) for a given size input and J index.

     The final optional argument determines the class of the resulting
     matrix.  Possible values for CLASS: "single", "double".  The
     default is "double".

 -- Function File: A = gallery ("wathen", NX, NY)
 -- Function File: A = gallery ("wathen", NX, NY, K)
     Create the Wathen matrix.

 -- Function File: [A, B] = gallery ("wilk", N)
     Create various specific matrices devised/discussed by Wilkinson.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Create interesting matrices for testing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
hadamard


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 690
 -- Function File: hadamard (N)
     Construct a Hadamard matrix (Hn) of size N-by-N.  The size N must
     be of the form 2^k * p in which p is one of 1, 12, 20 or 28.  The
     returned matrix is normalized, meaning 'Hn(:,1) == 1' and
     'Hn(1,:) == 1'.

     Some of the properties of Hadamard matrices are:

        * 'kron (Hm, Hn)' is a Hadamard matrix of size M-by-N.

        * 'Hn * Hn' = N * eye (N)'.

        * The rows of Hn are orthogonal.

        * 'det (A) <= abs (det (Hn))' for all A with
          'abs (A(i, j)) <= 1'.

        * Multiplying any row or column by -1 and the matrix will remain
          a Hadamard matrix.

     See also: compan, hankel, toeplitz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Construct a Hadamard matrix (Hn) of size N-by-N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
hankel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 594
 -- Function File: hankel (C)
 -- Function File: hankel (C, R)
     Return the Hankel matrix constructed from the first column C, and
     (optionally) the last row R.  If the last element of C is not the
     same as the first element of R, the last element of C is used.  If
     the second argument is omitted, it is assumed to be a vector of
     zeros with the same size as C.

     A Hankel matrix formed from an m-vector C, and an n-vector R, has
     the elements

          H(i,j) = c(i+j-1),  i+j-1 <= m;
          H(i,j) = r(i+j-m),  otherwise

     See also: hadamard, toeplitz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Return the Hankel matrix constructed from the first column C, and  (optionally) the last row R.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
hilb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 573
 -- Function File: hilb (N)
     Return the Hilbert matrix of order N.  The i,j element of a Hilbert
     matrix is defined as

          H(i, j) = 1 / (i + j - 1)

     Hilbert matrices are close to being singular which make them
     difficult to invert with numerical routines.  Comparing the
     condition number of a random matrix 5x5 matrix with that of a
     Hilbert matrix of order 5 reveals just how difficult the problem
     is.

          cond (rand (5))
             => 14.392
          cond (hilb (5))
             => 4.7661e+05

     See also: invhilb.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Return the Hilbert matrix of order N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
invhilb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1023
 -- Function File: invhilb (N)
     Return the inverse of the Hilbert matrix of order N.  This can be
     computed exactly using


                      (i+j)         /n+i-1\  /n+j-1\   /i+j-2\ 2
           A(i,j) = -1      (i+j-1)(       )(       ) (       )
                                    \ n-j /  \ n-i /   \ i-2 /

                  = p(i) p(j) / (i+j-1)


     where

                       k  /k+n-1\   /n\
              p(k) = -1  (       ) (   )
                          \ k-1 /   \k/

     The validity of this formula can easily be checked by expanding the
     binomial coefficients in both formulas as factorials.  It can be
     derived more directly via the theory of Cauchy matrices.  See J. W.
     Demmel, 'Applied Numerical Linear Algebra', p.  92.

     Compare this with the numerical calculation of 'inverse (hilb
     (n))', which suffers from the ill-conditioning of the Hilbert
     matrix, and the finite precision of your computer's floating point
     arithmetic.

     See also: hilb.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return the inverse of the Hilbert matrix of order N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
magic


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 293
 -- Function File: magic (N)

     Create an N-by-N magic square.  A magic square is an arrangement of
     the integers '1:n^2' such that the row sums, column sums, and
     diagonal sums are all equal to the same value.

     Note: N must be greater than 2 for the magic square to exist.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Create an N-by-N magic square.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
pascal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 649
 -- Function File: pascal (N)
 -- Function File: pascal (N, T)
     Return the Pascal matrix of order N if 'T = 0'.  T defaults to 0.
     Return the pseudo-lower triangular Cholesky factor of the Pascal
     matrix if 'T = 1' (The sign of some columns may be negative).  This
     matrix is its own inverse, that is 'pascal (N, 1) ^ 2 == eye (N)'.
     If 'T = -1', return the true Cholesky factor with strictly positive
     values on the diagonal.  If 'T = 2', return a transposed and
     permuted version of 'pascal (N, 1)', which is the cube root of the
     identity matrix.  That is, 'pascal (N, 2) ^ 3 == eye (N)'.

     See also: chol.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return the Pascal matrix of order N if 'T = 0'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rosser


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 171
 -- Function File: rosser ()
     Return the Rosser matrix.  This is a difficult test case used to
     evaluate eigenvalue algorithms.

     See also: wilkinson, eig.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Return the Rosser matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
toeplitz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 729
 -- Function File: toeplitz (C)
 -- Function File: toeplitz (C, R)
     Return the Toeplitz matrix constructed from the first column C, and
     (optionally) the first row R.  If the first element of R is not the
     same as the first element of C, the first element of C is used.  If
     the second argument is omitted, the first row is taken to be the
     same as the first column.

     A square Toeplitz matrix has the form:

          c(0)  r(1)   r(2)  ...  r(n)
          c(1)  c(0)   r(1)  ... r(n-1)
          c(2)  c(1)   c(0)  ... r(n-2)
           .     .      .   .      .
           .     .      .     .    .
           .     .      .       .  .
          c(n) c(n-1) c(n-2) ...  c(0)

     See also: hankel.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Return the Toeplitz matrix constructed from the first column C, and  (optionally) the first row R.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
vander


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 567
 -- Function File: vander (C)
 -- Function File: vander (C, N)
     Return the Vandermonde matrix whose next to last column is C.  If N
     is specified, it determines the number of columns; otherwise, N is
     taken to be equal to the length of C.

     A Vandermonde matrix has the form:

          c(1)^(n-1) ... c(1)^2  c(1)  1
          c(2)^(n-1) ... c(2)^2  c(2)  1
              .     .      .      .    .
              .       .    .      .    .
              .         .  .      .    .
          c(n)^(n-1) ... c(n)^2  c(n)  1

     See also: polyfit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Return the Vandermonde matrix whose next to last column is C.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
wilkinson


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 313
 -- Function File: wilkinson (N)
     Return the Wilkinson matrix of order N.  Wilkinson matrices are
     symmetric and tridiagonal with pairs of nearly, but not exactly,
     equal eigenvalues.  They are useful in testing the behavior and
     performance of eigenvalue solvers.

     See also: rosser, eig.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Return the Wilkinson matrix of order N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
center


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 263
 -- Function File: center (X)
 -- Function File: center (X, DIM)
     If X is a vector, subtract its mean.  If X is a matrix, do the
     above for each column.  If the optional argument DIM is given,
     operate along this dimension.

     See also: zscore.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
If X is a vector, subtract its mean.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cloglog


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 142
 -- Function File: cloglog (X)
     Return the complementary log-log function of X, defined as

          cloglog (x) = - log (- log (X))

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Return the complementary log-log function of X, defined as 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
corr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 506
 -- Function File: corr (X)
 -- Function File: corr (X, Y)
     Compute matrix of correlation coefficients.

     If each row of X and Y is an observation and each column is a
     variable, then the (I, J)-th entry of 'corr (X, Y)' is the
     correlation between the I-th variable in X and the J-th variable in
     Y.

          corr (x,y) = cov (x,y) / (std (x) * std (y))

     If called with one argument, compute 'corr (X, X)', the correlation
     between the columns of X.

     See also: cov.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Compute matrix of correlation coefficients.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
cov


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1228
 -- Function File: cov (X)
 -- Function File: cov (X, OPT)
 -- Function File: cov (X, Y)
 -- Function File: cov (X, Y, OPT)
     Compute the covariance matrix.

     If each row of X and Y is an observation, and each column is a
     variable, then the (I, J)-th entry of 'cov (X, Y)' is the
     covariance between the I-th variable in X and the J-th variable in
     Y.

          cov (x) = 1/N-1 * SUM_i (x(i) - mean(x)) * (y(i) - mean(y))

     If called with one argument, compute 'cov (X, X)', the covariance
     between the columns of X.

     The argument OPT determines the type of normalization to use.
     Valid values are

     0:
          normalize with N-1, provides the best unbiased estimator of
          the covariance [default]

     1:
          normalize with N, this provides the second moment around the
          mean

     MATLAB compatibility: Octave always computes the covariance matrix.
     For two inputs, however, MATLAB will calculate 'cov (X(:), Y(:))'
     whenever the number of elements in X and Y are equal.  This will
     result in a scalar rather than a matrix output.  Code relying on
     this odd definition will need to be changed when running in Octave.

     See also: corr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Compute the covariance matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
gls


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 627
 -- Function File: [BETA, V, R] = gls (Y, X, O)
     Generalized least squares estimation for the multivariate model y = x*b + e
     with mean (e) = 0 and cov (vec (e)) = (s^2) o, where y is a t by p
     matrix, x is a t by k matrix, b is a k by p matrix, e is a t by p
     matrix, and o is a t*p by t*p matrix.

     Each row of Y and X is an observation and each column a variable.
     The return values BETA, V, and R are defined as follows.

     BETA
          The GLS estimator for b.

     V
          The GLS estimator for s^2.

     R
          The matrix of GLS residuals, r = y - x*beta.

     See also: ols.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 249
Generalized least squares estimation for the multivariate model y = x*b + e  with mean (e) = 0 and cov (vec (e)) = (s^2) o, where y is a t by p  matrix, x is a t by k matrix, b is a k by p matrix, e is a t by p  matrix, and o is a t*p by t*p matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
histc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1053
 -- Function File: N = histc (X, EDGES)
 -- Function File: N = histc (X, EDGES, DIM)
 -- Function File: [N, IDX] = histc (...)
     Produce histogram counts.

     When X is a vector, the function counts the number of elements of X
     that fall in the histogram bins defined by EDGES.  This must be a
     vector of monotonically increasing values that define the edges of
     the histogram bins.  'N(k)' contains the number of elements in X
     for which 'EDGES(k) <= X < EDGES(k+1)'.  The final element of N
     contains the number of elements of X exactly equal to the last
     element of EDGES.

     When X is an N-dimensional array, the computation is carried out
     along dimension DIM.  If not specified DIM defaults to the first
     non-singleton dimension.

     When a second output argument is requested an index matrix is also
     returned.  The IDX matrix has the same size as X.  Each element of
     IDX contains the index of the histogram bin in which the
     corresponding element of X was counted.

     See also: hist.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Produce histogram counts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
iqr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 488
 -- Function File: iqr (X)
 -- Function File: iqr (X, DIM)
     Return the interquartile range, i.e., the difference between the
     upper and lower quartile of the input data.  If X is a matrix, do
     the above for first non-singleton dimension of X.

     If the optional argument DIM is given, operate along this
     dimension.

     As a measure of dispersion, the interquartile range is less
     affected by outliers than either 'range' or 'std'.

     See also: range, std.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return the interquartile range, i.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
kendall


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 740
 -- Function File: kendall (X)
 -- Function File: kendall (X, Y)
     Compute Kendall's TAU.

     For two data vectors X, Y of common length N, Kendall's TAU is the
     correlation of the signs of all rank differences of X and Y; i.e.,
     if both X and Y have distinct entries, then

                   1
          tau = -------   SUM sign (q(i) - q(j)) * sign (r(i) - r(j))
                n (n-1)   i,j

     in which the Q(I) and R(I) are the ranks of X and Y, respectively.

     If X and Y are drawn from independent distributions, Kendall's TAU
     is asymptotically normal with mean 0 and variance '(2 * (2N+5)) /
     (9 * N * (N-1))'.

     'kendall (X)' is equivalent to 'kendall (X, X)'.

     See also: ranks, spearman.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Compute Kendall's TAU.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
kurtosis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1195
 -- Function File: kurtosis (X)
 -- Function File: kurtosis (X, FLAG)
 -- Function File: kurtosis (X, FLAG, DIM)
     Compute the sample kurtosis of the elements of X:

               mean ((X - mean (X)).^4)
          k1 = ------------------------
                      std (X).^4

     The optional argument FLAG controls which normalization is used.
     If FLAG is equal to 1 (default value, used when FLAG is omitted or
     empty), return the sample kurtosis as defined above.  If FLAG is
     equal to 0, return the "bias-corrected" kurtosis coefficient
     instead:

                        N - 1
          k0 = 3 + -------------- * ((N + 1) * k1 - 3 * (N - 1))
                   (N - 2)(N - 3)

     The bias-corrected kurtosis coefficient is obtained by replacing
     the sample second and fourth central moments by their unbiased
     versions.  It is an unbiased estimate of the population kurtosis
     for normal populations.

     If X is a matrix, or more generally a multi-dimensional array,
     return the kurtosis along the first non-singleton dimension.  If
     the optional DIM argument is given, operate along this dimension.

     See also: var, skewness, moment.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute the sample kurtosis of the elements of X: 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
logit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
 -- Function File: logit (P)
     For each component of P, return the logit of P defined as

          logit (P) = log (P / (1-P))

     See also: logistic_cdf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
For each component of P, return the logit of P defined as 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
mahalanobis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 253
 -- Function File: mahalanobis (X, Y)
     Return the Mahalanobis' D-square distance between the multivariate
     samples X and Y, which must have the same number of components
     (columns), but may have a different number of observations (rows).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 198
Return the Mahalanobis' D-square distance between the multivariate  samples X and Y, which must have the same number of components  (columns), but may have a different number of observations (rows).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
mean


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 801
 -- Function File: mean (X)
 -- Function File: mean (X, DIM)
 -- Function File: mean (X, OPT)
 -- Function File: mean (X, DIM, OPT)
     Compute the mean of the elements of the vector X.

          mean (x) = SUM_i x(i) / N

     If X is a matrix, compute the mean for each column and return them
     in a row vector.

     The optional argument OPT selects the type of mean to compute.  The
     following options are recognized:

     "a"
          Compute the (ordinary) arithmetic mean.  [default]

     "g"
          Compute the geometric mean.

     "h"
          Compute the harmonic mean.

     If the optional argument DIM is given, operate along this
     dimension.

     Both DIM and OPT are optional.  If both are supplied, either may
     appear first.

     See also: median, mode.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Compute the mean of the elements of the vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
meansq


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 378
 -- Function File: meansq (X)
 -- Function File: meansq (X, DIM)
     Compute the mean square of the elements of the vector X.

          std (x) = 1/N SUM_i x(i)^2

     For matrix arguments, return a row vector containing the mean
     square of each column.

     If the optional argument DIM is given, operate along this
     dimension.

     See also: var, std, moment.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Compute the mean square of the elements of the vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
median


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 536
 -- Function File: median (X)
 -- Function File: median (X, DIM)
     Compute the median value of the elements of the vector X.  If the
     elements of X are sorted, the median is defined as

                        x(ceil(N/2))             N odd
          median (x) =
                       (x(N/2) + x((N/2)+1))/2   N even

     If X is a matrix, compute the median value for each column and
     return them in a row vector.  If the optional DIM argument is
     given, operate along this dimension.

     See also: mean, mode.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Compute the median value of the elements of the vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
mode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 689
 -- Function File: mode (X)
 -- Function File: mode (X, DIM)
 -- Function File: [M, F, C] = mode (...)
     Compute the most frequently occurring value in a dataset (mode).
     'mode' determines the frequency of values along the first
     non-singleton dimension and returns the value with the highest
     frequency.  If two, or more, values have the same frequency 'mode'
     returns the smallest.

     If the optional argument DIM is given, operate along this
     dimension.

     The return variable F is the number of occurrences of the mode in
     in the dataset.  The cell array C contains all of the elements with
     the maximum frequency.

     See also: mean, median.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Compute the most frequently occurring value in a dataset (mode).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
moment


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1155
 -- Function File: moment (X, P)
 -- Function File: moment (X, P, TYPE)
 -- Function File: moment (X, P, DIM)
 -- Function File: moment (X, P, TYPE, DIM)
 -- Function File: moment (X, P, DIM, TYPE)
     Compute the P-th central moment of the vector X.

          1/N SUM_i (x(i) - mean(x))^p

     If X is a matrix, return the row vector containing the P-th central
     moment of each column.

     The optional string TYPE specifies the type of moment to be
     computed.  Valid options are:

     "c"
          Central Moment (default).

     "a"
     "ac"
          Absolute Central Moment.  The moment about the mean ignoring
          sign defined as

               1/N SUM_i (abs (x(i) - mean(x)))^p

     "r"
          Raw Moment.  The moment about zero defined as

               moment (x) = 1/N SUM_i x(i)^p

     "ar"
          Absolute Raw Moment.  The moment about zero ignoring sign
          defined as

               1/N SUM_i ( abs (x(i)) )^p

     If the optional argument DIM is given, operate along this
     dimension.

     If both TYPE and DIM are given they may appear in any order.

     See also: var, skewness, kurtosis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Compute the P-th central moment of the vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
ols


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 932
 -- Function File: [BETA, SIGMA, R] = ols (Y, X)
     Ordinary least squares estimation for the multivariate model y = x*b + e
     with mean (e) = 0 and cov (vec (e)) = kron (s, I).  where y is a t
     by p matrix, x is a t by k matrix, b is a k by p matrix, and e is a
     t by p matrix.

     Each row of Y and X is an observation and each column a variable.

     The return values BETA, SIGMA, and R are defined as follows.

     BETA
          The OLS estimator for b.  BETA is calculated directly via 'inv
          (x'*x) * x' * y' if the matrix 'x'*x' is of full rank.
          Otherwise, 'BETA = pinv (X) * Y' where 'pinv (X)' denotes the
          pseudoinverse of X.

     SIGMA
          The OLS estimator for the matrix S,

               SIGMA = (Y-X*BETA)'
                 * (Y-X*BETA)
                 / (T-rank(X))

     R
          The matrix of OLS residuals, 'R = Y - X*BETA'.

     See also: gls, pinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
Ordinary least squares estimation for the multivariate model y = x*b + e  with mean (e) = 0 and cov (vec (e)) = kron (s, I).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ppplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 866
 -- Function File: [P, Y] = ppplot (X, DIST, PARAMS)
     Perform a PP-plot (probability plot).

     If F is the CDF of the distribution DIST with parameters PARAMS and
     X a sample vector of length N, the PP-plot graphs ordinate Y(I) = F
     (I-th largest element of X) versus abscissa P(I) = (I - 0.5)/N.  If
     the sample comes from F, the pairs will approximately follow a
     straight line.

     The default for DIST is the standard normal distribution.  The
     optional argument PARAMS contains a list of parameters of DIST.
     For example, for a probability plot of the uniform distribution on
     [2,4] and X, use

          ppplot (x, "uniform", 2, 4)

     DIST can be any string for which a function DIST_CDF that
     calculates the CDF of distribution DIST exists.

     If no output arguments are given, the data are plotted directly.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Perform a PP-plot (probability plot).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
prctile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 856
 -- Function File: Q = prctile (X)
 -- Function File: Q = prctile (X, P)
 -- Function File: Q = prctile (X, P, DIM)
     For a sample X, compute the quantiles, Q, corresponding to the
     cumulative probability values, P, in percent.  All non-numeric
     values (NaNs) of X are ignored.

     If X is a matrix, compute the percentiles for each column and
     return them in a matrix, such that the i-th row of Y contains the
     P(i)th percentiles of each column of X.

     If P is unspecified, return the quantiles for '[0 25 50 75 100]'.
     The optional argument DIM determines the dimension along which the
     percentiles are calculated.  If DIM is omitted, and X is a vector
     or matrix, it defaults to 1 (column-wise quantiles).  When X is an
     N-D array, DIM defaults to the first non-singleton dimension.

     See also: quantile.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
For a sample X, compute the quantiles, Q, corresponding to the  cumulative probability values, P, in percent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
probit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
 -- Function File: probit (P)
     For each component of P, return the probit (the quantile of the
     standard normal distribution) of P.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
For each component of P, return the probit (the quantile of the  standard normal distribution) of P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
qqplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1194
 -- Function File: [Q, S] = qqplot (X)
 -- Function File: [Q, S] = qqplot (X, Y)
 -- Function File: [Q, S] = qqplot (X, DIST)
 -- Function File: [Q, S] = qqplot (X, Y, PARAMS)
 -- Function File: qqplot (...)
     Perform a QQ-plot (quantile plot).

     If F is the CDF of the distribution DIST with parameters PARAMS and
     G its inverse, and X a sample vector of length N, the QQ-plot
     graphs ordinate S(I) = I-th largest element of x versus abscissa
     Q(If) = G((I - 0.5)/N).

     If the sample comes from F, except for a transformation of location
     and scale, the pairs will approximately follow a straight line.

     If the second argument is a vector Y the empirical CDF of Y is used
     as DIST.

     The default for DIST is the standard normal distribution.  The
     optional argument PARAMS contains a list of parameters of DIST.
     For example, for a quantile plot of the uniform distribution on
     [2,4] and X, use

          qqplot (x, "unif", 2, 4)

     DIST can be any string for which a function DISTINV or DIST_INV
     exists that calculates the inverse CDF of distribution DIST.

     If no output arguments are given, the data are plotted directly.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Perform a QQ-plot (quantile plot).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
quantile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3085
 -- Function File: Q = quantile (X)
 -- Function File: Q = quantile (X, P)
 -- Function File: Q = quantile (X, P, DIM)
 -- Function File: Q = quantile (X, P, DIM, METHOD)
     For a sample, X, calculate the quantiles, Q, corresponding to the
     cumulative probability values in P.  All non-numeric values (NaNs)
     of X are ignored.

     If X is a matrix, compute the quantiles for each column and return
     them in a matrix, such that the i-th row of Q contains the P(i)th
     quantiles of each column of X.

     If P is unspecified, return the quantiles for '[0.00 0.25 0.50 0.75
     1.00]'.  The optional argument DIM determines the dimension along
     which the quantiles are calculated.  If DIM is omitted, and X is a
     vector or matrix, it defaults to 1 (column-wise quantiles).  If X
     is an N-D array, DIM defaults to the first non-singleton dimension.

     The methods available to calculate sample quantiles are the nine
     methods used by R (<http://www.r-project.org/>).  The default value
     is METHOD = 5.

     Discontinuous sample quantile methods 1, 2, and 3

       1. Method 1: Inverse of empirical distribution function.

       2. Method 2: Similar to method 1 but with averaging at
          discontinuities.

       3. Method 3: SAS definition: nearest even order statistic.

     Continuous sample quantile methods 4 through 9, where p(k) is the
     linear interpolation function respecting each methods'
     representative cdf.

       4. Method 4: p(k) = k / n.  That is, linear interpolation of the
          empirical cdf.

       5. Method 5: p(k) = (k - 0.5) / n.  That is a piecewise linear
          function where the knots are the values midway through the
          steps of the empirical cdf.

       6. Method 6: p(k) = k / (n + 1).

       7. Method 7: p(k) = (k - 1) / (n - 1).

       8. Method 8: p(k) = (k - 1/3) / (n + 1/3).  The resulting
          quantile estimates are approximately median-unbiased
          regardless of the distribution of X.

       9. Method 9: p(k) = (k - 3/8) / (n + 1/4).  The resulting
          quantile estimates are approximately unbiased for the expected
          order statistics if X is normally distributed.

     Hyndman and Fan (1996) recommend method 8.  Maxima, S, and R
     (versions prior to 2.0.0) use 7 as their default.  Minitab and SPSS
     use method 6.  MATLAB uses method 5.

     References:

        * Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) The New
          S Language.  Wadsworth & Brooks/Cole.

        * Hyndman, R. J. and Fan, Y. (1996) Sample quantiles in
          statistical packages, American Statistician, 50, 361-365.

        * R: A Language and Environment for Statistical Computing;
          <http://cran.r-project.org/doc/manuals/fullrefman.pdf>.

     Examples:

          x = randi (1000, [10, 1]);  # Create empirical data in range 1-1000
          q = quantile (x, [0, 1]);   # Return minimum, maximum of distribution
          q = quantile (x, [0.25 0.5 0.75]); # Return quartiles of distribution

     See also: prctile.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
For a sample, X, calculate the quantiles, Q, corresponding to the  cumulative probability values in P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
range


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 575
 -- Function File: range (X)
 -- Function File: range (X, DIM)
     Return the range, i.e., the difference between the maximum and the
     minimum of the input data.  If X is a vector, the range is
     calculated over the elements of X.  If X is a matrix, the range is
     calculated over each column of X.

     If the optional argument DIM is given, operate along this
     dimension.

     The range is a quickly computed measure of the dispersion of a data
     set, but is less accurate than 'iqr' if there are outlying data
     points.

     See also: iqr, std.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Return the range, i.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ranks


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 238
 -- Function File: ranks (X, DIM)
     Return the ranks of X along the first non-singleton dimension
     adjusted for ties.  If the optional argument DIM is given, operate
     along this dimension.

     See also: spearman, kendall.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 81
Return the ranks of X along the first non-singleton dimension  adjusted for ties.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
run_count


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 298
 -- Function File: run_count (X, N)
 -- Function File: run_count (X, N, DIM)
     Count the upward runs along the first non-singleton dimension of X
     of length 1, 2, ..., N-1 and greater than or equal to N.

     If the optional argument DIM is given then operate along this
     dimension.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
Count the upward runs along the first non-singleton dimension of X  of length 1, 2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
runlength


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 265
 -- Function File: [count, value] = runlength (X)
     Find the lengths of all sequences of common values.  Return the
     vector of lengths and the value that was repeated.

          runlength ([2, 2, 0, 4, 4, 4, 0, 1, 1, 1, 1])
          =>  [2, 1, 3, 1, 4]
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Find the lengths of all sequences of common values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
skewness


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1203
 -- Function File: skewness (X)
 -- Function File: skewness (X, FLAG)
 -- Function File: skewness (X, FLAG, DIM)
     Compute the sample skewness of the elements of X:

                         mean ((X - mean (X)).^3)
          skewness (X) = ------------------------.
                                std (X).^3

     The optional argument FLAG controls which normalization is used.
     If FLAG is equal to 1 (default value, used when FLAG is omitted or
     empty), return the sample skewness as defined above.  If FLAG is
     equal to 0, return the adjusted skewness coefficient instead:

                            sqrt (N*(N-1))   mean ((X - mean (X)).^3)
          skewness (X, 0) = -------------- * ------------------------.
                                (N - 2)             std (X).^3

     The adjusted skewness coefficient is obtained by replacing the
     sample second and third central moments by their bias-corrected
     versions.

     If X is a matrix, or more generally a multi-dimensional array,
     return the skewness along the first non-singleton dimension.  If
     the optional DIM argument is given, operate along this dimension.

     See also: var, kurtosis, moment.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute the sample skewness of the elements of X: 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
spearman


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 488
 -- Function File: spearman (X)
 -- Function File: spearman (X, Y)
     Compute Spearman's rank correlation coefficient RHO.

     For two data vectors X and Y, Spearman's RHO is the correlation
     coefficient of the ranks of X and Y.

     If X and Y are drawn from independent distributions, RHO has zero
     mean and variance '1 / (n - 1)', and is asymptotically normally
     distributed.

     'spearman (X)' is equivalent to 'spearman (X, X)'.

     See also: ranks, kendall.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute Spearman's rank correlation coefficient RHO.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
statistics


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 486
 -- Function File: statistics (X)
 -- Function File: statistics (X, DIM)
     Return a vector with the minimum, first quartile, median, third
     quartile, maximum, mean, standard deviation, skewness, and kurtosis
     of the elements of the vector X.

     If X is a matrix, calculate statistics over the first non-singleton
     dimension.  If the optional argument DIM is given, operate along
     this dimension.

     See also: min, max, median, mean, std, skewness, kurtosis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 166
Return a vector with the minimum, first quartile, median, third  quartile, maximum, mean, standard deviation, skewness, and kurtosis  of the elements of the vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
std


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 843
 -- Function File: std (X)
 -- Function File: std (X, OPT)
 -- Function File: std (X, OPT, DIM)
     Compute the standard deviation of the elements of the vector X.

          std (x) = sqrt ( 1/(N-1) SUM_i (x(i) - mean(x))^2 )

     where N is the number of elements.

     If X is a matrix, compute the standard deviation for each column
     and return them in a row vector.

     The argument OPT determines the type of normalization to use.
     Valid values are

     0:
          normalize with N-1, provides the square root of the best
          unbiased estimator of the variance [default]

     1:
          normalize with N, this provides the square root of the second
          moment around the mean

     If the optional argument DIM is given, operate along this
     dimension.

     See also: var, range, iqr, mean, median.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Compute the standard deviation of the elements of the vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
table


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 269
 -- Function File: [T, L_X] = table (X)
 -- Function File: [T, L_X, L_Y] = table (X, Y)
     Create a contingency table T from data vectors.  The L_X and L_Y
     vectors are the corresponding levels.

     Currently, only 1- and 2-dimensional tables are supported.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Create a contingency table T from data vectors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
var


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 817
 -- Function File: var (X)
 -- Function File: var (X, OPT)
 -- Function File: var (X, OPT, DIM)
     Compute the variance of the elements of the vector X.

          var (x) = 1/(N-1) SUM_i (x(i) - mean(x))^2

     If X is a matrix, compute the variance for each column and return
     them in a row vector.

     The argument OPT determines the type of normalization to use.
     Valid values are

     0:
          normalize with N-1, provides the best unbiased estimator of
          the variance [default]

     1:
          normalizes with N, this provides the second moment around the
          mean

     If N==1 the value of OPT is ignored and normalization by N is used.

     If the optional argument DIM is given, operate along this
     dimension.

     See also: cov, std, skewness, kurtosis, moment.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute the variance of the elements of the vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
zscore


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 766
 -- Function File: [Z, MU, SIGMA] = zscore (X)
 -- Function File: [Z, MU, SIGMA] = zscore (X, OPT)
 -- Function File: [Z, MU, SIGMA] = zscore (X, OPT, DIM)
     If X is a vector, subtract its mean and divide by its standard
     deviation.  If the standard deviation is zero, divide by 1 instead.
     The optional parameter OPT determines the normalization to use when
     computing the standard deviation and is the same as the
     corresponding parameter for 'std'.

     If X is a matrix, do the above along the first non-singleton
     dimension.  If the third optional argument DIM is given, operate
     along this dimension.

     The mean and standard deviation along DIM are given in MU and SIGMA
     respectively.

     See also: mean, std, center.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
If X is a vector, subtract its mean and divide by its standard  deviation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
betacdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 179
 -- Function File: betacdf (X, A, B)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the Beta distribution with parameters A and B.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
For each element of X, compute the cumulative distribution function  (CDF) at X of the Beta distribution with parameters A and B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
betainv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 174
 -- Function File: betainv (X, A, B)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the Beta distribution with parameters A and B.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
For each element of X, compute the quantile (the inverse of the  CDF) at X of the Beta distribution with parameters A and B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
betapdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 175
 -- Function File: betapdf (X, A, B)
     For each element of X, compute the probability density function
     (PDF) at X of the Beta distribution with parameters A and B.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
For each element of X, compute the probability density function  (PDF) at X of the Beta distribution with parameters A and B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
betarnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 720
 -- Function File: betarnd (A, B)
 -- Function File: betarnd (A, B, R)
 -- Function File: betarnd (A, B, R, C, ...)
 -- Function File: betarnd (A, B, [SZ])
     Return a matrix of random samples from the Beta distribution with
     parameters A and B.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the common
     size of A and B.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Return a matrix of random samples from the Beta distribution with  parameters A and B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
binocdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 262
 -- Function File: binocdf (X, N, P)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the binomial distribution with parameters N and P,
     where N is the number of trials and P is the probability of
     success.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 204
For each element of X, compute the cumulative distribution function  (CDF) at X of the binomial distribution with parameters N and P,  where N is the number of trials and P is the probability of  success.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
binoinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 257
 -- Function File: binoinv (X, N, P)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the binomial distribution with parameters N and P,
     where N is the number of trials and P is the probability of
     success.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 199
For each element of X, compute the quantile (the inverse of the  CDF) at X of the binomial distribution with parameters N and P,  where N is the number of trials and P is the probability of  success.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
binopdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 258
 -- Function File: binopdf (X, N, P)
     For each element of X, compute the probability density function
     (PDF) at X of the binomial distribution with parameters N and P,
     where N is the number of trials and P is the probability of
     success.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 200
For each element of X, compute the probability density function  (PDF) at X of the binomial distribution with parameters N and P,  where N is the number of trials and P is the probability of  success.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
binornd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 798
 -- Function File: binornd (N, P)
 -- Function File: binornd (N, P, R)
 -- Function File: binornd (N, P, R, C, ...)
 -- Function File: binornd (N, P, [SZ])
     Return a matrix of random samples from the binomial distribution
     with parameters N and P, where N is the number of trials and P is
     the probability of success.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the common
     size of N and P.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 160
Return a matrix of random samples from the binomial distribution  with parameters N and P, where N is the number of trials and P is  the probability of success.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
cauchy_cdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 319
 -- Function File: cauchy_cdf (X)
 -- Function File: cauchy_cdf (X, LOCATION, SCALE)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the Cauchy distribution with location parameter
     LOCATION and scale parameter SCALE.  Default values are LOCATION =
     0, SCALE = 1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 167
For each element of X, compute the cumulative distribution function  (CDF) at X of the Cauchy distribution with location parameter  LOCATION and scale parameter SCALE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
cauchy_inv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 314
 -- Function File: cauchy_inv (X)
 -- Function File: cauchy_inv (X, LOCATION, SCALE)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the Cauchy distribution with location parameter
     LOCATION and scale parameter SCALE.  Default values are LOCATION =
     0, SCALE = 1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 162
For each element of X, compute the quantile (the inverse of the  CDF) at X of the Cauchy distribution with location parameter  LOCATION and scale parameter SCALE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
cauchy_pdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 319
 -- Function File: cauchy_pdf (X)
 -- Function File: cauchy_pdf (X, LOCATION, SCALE)
     For each element of X, compute the probability density function
     (PDF) at X of the Cauchy distribution with location parameter
     LOCATION and scale parameter SCALE > 0.  Default values are
     LOCATION = 0, SCALE = 1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 167
For each element of X, compute the probability density function  (PDF) at X of the Cauchy distribution with location parameter  LOCATION and scale parameter SCALE > 0.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
cauchy_rnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 800
 -- Function File: cauchy_rnd (LOCATION, SCALE)
 -- Function File: cauchy_rnd (LOCATION, SCALE, R)
 -- Function File: cauchy_rnd (LOCATION, SCALE, R, C, ...)
 -- Function File: cauchy_rnd (LOCATION, SCALE, [SZ])
     Return a matrix of random samples from the Cauchy distribution with
     parameters LOCATION and SCALE.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the common
     size of LOCATION and SCALE.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
Return a matrix of random samples from the Cauchy distribution with  parameters LOCATION and SCALE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
chi2cdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 189
 -- Function File: chi2cdf (X, N)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the chi-square distribution with N degrees of
     freedom.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 138
For each element of X, compute the cumulative distribution function  (CDF) at X of the chi-square distribution with N degrees of  freedom.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
chi2inv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 179
 -- Function File: chi2inv (X, N)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the chi-square distribution with N degrees of freedom.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
For each element of X, compute the quantile (the inverse of the  CDF) at X of the chi-square distribution with N degrees of freedom.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
chi2pdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 185
 -- Function File: chi2pdf (X, N)
     For each element of X, compute the probability density function
     (PDF) at X of the chi-square distribution with N degrees of
     freedom.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
For each element of X, compute the probability density function  (PDF) at X of the chi-square distribution with N degrees of  freedom.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
chi2rnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 703
 -- Function File: chi2rnd (N)
 -- Function File: chi2rnd (N, R)
 -- Function File: chi2rnd (N, R, C, ...)
 -- Function File: chi2rnd (N, [SZ])
     Return a matrix of random samples from the chi-square distribution
     with N degrees of freedom.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the size
     of N.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 94
Return a matrix of random samples from the chi-square distribution  with N degrees of freedom.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
discrete_cdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 229
 -- Function File: discrete_cdf (X, V, P)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of a univariate discrete distribution which assumes the
     values in V with probabilities P.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 170
For each element of X, compute the cumulative distribution function  (CDF) at X of a univariate discrete distribution which assumes the  values in V with probabilities P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
discrete_inv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 217
 -- Function File: discrete_inv (X, V, P)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the univariate distribution which assumes the values
     in V with probabilities P.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 158
For each element of X, compute the quantile (the inverse of the  CDF) at X of the univariate distribution which assumes the values  in V with probabilities P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
discrete_pdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 225
 -- Function File: discrete_pdf (X, V, P)
     For each element of X, compute the probability density function
     (PDF) at X of a univariate discrete distribution which assumes the
     values in V with probabilities P.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 166
For each element of X, compute the probability density function  (PDF) at X of a univariate discrete distribution which assumes the  values in V with probabilities P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
discrete_rnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 773
 -- Function File: discrete_rnd (V, P)
 -- Function File: discrete_rnd (V, P, R)
 -- Function File: discrete_rnd (V, P, R, C, ...)
 -- Function File: discrete_rnd (V, P, [SZ])
     Return a matrix of random samples from the univariate distribution
     which assumes the values in V with probabilities P.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the common
     size of V and P.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 119
Return a matrix of random samples from the univariate distribution  which assumes the values in V with probabilities P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
empirical_cdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 212
 -- Function File: empirical_cdf (X, DATA)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the empirical distribution obtained from the
     univariate sample DATA.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
For each element of X, compute the cumulative distribution function  (CDF) at X of the empirical distribution obtained from the  univariate sample DATA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
empirical_inv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 207
 -- Function File: empirical_inv (X, DATA)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the empirical distribution obtained from the
     univariate sample DATA.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 147
For each element of X, compute the quantile (the inverse of the  CDF) at X of the empirical distribution obtained from the  univariate sample DATA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
empirical_pdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 208
 -- Function File: empirical_pdf (X, DATA)
     For each element of X, compute the probability density function
     (PDF) at X of the empirical distribution obtained from the
     univariate sample DATA.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 148
For each element of X, compute the probability density function  (PDF) at X of the empirical distribution obtained from the  univariate sample DATA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
empirical_rnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 776
 -- Function File: empirical_rnd (DATA)
 -- Function File: empirical_rnd (DATA, R)
 -- Function File: empirical_rnd (DATA, R, C, ...)
 -- Function File: empirical_rnd (DATA, [SZ])
     Return a matrix of random samples from the empirical distribution
     obtained from the univariate sample DATA.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is a random
     ordering of the sample DATA.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
Return a matrix of random samples from the empirical distribution  obtained from the univariate sample DATA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
expcdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 234
 -- Function File: expcdf (X, LAMBDA)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the exponential distribution with mean LAMBDA.

     The arguments can be of common size or scalars.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
For each element of X, compute the cumulative distribution function  (CDF) at X of the exponential distribution with mean LAMBDA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
expinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 175
 -- Function File: expinv (X, LAMBDA)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the exponential distribution with mean LAMBDA.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
For each element of X, compute the quantile (the inverse of the  CDF) at X of the exponential distribution with mean LAMBDA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
exppdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 176
 -- Function File: exppdf (X, LAMBDA)
     For each element of X, compute the probability density function
     (PDF) at X of the exponential distribution with mean LAMBDA.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
For each element of X, compute the probability density function  (PDF) at X of the exponential distribution with mean LAMBDA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
exprnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 716
 -- Function File: exprnd (LAMBDA)
 -- Function File: exprnd (LAMBDA, R)
 -- Function File: exprnd (LAMBDA, R, C, ...)
 -- Function File: exprnd (LAMBDA, [SZ])
     Return a matrix of random samples from the exponential distribution
     with mean LAMBDA.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the size
     of LAMBDA.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Return a matrix of random samples from the exponential distribution  with mean LAMBDA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fcdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 181
 -- Function File: fcdf (X, M, N)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the F distribution with M and N degrees of freedom.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
For each element of X, compute the cumulative distribution function  (CDF) at X of the F distribution with M and N degrees of freedom.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
finv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 176
 -- Function File: finv (X, M, N)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the F distribution with M and N degrees of freedom.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
For each element of X, compute the quantile (the inverse of the  CDF) at X of the F distribution with M and N degrees of freedom.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fpdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 177
 -- Function File: fpdf (X, M, N)
     For each element of X, compute the probability density function
     (PDF) at X of the F distribution with M and N degrees of freedom.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 130
For each element of X, compute the probability density function  (PDF) at X of the F distribution with M and N degrees of freedom.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
frnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 713
 -- Function File: frnd (M, N)
 -- Function File: frnd (M, N, R)
 -- Function File: frnd (M, N, R, C, ...)
 -- Function File: frnd (M, N, [SZ])
     Return a matrix of random samples from the F distribution with M
     and N degrees of freedom.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the common
     size of M and N.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
Return a matrix of random samples from the F distribution with M  and N degrees of freedom.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gamcdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 195
 -- Function File: gamcdf (X, A, B)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the Gamma distribution with shape parameter A and
     scale B.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 142
For each element of X, compute the cumulative distribution function  (CDF) at X of the Gamma distribution with shape parameter A and  scale B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gaminv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 190
 -- Function File: gaminv (X, A, B)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the Gamma distribution with shape parameter A and
     scale B.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 137
For each element of X, compute the quantile (the inverse of the  CDF) at X of the Gamma distribution with shape parameter A and  scale B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gampdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 190
 -- Function File: gampdf (X, A, B)
     For each element of X, return the probability density function
     (PDF) at X of the Gamma distribution with shape parameter A and
     scale B.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 137
For each element of X, return the probability density function  (PDF) at X of the Gamma distribution with shape parameter A and  scale B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gamrnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 728
 -- Function File: gamrnd (A, B)
 -- Function File: gamrnd (A, B, R)
 -- Function File: gamrnd (A, B, R, C, ...)
 -- Function File: gamrnd (A, B, [SZ])
     Return a matrix of random samples from the Gamma distribution with
     shape parameter A and scale B.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the common
     size of A and B.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Return a matrix of random samples from the Gamma distribution with  shape parameter A and scale B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
geocdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 317
 -- Function File: geocdf (X, P)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the geometric distribution with parameter P.

     The geometric distribution models the number of failures (X-1) of a
     Bernoulli trial with probability P before the first success (X).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
For each element of X, compute the cumulative distribution function  (CDF) at X of the geometric distribution with parameter P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
geoinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 312
 -- Function File: geoinv (X, P)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the geometric distribution with parameter P.

     The geometric distribution models the number of failures (X-1) of a
     Bernoulli trial with probability P before the first success (X).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 122
For each element of X, compute the quantile (the inverse of the  CDF) at X of the geometric distribution with parameter P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
geopdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 313
 -- Function File: geopdf (X, P)
     For each element of X, compute the probability density function
     (PDF) at X of the geometric distribution with parameter P.

     The geometric distribution models the number of failures (X-1) of a
     Bernoulli trial with probability P before the first success (X).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
For each element of X, compute the probability density function  (PDF) at X of the geometric distribution with parameter P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
geornd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 833
 -- Function File: geornd (P)
 -- Function File: geornd (P, R)
 -- Function File: geornd (P, R, C, ...)
 -- Function File: geornd (P, [SZ])
     Return a matrix of random samples from the geometric distribution
     with parameter P.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the size
     of P.

     The geometric distribution models the number of failures (X-1) of a
     Bernoulli trial with probability P before the first success (X).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Return a matrix of random samples from the geometric distribution  with parameter P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hygecdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 474
 -- Function File: hygecdf (X, T, M, N)
     Compute the cumulative distribution function (CDF) at X of the
     hypergeometric distribution with parameters T, M, and N.  This is
     the probability of obtaining not more than X marked items when
     randomly drawing a sample of size N without replacement from a
     population of total size T containing M marked items.

     The parameters T, M, and N must be positive integers with M and N
     not greater than T.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 120
Compute the cumulative distribution function (CDF) at X of the  hypergeometric distribution with parameters T, M, and N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hygeinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 478
 -- Function File: hygeinv (X, T, M, N)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the hypergeometric distribution with parameters T, M,
     and N.  This is the probability of obtaining X marked items when
     randomly drawing a sample of size N without replacement from a
     population of total size T containing M marked items.

     The parameters T, M, and N must be positive integers with M and N
     not greater than T.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 139
For each element of X, compute the quantile (the inverse of the  CDF) at X of the hypergeometric distribution with parameters T, M,  and N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hygepdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 456
 -- Function File: hygepdf (X, T, M, N)
     Compute the probability density function (PDF) at X of the
     hypergeometric distribution with parameters T, M, and N.  This is
     the probability of obtaining X marked items when randomly drawing a
     sample of size N without replacement from a population of total
     size T containing M marked items.

     The parameters T, M, and N must be positive integers with M and N
     not greater than T.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
Compute the probability density function (PDF) at X of the  hypergeometric distribution with parameters T, M, and N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hygernd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 847
 -- Function File: hygernd (T, M, N)
 -- Function File: hygernd (T, M, N, R)
 -- Function File: hygernd (T, M, N, R, C, ...)
 -- Function File: hygernd (T, M, N, [SZ])
     Return a matrix of random samples from the hypergeometric
     distribution with parameters T, M, and N.

     The parameters T, M, and N must be positive integers with M and N
     not greater than T.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the common
     size of T, M, and N.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
Return a matrix of random samples from the hypergeometric  distribution with parameters T, M, and N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
kolmogorov_smirnov_cdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 410
 -- Function File: kolmogorov_smirnov_cdf (X, TOL)
     Return the cumulative distribution function (CDF) at X of the
     Kolmogorov-Smirnov distribution,

                   Inf
          Q(x) =   SUM    (-1)^k exp (-2 k^2 x^2)
                 k = -Inf

     for X > 0.

     The optional parameter TOL specifies the precision up to which the
     series should be evaluated; the default is TOL = 'eps'.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Return the cumulative distribution function (CDF) at X of the  Kolmogorov-Smirnov distribution, 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
laplace_cdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 156
 -- Function File: laplace_cdf (X)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the Laplace distribution.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
For each element of X, compute the cumulative distribution function  (CDF) at X of the Laplace distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
laplace_inv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 151
 -- Function File: laplace_inv (X)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the Laplace distribution.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
For each element of X, compute the quantile (the inverse of the  CDF) at X of the Laplace distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
laplace_pdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
 -- Function File: laplace_pdf (X)
     For each element of X, compute the probability density function
     (PDF) at X of the Laplace distribution.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
For each element of X, compute the probability density function  (PDF) at X of the Laplace distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
laplace_rnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 558
 -- Function File: laplace_rnd (R)
 -- Function File: laplace_rnd (R, C, ...)
 -- Function File: laplace_rnd ([SZ])
     Return a matrix of random samples from the Laplace distribution.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return a matrix of random samples from the Laplace distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
logistic_cdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 158
 -- Function File: logistic_cdf (X)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the logistic distribution.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
For each element of X, compute the cumulative distribution function  (CDF) at X of the logistic distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
logistic_inv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
 -- Function File: logistic_inv (X)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the logistic distribution.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
For each element of X, compute the quantile (the inverse of the  CDF) at X of the logistic distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
logistic_pdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
 -- Function File: logistic_pdf (X)
     For each element of X, compute the PDF at X of the logistic
     distribution.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
For each element of X, compute the PDF at X of the logistic  distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
logistic_rnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 562
 -- Function File: logistic_rnd (R)
 -- Function File: logistic_rnd (R, C, ...)
 -- Function File: logistic_rnd ([SZ])
     Return a matrix of random samples from the logistic distribution.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return a matrix of random samples from the logistic distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
logncdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 414
 -- Function File: logncdf (X)
 -- Function File: logncdf (X, MU, SIGMA)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the lognormal distribution with parameters MU and
     SIGMA.  If a random variable follows this distribution, its
     logarithm is normally distributed with mean MU and standard
     deviation SIGMA.

     Default values are MU = 0, SIGMA = 1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 140
For each element of X, compute the cumulative distribution function  (CDF) at X of the lognormal distribution with parameters MU and  SIGMA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
logninv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 409
 -- Function File: logninv (X)
 -- Function File: logninv (X, MU, SIGMA)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the lognormal distribution with parameters MU and
     SIGMA.  If a random variable follows this distribution, its
     logarithm is normally distributed with mean MU and standard
     deviation SIGMA.

     Default values are MU = 0, SIGMA = 1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
For each element of X, compute the quantile (the inverse of the  CDF) at X of the lognormal distribution with parameters MU and  SIGMA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
lognpdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 410
 -- Function File: lognpdf (X)
 -- Function File: lognpdf (X, MU, SIGMA)
     For each element of X, compute the probability density function
     (PDF) at X of the lognormal distribution with parameters MU and
     SIGMA.  If a random variable follows this distribution, its
     logarithm is normally distributed with mean MU and standard
     deviation SIGMA.

     Default values are MU = 0, SIGMA = 1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 136
For each element of X, compute the probability density function  (PDF) at X of the lognormal distribution with parameters MU and  SIGMA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
lognrnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 755
 -- Function File: lognrnd (MU, SIGMA)
 -- Function File: lognrnd (MU, SIGMA, R)
 -- Function File: lognrnd (MU, SIGMA, R, C, ...)
 -- Function File: lognrnd (MU, SIGMA, [SZ])
     Return a matrix of random samples from the lognormal distribution
     with parameters MU and SIGMA.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the common
     size of MU and SIGMA.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Return a matrix of random samples from the lognormal distribution  with parameters MU and SIGMA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nbincdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 465
 -- Function File: nbincdf (X, N, P)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the negative binomial distribution with parameters N
     and P.

     When N is integer this is the Pascal distribution.  When N is
     extended to real numbers this is the Polya distribution.

     The number of failures in a Bernoulli experiment with success
     probability P before the N-th success follows this distribution.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
For each element of X, compute the cumulative distribution function  (CDF) at X of the negative binomial distribution with parameters N  and P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nbininv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 460
 -- Function File: nbininv (X, N, P)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the negative binomial distribution with parameters N
     and P.

     When N is integer this is the Pascal distribution.  When N is
     extended to real numbers this is the Polya distribution.

     The number of failures in a Bernoulli experiment with success
     probability P before the N-th success follows this distribution.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 138
For each element of X, compute the quantile (the inverse of the  CDF) at X of the negative binomial distribution with parameters N  and P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nbinpdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 461
 -- Function File: nbinpdf (X, N, P)
     For each element of X, compute the probability density function
     (PDF) at X of the negative binomial distribution with parameters N
     and P.

     When N is integer this is the Pascal distribution.  When N is
     extended to real numbers this is the Polya distribution.

     The number of failures in a Bernoulli experiment with success
     probability P before the N-th success follows this distribution.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 139
For each element of X, compute the probability density function  (PDF) at X of the negative binomial distribution with parameters N  and P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nbinrnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 733
 -- Function File: nbinrnd (N, P)
 -- Function File: nbinrnd (N, P, R)
 -- Function File: nbinrnd (N, P, R, C, ...)
 -- Function File: nbinrnd (N, P, [SZ])
     Return a matrix of random samples from the negative binomial
     distribution with parameters N and P.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the common
     size of N and P.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
Return a matrix of random samples from the negative binomial  distribution with parameters N and P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
normcdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 284
 -- Function File: normcdf (X)
 -- Function File: normcdf (X, MU, SIGMA)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the normal distribution with mean MU and standard
     deviation SIGMA.

     Default values are MU = 0, SIGMA = 1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
For each element of X, compute the cumulative distribution function  (CDF) at X of the normal distribution with mean MU and standard  deviation SIGMA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
norminv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 279
 -- Function File: norminv (X)
 -- Function File: norminv (X, MU, SIGMA)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the normal distribution with mean MU and standard
     deviation SIGMA.

     Default values are MU = 0, SIGMA = 1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 145
For each element of X, compute the quantile (the inverse of the  CDF) at X of the normal distribution with mean MU and standard  deviation SIGMA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
normpdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 280
 -- Function File: normpdf (X)
 -- Function File: normpdf (X, MU, SIGMA)
     For each element of X, compute the probability density function
     (PDF) at X of the normal distribution with mean MU and standard
     deviation SIGMA.

     Default values are MU = 0, SIGMA = 1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 146
For each element of X, compute the probability density function  (PDF) at X of the normal distribution with mean MU and standard  deviation SIGMA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
normrnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 776
 -- Function File: normrnd (MU, SIGMA)
 -- Function File: normrnd (MU, SIGMA, R)
 -- Function File: normrnd (MU, SIGMA, R, C, ...)
 -- Function File: normrnd (MU, SIGMA, [SZ])
     Return a matrix of random samples from the normal distribution with
     parameters mean MU and standard deviation SIGMA.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the common
     size of MU and SIGMA.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
Return a matrix of random samples from the normal distribution with  parameters mean MU and standard deviation SIGMA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
poisscdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 183
 -- Function File: poisscdf (X, LAMBDA)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the Poisson distribution with parameter lambda.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 130
For each element of X, compute the cumulative distribution function  (CDF) at X of the Poisson distribution with parameter lambda.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
poissinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 178
 -- Function File: poissinv (X, LAMBDA)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the Poisson distribution with parameter LAMBDA.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
For each element of X, compute the quantile (the inverse of the  CDF) at X of the Poisson distribution with parameter LAMBDA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
poisspdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 179
 -- Function File: poisspdf (X, LAMBDA)
     For each element of X, compute the probability density function
     (PDF) at X of the Poisson distribution with parameter LAMBDA.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
For each element of X, compute the probability density function  (PDF) at X of the Poisson distribution with parameter LAMBDA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
poissrnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 725
 -- Function File: poissrnd (LAMBDA)
 -- Function File: poissrnd (LAMBDA, R)
 -- Function File: poissrnd (LAMBDA, R, C, ...)
 -- Function File: poissrnd (LAMBDA, [SZ])
     Return a matrix of random samples from the Poisson distribution
     with parameter LAMBDA.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the size
     of LAMBDA.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Return a matrix of random samples from the Poisson distribution  with parameter LAMBDA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
stdnormal_cdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 206
 -- Function File: stdnormal_cdf (X)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the standard normal distribution (mean = 0, standard
     deviation = 1).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
For each element of X, compute the cumulative distribution function  (CDF) at X of the standard normal distribution (mean = 0, standard  deviation = 1).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
stdnormal_inv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 201
 -- Function File: stdnormal_inv (X)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the standard normal distribution (mean = 0, standard
     deviation = 1).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 147
For each element of X, compute the quantile (the inverse of the  CDF) at X of the standard normal distribution (mean = 0, standard  deviation = 1).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
stdnormal_pdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 202
 -- Function File: stdnormal_pdf (X)
     For each element of X, compute the probability density function
     (PDF) at X of the standard normal distribution (mean = 0, standard
     deviation = 1).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 148
For each element of X, compute the probability density function  (PDF) at X of the standard normal distribution (mean = 0, standard  deviation = 1).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
stdnormal_rnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 612
 -- Function File: stdnormal_rnd (R)
 -- Function File: stdnormal_rnd (R, C, ...)
 -- Function File: stdnormal_rnd ([SZ])
     Return a matrix of random samples from the standard normal
     distribution (mean = 0, standard deviation = 1).

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
Return a matrix of random samples from the standard normal  distribution (mean = 0, standard deviation = 1).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
tcdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 211
 -- Function File: tcdf (X, N)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the t (Student) distribution with N degrees of
     freedom, i.e., PROB (t(N) <= X).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 142
For each element of X, compute the cumulative distribution function  (CDF) at X of the t (Student) distribution with N degrees of  freedom, i.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
tinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 286
 -- Function File: tinv (X, N)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the t (Student) distribution with N degrees of
     freedom.  This function is analogous to looking in a table for the
     t-value of a single-tailed distribution.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
For each element of X, compute the quantile (the inverse of the  CDF) at X of the t (Student) distribution with N degrees of  freedom.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
tpdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 183
 -- Function File: tpdf (X, N)
     For each element of X, compute the probability density function
     (PDF) at X of the T (Student) distribution with N degrees of
     freedom.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
For each element of X, compute the probability density function  (PDF) at X of the T (Student) distribution with N degrees of  freedom.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
trnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 692
 -- Function File: trnd (N)
 -- Function File: trnd (N, R)
 -- Function File: trnd (N, R, C, ...)
 -- Function File: trnd (N, [SZ])
     Return a matrix of random samples from the t (Student) distribution
     with N degrees of freedom.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the size
     of N.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Return a matrix of random samples from the t (Student) distribution  with N degrees of freedom.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
unidrnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 797
 -- Function File: unidrnd (N)
 -- Function File: unidrnd (N, R)
 -- Function File: unidrnd (N, R, C, ...)
 -- Function File: unidrnd (N, [SZ])
     Return a matrix of random samples from the discrete uniform
     distribution which assumes the integer values 1-N with equal
     probability.  N may be a scalar or a multi-dimensional array.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the size
     of N.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
Return a matrix of random samples from the discrete uniform  distribution which assumes the integer values 1-N with equal  probability.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
unidcdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 227
 -- Function File: unidcdf (X, N)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of a discrete uniform distribution which assumes the
     integer values 1-N with equal probability.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 176
For each element of X, compute the cumulative distribution function  (CDF) at X of a discrete uniform distribution which assumes the  integer values 1-N with equal probability.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
unidinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 224
 -- Function File: unidinv (X, N)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the discrete uniform distribution which assumes the
     integer values 1-N with equal probability.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 173
For each element of X, compute the quantile (the inverse of the  CDF) at X of the discrete uniform distribution which assumes the  integer values 1-N with equal probability.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
unidpdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 389
 -- Function File: unidpdf (X, N)
     For each element of X, compute the probability density function
     (PDF) at X of a discrete uniform distribution which assumes the
     integer values 1-N with equal probability.

     Warning: The underlying implementation uses the double class and
     will only be accurate for N <= 'bitmax' (2^{53} - 1 on IEEE-754
     compatible systems).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 172
For each element of X, compute the probability density function  (PDF) at X of a discrete uniform distribution which assumes the  integer values 1-N with equal probability.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
unifrnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 709
 -- Function File: unifrnd (A, B)
 -- Function File: unifrnd (A, B, R)
 -- Function File: unifrnd (A, B, R, C, ...)
 -- Function File: unifrnd (A, B, [SZ])
     Return a matrix of random samples from the uniform distribution on
     [A, B].

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the common
     size of A and B.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return a matrix of random samples from the uniform distribution on  [A, B].



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
unifcdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 251
 -- Function File: unifcdf (X)
 -- Function File: unifcdf (X, A, B)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the uniform distribution on the interval [A, B].

     Default values are A = 0, B = 1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 131
For each element of X, compute the cumulative distribution function  (CDF) at X of the uniform distribution on the interval [A, B].



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
unifinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 246
 -- Function File: unifinv (X)
 -- Function File: unifinv (X, A, B)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the uniform distribution on the interval [A, B].

     Default values are A = 0, B = 1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
For each element of X, compute the quantile (the inverse of the  CDF) at X of the uniform distribution on the interval [A, B].



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
unifpdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 247
 -- Function File: unifpdf (X)
 -- Function File: unifpdf (X, A, B)
     For each element of X, compute the probability density function
     (PDF) at X of the uniform distribution on the interval [A, B].

     Default values are A = 0, B = 1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
For each element of X, compute the probability density function  (PDF) at X of the uniform distribution on the interval [A, B].



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
wblcdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 379
 -- Function File: wblcdf (X)
 -- Function File: wblcdf (X, SCALE)
 -- Function File: wblcdf (X, SCALE, SHAPE)
     Compute the cumulative distribution function (CDF) at X of the
     Weibull distribution with scale parameter SCALE and shape parameter
     SHAPE, which is

          1 - exp (-(x/scale)^shape)

     for X >= 0.

     Default values are SCALE = 1, SHAPE = 1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 149
Compute the cumulative distribution function (CDF) at X of the  Weibull distribution with scale parameter SCALE and shape parameter  SHAPE, which is 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
wblinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 304
 -- Function File: wblinv (X)
 -- Function File: wblinv (X, SCALE)
 -- Function File: wblinv (X, SCALE, SHAPE)
     Compute the quantile (the inverse of the CDF) at X of the Weibull
     distribution with scale parameter SCALE and shape parameter SHAPE.

     Default values are SCALE = 1, SHAPE = 1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 133
Compute the quantile (the inverse of the CDF) at X of the Weibull  distribution with scale parameter SCALE and shape parameter SHAPE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
wblpdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 418
 -- Function File: wblpdf (X)
 -- Function File: wblpdf (X, SCALE)
 -- Function File: wblpdf (X, SCALE, SHAPE)
     Compute the probability density function (PDF) at X of the Weibull
     distribution with scale parameter SCALE and shape parameter SHAPE
     which is given by

          shape * scale^(-shape) * x^(shape-1) * exp (-(x/scale)^shape)

     for X >= 0.

     Default values are SCALE = 1, SHAPE = 1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
Compute the probability density function (PDF) at X of the Weibull  distribution with scale parameter SCALE and shape parameter SHAPE  which is given by 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
wblrnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 767
 -- Function File: wblrnd (SCALE, SHAPE)
 -- Function File: wblrnd (SCALE, SHAPE, R)
 -- Function File: wblrnd (SCALE, SHAPE, R, C, ...)
 -- Function File: wblrnd (SCALE, SHAPE, [SZ])
     Return a matrix of random samples from the Weibull distribution
     with parameters SCALE and SHAPE.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector of
     dimensions SZ.

     If no size arguments are given then the result matrix is the common
     size of SCALE and SHAPE.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Return a matrix of random samples from the Weibull distribution  with parameters SCALE and SHAPE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
wienrnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 456
 -- Function File: wienrnd (T, D, N)
     Return a simulated realization of the D-dimensional Wiener Process
     on the interval [0, T].  If D is omitted, D = 1 is used.  The first
     column of the return matrix contains time, the remaining columns
     contain the Wiener process.

     The optional parameter N gives the number of summands used for
     simulating the process over an interval of length 1.  If N is
     omitted, N = 1000 is used.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
Return a simulated realization of the D-dimensional Wiener Process  on the interval [0, T].



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
logistic_regression


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1684
 -- Function File: [THETA, BETA, DEV, DL, D2L, P] = logistic_regression
          (Y, X, PRINT, THETA, BETA)
     Perform ordinal logistic regression.

     Suppose Y takes values in K ordered categories, and let 'gamma_i
     (X)' be the cumulative probability that Y falls in one of the first
     I categories given the covariate X.  Then

          [theta, beta] = logistic_regression (y, x)

     fits the model

          logit (gamma_i (x)) = theta_i - beta' * x,   i = 1 ... k-1

     The number of ordinal categories, K, is taken to be the number of
     distinct values of 'round (Y)'.  If K equals 2, Y is binary and the
     model is ordinary logistic regression.  The matrix X is assumed to
     have full column rank.

     Given Y only, 'theta = logistic_regression (y)' fits the model with
     baseline logit odds only.

     The full form is

          [theta, beta, dev, dl, d2l, gamma]
             = logistic_regression (y, x, print, theta, beta)

     in which all output arguments and all input arguments except Y are
     optional.

     Setting PRINT to 1 requests summary information about the fitted
     model to be displayed.  Setting PRINT to 2 requests information
     about convergence at each iteration.  Other values request no
     information to be displayed.  The input arguments THETA and BETA
     give initial estimates for THETA and BETA.

     The returned value DEV holds minus twice the log-likelihood.

     The returned values DL and D2L are the vector of first and the
     matrix of second derivatives of the log-likelihood with respect to
     THETA and BETA.

     P holds estimates for the conditional distribution of Y given X.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
(Y, X, PRINT, THETA, BETA)  Perform ordinal logistic regression.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
logistic_regression_derivatives


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 283
 -- Function File: [DL, D2L] = logistic_regression_derivatives (X, Z,
          Z1, G, G1, P)
     Calculate derivatives of the log-likelihood for ordinal logistic
     regression model.  Private function called by
     'logistic_regression'.

     See also: logistic_regression.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Z1, G, G1, P)  Calculate derivatives of the log-likelihood for ordinal logistic  regression model.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
logistic_regression_likelihood


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 266
 -- Function File: [G, G1, P, DEV] = logistic_regression_likelihood (Y,
          X, BETA, Z, Z1)
     Calculate the likelihood for the ordinal logistic regression model.
     Private function called by 'logistic_regression'.

     See also: logistic_regression.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
X, BETA, Z, Z1)  Calculate the likelihood for the ordinal logistic regression model.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
anova


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1005
 -- Function File: [PVAL, F, DF_B, DF_W] = anova (Y, G)
     Perform a one-way analysis of variance (ANOVA). The goal is to test
     whether the population means of data taken from K different groups
     are all equal.

     Data may be given in a single vector Y with groups specified by a
     corresponding vector of group labels G (e.g., numbers from 1 to K).
     This is the general form which does not impose any restriction on
     the number of data in each group or the group labels.

     If Y is a matrix and G is omitted, each column of Y is treated as a
     group.  This form is only appropriate for balanced ANOVA in which
     the numbers of samples from each group are all equal.

     Under the null of constant means, the statistic F follows an F
     distribution with DF_B and DF_W degrees of freedom.

     The p-value (1 minus the CDF of this distribution at F) is returned
     in PVAL.

     If no output argument is given, the standard one-way ANOVA table is
     printed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Perform a one-way analysis of variance (ANOVA).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
bartlett_test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 491
 -- Function File: [PVAL, CHISQ, DF] = bartlett_test (X1, ...)
     Perform a Bartlett test for the homogeneity of variances in the
     data vectors X1, X2, ..., XK, where K > 1.

     Under the null of equal variances, the test statistic CHISQ
     approximately follows a chi-square distribution with DF degrees of
     freedom.

     The p-value (1 minus the CDF of this distribution at CHISQ) is
     returned in PVAL.

     If no output argument is given, the p-value is displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Perform a Bartlett test for the homogeneity of variances in the  data vectors X1, X2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
chisquare_test_homogeneity


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 621
 -- Function File: [PVAL, CHISQ, DF] = chisquare_test_homogeneity (X, Y,
          C)
     Given two samples X and Y, perform a chisquare test for homogeneity
     of the null hypothesis that X and Y come from the same
     distribution, based on the partition induced by the (strictly
     increasing) entries of C.

     For large samples, the test statistic CHISQ approximately follows a
     chisquare distribution with DF = 'length (C)' degrees of freedom.

     The p-value (1 minus the CDF of this distribution at CHISQ) is
     returned in PVAL.

     If no output argument is given, the p-value is displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 217
C)  Given two samples X and Y, perform a chisquare test for homogeneity  of the null hypothesis that X and Y come from the same  distribution, based on the partition induced by the (strictly  increasing) entries of C.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
chisquare_test_independence


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 461
 -- Function File: [PVAL, CHISQ, DF] = chisquare_test_independence (X)
     Perform a chi-square test for independence based on the contingency
     table X.  Under the null hypothesis of independence, CHISQ
     approximately has a chi-square distribution with DF degrees of
     freedom.

     The p-value (1 minus the CDF of this distribution at chisq) of the
     test is returned in PVAL.

     If no output argument is given, the p-value is displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Perform a chi-square test for independence based on the contingency  table X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cor_test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1384
 -- Function File: cor_test (X, Y, ALT, METHOD)
     Test whether two samples X and Y come from uncorrelated
     populations.

     The optional argument string ALT describes the alternative
     hypothesis, and can be "!=" or "<>" (non-zero), ">" (greater than
     0), or "<" (less than 0).  The default is the two-sided case.

     The optional argument string METHOD specifies which correlation
     coefficient to use for testing.  If METHOD is "pearson" (default),
     the (usual) Pearson's product moment correlation coefficient is
     used.  In this case, the data should come from a bivariate normal
     distribution.  Otherwise, the other two methods offer nonparametric
     alternatives.  If METHOD is "kendall", then Kendall's rank
     correlation tau is used.  If METHOD is "spearman", then Spearman's
     rank correlation rho is used.  Only the first character is
     necessary.

     The output is a structure with the following elements:

     PVAL
          The p-value of the test.

     STAT
          The value of the test statistic.

     DIST
          The distribution of the test statistic.

     PARAMS
          The parameters of the null distribution of the test statistic.

     ALTERNATIVE
          The alternative hypothesis.

     METHOD
          The method used for testing.

     If no output argument is given, the p-value is displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Test whether two samples X and Y come from uncorrelated  populations.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
f_test_regression


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 516
 -- Function File: [PVAL, F, DF_NUM, DF_DEN] = f_test_regression (Y, X,
          RR, R)
     Perform an F test for the null hypothesis rr * b = r in a classical
     normal regression model y = X * b + e.

     Under the null, the test statistic F follows an F distribution with
     DF_NUM and DF_DEN degrees of freedom.

     The p-value (1 minus the CDF of this distribution at F) is returned
     in PVAL.

     If not given explicitly, R = 0.

     If no output argument is given, the p-value is displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
RR, R)  Perform an F test for the null hypothesis rr * b = r in a classical  normal regression model y = X * b + e.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
hotelling_test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 570
 -- Function File: [PVAL, TSQ] = hotelling_test (X, M)
     For a sample X from a multivariate normal distribution with unknown
     mean and covariance matrix, test the null hypothesis that 'mean (X)
     == M'.

     Hotelling's T^2 is returned in TSQ.  Under the null, (n-p) T^2 /
     (p(n-1)) has an F distribution with p and n-p degrees of freedom,
     where n and p are the numbers of samples and variables,
     respectively.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 144
For a sample X from a multivariate normal distribution with unknown  mean and covariance matrix, test the null hypothesis that 'mean (X)  == M'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
hotelling_test_2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 686
 -- Function File: [PVAL, TSQ] = hotelling_test_2 (X, Y)
     For two samples X from multivariate normal distributions with the
     same number of variables (columns), unknown means and unknown equal
     covariance matrices, test the null hypothesis 'mean (X) == mean
     (Y)'.

     Hotelling's two-sample T^2 is returned in TSQ.  Under the null,

          (n_x+n_y-p-1) T^2 / (p(n_x+n_y-2))

     has an F distribution with p and n_x+n_y-p-1 degrees of freedom,
     where n_x and n_y are the sample sizes and p is the number of
     variables.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 206
For two samples X from multivariate normal distributions with the  same number of variables (columns), unknown means and unknown equal  covariance matrices, test the null hypothesis 'mean (X) == mean  (Y)'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
kolmogorov_smirnov_test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1359
 -- Function File: [PVAL, KS] = kolmogorov_smirnov_test (X, DIST,
          PARAMS, ALT)
     Perform a Kolmogorov-Smirnov test of the null hypothesis that the
     sample X comes from the (continuous) distribution dist.  I.e., if F
     and G are the CDFs corresponding to the sample and dist,
     respectively, then the null is that F == G.

     The optional argument PARAMS contains a list of parameters of DIST.
     For example, to test whether a sample X comes from a uniform
     distribution on [2,4], use

          kolmogorov_smirnov_test (x, "unif", 2, 4)

     DIST can be any string for which a function DIST_CDF that
     calculates the CDF of distribution DIST exists.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is "!=" or "<>", the null is tested
     against the two-sided alternative F != G.  In this case, the test
     statistic KS follows a two-sided Kolmogorov-Smirnov distribution.
     If ALT is ">", the one-sided alternative F > G is considered.
     Similarly for "<", the one-sided alternative F > G is considered.
     In this case, the test statistic KS has a one-sided
     Kolmogorov-Smirnov distribution.  The default is the two-sided
     case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value is displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 136
PARAMS, ALT)  Perform a Kolmogorov-Smirnov test of the null hypothesis that the  sample X comes from the (continuous) distribution dist.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
kolmogorov_smirnov_test_2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1165
 -- Function File: [PVAL, KS, D] = kolmogorov_smirnov_test_2 (X, Y, ALT)
     Perform a 2-sample Kolmogorov-Smirnov test of the null hypothesis
     that the samples X and Y come from the same (continuous)
     distribution.  I.e., if F and G are the CDFs corresponding to the X
     and Y samples, respectively, then the null is that F == G.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is "!=" or "<>", the null is tested
     against the two-sided alternative F != G.  In this case, the test
     statistic KS follows a two-sided Kolmogorov-Smirnov distribution.
     If ALT is ">", the one-sided alternative F > G is considered.
     Similarly for "<", the one-sided alternative F < G is considered.
     In this case, the test statistic KS has a one-sided
     Kolmogorov-Smirnov distribution.  The default is the two-sided
     case.

     The p-value of the test is returned in PVAL.

     The third returned value, D, is the test statistic, the maximum
     vertical distance between the two cumulative distribution
     functions.

     If no output argument is given, the p-value is displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 138
Perform a 2-sample Kolmogorov-Smirnov test of the null hypothesis  that the samples X and Y come from the same (continuous)  distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
kruskal_wallis_test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1133
 -- Function File: [PVAL, K, DF] = kruskal_wallis_test (X1, ...)
     Perform a Kruskal-Wallis one-factor analysis of variance.

     Suppose a variable is observed for K > 1 different groups, and let
     X1, ..., XK be the corresponding data vectors.

     Under the null hypothesis that the ranks in the pooled sample are
     not affected by the group memberships, the test statistic K is
     approximately chi-square with DF = K - 1 degrees of freedom.

     If the data contains ties (some value appears more than once) K is
     divided by

     1 - SUM_TIES / (N^3 - N)

     where SUM_TIES is the sum of T^2 - T over each group of ties where
     T is the number of ties in the group and N is the total number of
     values in the input data.  For more info on this adjustment see
     William H. Kruskal and W. Allen Wallis, 'Use of Ranks in
     One-Criterion Variance Analysis', Journal of the American
     Statistical Association, Vol.  47, No.  260 (Dec 1952).

     The p-value (1 minus the CDF of this distribution at K) is returned
     in PVAL.

     If no output argument is given, the p-value is displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Perform a Kruskal-Wallis one-factor analysis of variance.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
manova


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 647
 -- Function File: manova (X, G)
     Perform a one-way multivariate analysis of variance (MANOVA). The
     goal is to test whether the p-dimensional population means of data
     taken from K different groups are all equal.  All data are assumed
     drawn independently from p-dimensional normal distributions with
     the same covariance matrix.

     The data matrix is given by X.  As usual, rows are observations and
     columns are variables.  The vector G specifies the corresponding
     group labels (e.g., numbers from 1 to K).

     The LR test statistic (Wilks' Lambda) and approximate p-values are
     computed and displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Perform a one-way multivariate analysis of variance (MANOVA).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
mcnemar_test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 554
 -- Function File: [PVAL, CHISQ, DF] = mcnemar_test (X)
     For a square contingency table X of data cross-classified on the
     row and column variables, McNemar's test can be used for testing
     the null hypothesis of symmetry of the classification
     probabilities.

     Under the null, CHISQ is approximately distributed as chisquare
     with DF degrees of freedom.

     The p-value (1 minus the CDF of this distribution at CHISQ) is
     returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 201
For a square contingency table X of data cross-classified on the  row and column variables, McNemar's test can be used for testing  the null hypothesis of symmetry of the classification  probabilities.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
prop_test_2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 862
 -- Function File: [PVAL, Z] = prop_test_2 (X1, N1, X2, N2, ALT)
     If X1 and N1 are the counts of successes and trials in one sample,
     and X2 and N2 those in a second one, test the null hypothesis that
     the success probabilities P1 and P2 are the same.  Under the null,
     the test statistic Z approximately follows a standard normal
     distribution.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is "!=" or "<>", the null is tested
     against the two-sided alternative P1 != P2.  If ALT is ">", the
     one-sided alternative P1 > P2 is used.  Similarly for "<", the
     one-sided alternative P1 < P2 is used.  The default is the
     two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 185
If X1 and N1 are the counts of successes and trials in one sample,  and X2 and N2 those in a second one, test the null hypothesis that  the success probabilities P1 and P2 are the same.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
run_test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 337
 -- Function File: [PVAL, CHISQ] = run_test (X)
     Perform a chi-square test with 6 degrees of freedom based on the
     upward runs in the columns of X.  Can be used to test whether X
     contains independent data.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value is displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Perform a chi-square test with 6 degrees of freedom based on the  upward runs in the columns of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
sign_test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 947
 -- Function File: [PVAL, B, N] = sign_test (X, Y, ALT)
     For two matched-pair samples X and Y, perform a sign test of the
     null hypothesis PROB (X > Y) == PROB (X < Y) == 1/2.  Under the
     null, the test statistic B roughly follows a binomial distribution
     with parameters 'N = sum (X != Y)' and P = 1/2.

     With the optional argument 'alt', the alternative of interest can
     be selected.  If ALT is "!=" or "<>", the null hypothesis is tested
     against the two-sided alternative PROB (X < Y) != 1/2.  If ALT is
     ">", the one-sided alternative PROB (X > Y) > 1/2 ("x is
     stochastically greater than y") is considered.  Similarly for "<",
     the one-sided alternative PROB (X > Y) < 1/2 ("x is stochastically
     less than y") is considered.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 118
For two matched-pair samples X and Y, perform a sign test of the  null hypothesis PROB (X > Y) == PROB (X < Y) == 1/2.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
t_test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 848
 -- Function File: [PVAL, T, DF] = t_test (X, M, ALT)
     For a sample X from a normal distribution with unknown mean and
     variance, perform a t-test of the null hypothesis 'mean (X) == M'.
     Under the null, the test statistic T follows a Student distribution
     with 'DF = length (X) - 1' degrees of freedom.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is "!=" or "<>", the null is tested
     against the two-sided alternative 'mean (X) != M'.  If ALT is ">",
     the one-sided alternative 'mean (X) > M' is considered.  Similarly
     for "<", the one-sided alternative 'mean (X) < M' is considered.
     The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 131
For a sample X from a normal distribution with unknown mean and  variance, perform a t-test of the null hypothesis 'mean (X) == M'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
t_test_2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 880
 -- Function File: [PVAL, T, DF] = t_test_2 (X, Y, ALT)
     For two samples x and y from normal distributions with unknown
     means and unknown equal variances, perform a two-sample t-test of
     the null hypothesis of equal means.  Under the null, the test
     statistic T follows a Student distribution with DF degrees of
     freedom.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is "!=" or "<>", the null is tested
     against the two-sided alternative 'mean (X) != mean (Y)'.  If ALT
     is ">", the one-sided alternative 'mean (X) > mean (Y)' is used.
     Similarly for "<", the one-sided alternative 'mean (X) < mean (Y)'
     is used.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 166
For two samples x and y from normal distributions with unknown  means and unknown equal variances, perform a two-sample t-test of  the null hypothesis of equal means.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
t_test_regression


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 852
 -- Function File: [PVAL, T, DF] = t_test_regression (Y, X, RR, R, ALT)
     Perform a t test for the null hypothesis 'RR * B = R' in a
     classical normal regression model 'Y = X * B + E'.  Under the null,
     the test statistic T follows a T distribution with DF degrees of
     freedom.

     If R is omitted, a value of 0 is assumed.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is "!=" or "<>", the null is tested
     against the two-sided alternative 'RR * B != R'.  If ALT is ">",
     the one-sided alternative 'RR * B > R' is used.  Similarly for "<",
     the one-sided alternative 'RR * B < R' is used.  The default is the
     two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
Perform a t test for the null hypothesis 'RR * B = R' in a  classical normal regression model 'Y = X * B + E'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
u_test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 888
 -- Function File: [PVAL, Z] = u_test (X, Y, ALT)
     For two samples X and Y, perform a Mann-Whitney U-test of the null
     hypothesis PROB (X > Y) == 1/2 == PROB (X < Y).  Under the null,
     the test statistic Z approximately follows a standard normal
     distribution.  Note that this test is equivalent to the Wilcoxon
     rank-sum test.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is "!=" or "<>", the null is tested
     against the two-sided alternative PROB (X > Y) != 1/2.  If ALT is
     ">", the one-sided alternative PROB (X > Y) > 1/2 is considered.
     Similarly for "<", the one-sided alternative PROB (X > Y) < 1/2 is
     considered.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
For two samples X and Y, perform a Mann-Whitney U-test of the null  hypothesis PROB (X > Y) == 1/2 == PROB (X < Y).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
var_test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 884
 -- Function File: [PVAL, F, DF_NUM, DF_DEN] = var_test (X, Y, ALT)
     For two samples X and Y from normal distributions with unknown
     means and unknown variances, perform an F-test of the null
     hypothesis of equal variances.  Under the null, the test statistic
     F follows an F-distribution with DF_NUM and DF_DEN degrees of
     freedom.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is "!=" or "<>", the null is tested
     against the two-sided alternative 'var (X) != var (Y)'.  If ALT is
     ">", the one-sided alternative 'var (X) > var (Y)' is used.
     Similarly for "<", the one-sided alternative 'var (X) > var (Y)' is
     used.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 154
For two samples X and Y from normal distributions with unknown  means and unknown variances, perform an F-test of the null  hypothesis of equal variances.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
welch_test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 895
 -- Function File: [PVAL, T, DF] = welch_test (X, Y, ALT)
     For two samples X and Y from normal distributions with unknown
     means and unknown and not necessarily equal variances, perform a
     Welch test of the null hypothesis of equal means.  Under the null,
     the test statistic T approximately follows a Student distribution
     with DF degrees of freedom.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is "!=" or "<>", the null is tested
     against the two-sided alternative 'mean (X) != M'.  If ALT is ">",
     the one-sided alternative mean(x) > M is considered.  Similarly for
     "<", the one-sided alternative mean(x) < M is considered.  The
     default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 179
For two samples X and Y from normal distributions with unknown  means and unknown and not necessarily equal variances, perform a  Welch test of the null hypothesis of equal means.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
wilcoxon_test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 951
 -- Function File: [PVAL, Z] = wilcoxon_test (X, Y, ALT)
     For two matched-pair sample vectors X and Y, perform a Wilcoxon
     signed-rank test of the null hypothesis PROB (X > Y) == 1/2.  Under
     the null, the test statistic Z approximately follows a standard
     normal distribution when N > 25.

     *Caution:* This function assumes a normal distribution for Z and
     thus is invalid for N <= 25.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is "!=" or "<>", the null is tested
     against the two-sided alternative PROB (X > Y) != 1/2.  If alt is
     ">", the one-sided alternative PROB (X > Y) > 1/2 is considered.
     Similarly for "<", the one-sided alternative PROB (X > Y) < 1/2 is
     considered.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
For two matched-pair sample vectors X and Y, perform a Wilcoxon  signed-rank test of the null hypothesis PROB (X > Y) == 1/2.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
z_test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 845
 -- Function File: [PVAL, Z] = z_test (X, M, V, ALT)
     Perform a Z-test of the null hypothesis 'mean (X) == M' for a
     sample X from a normal distribution with unknown mean and known
     variance V.  Under the null, the test statistic Z follows a
     standard normal distribution.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is "!=" or "<>", the null is tested
     against the two-sided alternative 'mean (X) != M'.  If ALT is ">",
     the one-sided alternative 'mean (X) > M' is considered.  Similarly
     for "<", the one-sided alternative 'mean (X) < M' is considered.
     The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed along with some information.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 139
Perform a Z-test of the null hypothesis 'mean (X) == M' for a  sample X from a normal distribution with unknown mean and known  variance V.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
z_test_2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 878
 -- Function File: [PVAL, Z] = z_test_2 (X, Y, V_X, V_Y, ALT)
     For two samples X and Y from normal distributions with unknown
     means and known variances V_X and V_Y, perform a Z-test of the
     hypothesis of equal means.  Under the null, the test statistic Z
     follows a standard normal distribution.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is "!=" or "<>", the null is tested
     against the two-sided alternative 'mean (X) != mean (Y)'.  If alt
     is ">", the one-sided alternative 'mean (X) > mean (Y)' is used.
     Similarly for "<", the one-sided alternative 'mean (X) < mean (Y)'
     is used.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed along with some information.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 154
For two samples X and Y from normal distributions with unknown  means and known variances V_X and V_Y, perform a Z-test of the  hypothesis of equal means.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
base2dec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 701
 -- Function File: base2dec (S, BASE)
     Convert S from a string of digits in base BASE to a decimal integer
     (base 10).

          base2dec ("11120", 3)
             => 123

     If S is a string matrix, return a column vector with one value per
     row of S.  If a row contains invalid symbols then the corresponding
     value will be NaN.

     If S is a cell array of strings, return a column vector with one
     value per cell element in S.

     If BASE is a string, the characters of BASE are used as the symbols
     for the digits of S.  Space (' ') may not be used as a symbol.

          base2dec ("yyyzx", "xyz")
             => 123

     See also: dec2base, bin2dec, hex2dec.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Convert S from a string of digits in base BASE to a decimal integer  (base 10).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bin2dec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 646
 -- Function File: bin2dec (S)
     Return the decimal number corresponding to the binary number
     represented by the string S.  For example:

          bin2dec ("1110")
               => 14

     Spaces are ignored during conversion and may be used to make the
     binary number more readable.

          bin2dec ("1000 0001")
               => 129

     If S is a string matrix, return a column vector with one converted
     number per row of S; Invalid rows evaluate to NaN.

     If S is a cell array of strings, return a column vector with one
     converted number per cell element in S.

     See also: dec2bin, base2dec, hex2dec.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Return the decimal number corresponding to the binary number  represented by the string S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
blanks


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 377
 -- Function File: blanks (N)
     Return a string of N blanks, for example:

          blanks (10);
          whos ans
               =>
                Attr Name        Size                     Bytes  Class
                ==== ====        ====                     =====  =====
                     ans         1x10                        10  char

     See also: repmat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Return a string of N blanks, for example: 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cstrcat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 401
 -- Function File: cstrcat (S1, S2, ...)
     Return a string containing all the arguments concatenated
     horizontally.  Trailing white space is preserved.  For example:

          cstrcat ("ab   ", "cd")
                => "ab   cd"

          s = [ "ab"; "cde" ];
          cstrcat (s, s, s)
                => "ab ab ab "
                   "cdecdecde"

     See also: strcat, char, strvcat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Return a string containing all the arguments concatenated  horizontally.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
deblank


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 437
 -- Function File: deblank (S)
     Remove trailing whitespace and nulls from S.  If S is a matrix,
     DEBLANK trims each row to the length of longest string.  If S is a
     cell array of strings, operate recursively on each string element.

     Examples:

          deblank ("    abc  ")
               =>  "    abc"

          deblank ([" abc   "; "   def   "])
               =>  [" abc  " ; "   def"]

     See also: strtrim.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Remove trailing whitespace and nulls from S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
dec2base


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 746
 -- Function File: dec2base (D, BASE)
 -- Function File: dec2base (D, BASE, LEN)
     Return a string of symbols in base BASE corresponding to the
     non-negative integer D.

          dec2base (123, 3)
             => "11120"

     If D is a matrix or cell array, return a string matrix with one row
     per element in D, padded with leading zeros to the width of the
     largest value.

     If BASE is a string then the characters of BASE are used as the
     symbols for the digits of D.  Space (' ') may not be used as a
     symbol.

          dec2base (123, "aei")
             => "eeeia"

     The optional third argument, LEN, specifies the minimum number of
     digits in the result.

     See also: base2dec, dec2bin, dec2hex.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
Return a string of symbols in base BASE corresponding to the  non-negative integer D.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dec2bin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 518
 -- Function File: dec2bin (D, LEN)
     Return a binary number corresponding to the non-negative integer D,
     as a string of ones and zeros.  For example:

          dec2bin (14)
               => "1110"

     If D is a matrix or cell array, return a string matrix with one row
     per element in D, padded with leading zeros to the width of the
     largest value.

     The optional second argument, LEN, specifies the minimum number of
     digits in the result.

     See also: bin2dec, dec2base, dec2hex.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
Return a binary number corresponding to the non-negative integer D,  as a string of ones and zeros.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dec2hex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 495
 -- Function File: dec2hex (D, LEN)
     Return the hexadecimal string corresponding to the non-negative
     integer D.  For example:

          dec2hex (2748)
               => "ABC"

     If D is a matrix or cell array, return a string matrix with one row
     per element in D, padded with leading zeros to the width of the
     largest value.

     The optional second argument, LEN, specifies the minimum number of
     digits in the result.

     See also: hex2dec, dec2base, dec2bin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return the hexadecimal string corresponding to the non-negative  integer D.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
findstr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 669
 -- Function File: findstr (S, T)
 -- Function File: findstr (S, T, OVERLAP)
     Return the vector of all positions in the longer of the two strings
     S and T where an occurrence of the shorter of the two starts.  If
     the optional argument OVERLAP is true, the returned vector can
     include overlapping positions (this is the default).  For example:

          findstr ("ababab", "a")
               => [1, 3, 5];
          findstr ("abababa", "aba", 0)
               => [1, 5]

     *Caution:* 'findstr' is scheduled for deprecation.  Use 'strfind'
     in all new code.

     See also: strfind, strmatch, strcmp, strncmp, strcmpi, strncmpi,
     find.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 130
Return the vector of all positions in the longer of the two strings  S and T where an occurrence of the shorter of the two starts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hex2dec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 534
 -- Function File: hex2dec (S)
     Return the integer corresponding to the hexadecimal number
     represented by the string S.  For example:

          hex2dec ("12B")
                => 299
          hex2dec ("12b")
                => 299

     If S is a string matrix, return a column vector with one converted
     number per row of S; Invalid rows evaluate to NaN.

     If S is a cell array of strings, return a column vector with one
     converted number per cell element in S.

     See also: dec2hex, base2dec, bin2dec.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
Return the integer corresponding to the hexadecimal number  represented by the string S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
index


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 487
 -- Function File: index (S, T)
 -- Function File: index (S, T, DIRECTION)
     Return the position of the first occurrence of the string T in the
     string S, or 0 if no occurrence is found.  S may also be a string
     array or cell array of strings.

     For example:

          index ("Teststring", "t")
              => 4

     If DIRECTION is "first", return the first element found.  If
     DIRECTION is "last", return the last element found.

     See also: find, rindex.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
Return the position of the first occurrence of the string T in the  string S, or 0 if no occurrence is found.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isletter


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 269
 -- Function File: isletter (S)
     Return a logical array which is true where the elements of S are
     letters and false where they are not.  This is an alias for the
     'isalpha' function.

     See also: isalpha, isdigit, ispunct, isspace, iscntrl, isalnum.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Return a logical array which is true where the elements of S are  letters and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
isstrprop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1452
 -- Function File: isstrprop (STR, PROP)
     Test character string properties.  For example:

          isstrprop ("abc123", "alpha")
          => [1, 1, 1, 0, 0, 0]

     If STR is a cell array, 'isstrpop' is applied recursively to each
     element of the cell array.

     Numeric arrays are converted to character strings.

     The second argument PROP must be one of

     "alpha"
          True for characters that are alphabetic (letters).

     "alnum"
     "alphanum"
          True for characters that are alphabetic or digits.

     "lower"
          True for lowercase letters.

     "upper"
          True for uppercase letters.

     "digit"
          True for decimal digits (0-9).

     "xdigit"
          True for hexadecimal digits (a-fA-F0-9).

     "space"
     "wspace"
          True for whitespace characters (space, formfeed, newline,
          carriage return, tab, vertical tab).

     "punct"
          True for punctuation characters (printing characters except
          space or letter or digit).

     "cntrl"
          True for control characters.

     "graph"
     "graphic"
          True for printing characters except space.

     "print"
          True for printing characters including space.

     "ascii"
          True for characters that are in the range of ASCII encoding.

     See also: isalpha, isalnum, islower, isupper, isdigit, isxdigit,
     isspace, ispunct, iscntrl, isgraph, isprint, isascii.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Test character string properties.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
mat2str


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1233
 -- Function File: S = mat2str (X, N)
 -- Function File: S = mat2str (X, N, "class")
     Format real, complex, and logical matrices as strings.  The
     returned string may be used to reconstruct the original matrix by
     using the 'eval' function.

     The precision of the values is given by N.  If N is a scalar then
     both real and imaginary parts of the matrix are printed to the same
     precision.  Otherwise 'N(1)' defines the precision of the real part
     and 'N(2)' defines the precision of the imaginary part.  The
     default for N is 15.

     If the argument "class" is given then the class of X is included in
     the string in such a way that 'eval' will result in the
     construction of a matrix of the same class.

          mat2str ([ -1/3 + i/7; 1/3 - i/7 ], [4 2])
               => "[-0.3333+0.14i;0.3333-0.14i]"

          mat2str ([ -1/3 +i/7; 1/3 -i/7 ], [4 2])
               => "[-0.3333+0i 0+0.14i;0.3333+0i -0-0.14i]"

          mat2str (int16 ([1 -1]), "class")
               => "int16([1 -1])"

          mat2str (logical (eye (2)))
               => "[true false;false true]"

          isequal (x, eval (mat2str (x)))
               => 1

     See also: sprintf, num2str, int2str.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Format real, complex, and logical matrices as strings.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
ostrsplit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 911
 -- Function File: [CSTR] = ostrsplit (S, SEP)
 -- Function File: [CSTR] = ostrsplit (S, SEP, STRIP_EMPTY)
     Split the string S using one or more separators SEP and return a
     cell array of strings.  Consecutive separators and separators at
     boundaries result in empty strings, unless STRIP_EMPTY is true.
     The default value of STRIP_EMPTY is false.

     2-D character arrays are split at separators and at the original
     column boundaries.

     Example:

          ostrsplit ("a,b,c", ",")
                =>
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
                    }

          ostrsplit (["a,b" ; "cde"], ",")
                =>
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = cde
                    }

     See also: strsplit, strtok.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
Split the string S using one or more separators SEP and return a  cell array of strings.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
regexptranslate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 831
 -- Function File: regexptranslate (OP, S)
     Translate a string for use in a regular expression.  This may
     include either wildcard replacement or special character escaping.
     The behavior is controlled by OP which can take the following
     values

     "wildcard"
          The wildcard characters '.', '*', and '?' are replaced with
          wildcards that are appropriate for a regular expression.  For
          example:

               regexptranslate ("wildcard", "*.m")
                    => ".*\.m"

     "escape"
          The characters '$.?[]', that have special meaning for regular
          expressions are escaped so that they are treated literally.
          For example:

               regexptranslate ("escape", "12.5")
                    => "12\.5"

     See also: regexp, regexpi, regexprep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Translate a string for use in a regular expression.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rindex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 429
 -- Function File: rindex (S, T)
     Return the position of the last occurrence of the character string
     T in the character string S, or 0 if no occurrence is found.  S may
     also be a string array or cell array of strings.

     For example:

          rindex ("Teststring", "t")
               => 6

     The 'rindex' function is equivalent to 'index' with DIRECTION set
     to "last".

     See also: find, index.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 128
Return the position of the last occurrence of the character string  T in the character string S, or 0 if no occurrence is found.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
str2num


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 794
 -- Function File: X = str2num (S)
 -- Function File: [X, STATE] = str2num (S)
     Convert the string (or character array) S to a number (or an
     array).  Examples:

          str2num ("3.141596")
                => 3.141596

          str2num (["1, 2, 3"; "4, 5, 6"])
                => 1  2  3
                   4  5  6

     The optional second output, STATE, is logically true when the
     conversion is successful.  If the conversion fails the numeric
     output, X, is empty and STATE is false.

     *Caution:* As 'str2num' uses the 'eval' function to do the
     conversion, 'str2num' will execute any code contained in the string
     S.  Use 'str2double' for a safer and faster conversion.

     For cell array of strings use 'str2double'.

     See also: str2double, eval.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Convert the string (or character array) S to a number (or an  array).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
strcat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1240
 -- Function File: strcat (S1, S2, ...)
     Return a string containing all the arguments concatenated
     horizontally.  If the arguments are cell strings, 'strcat' returns
     a cell string with the individual cells concatenated.  For
     numerical input, each element is converted to the corresponding
     ASCII character.  Trailing white space for any character string
     input is eliminated before the strings are concatenated.  Note that
     cell string values do *not* have whitespace trimmed.

     For example:

          strcat ("|", " leading space is preserved", "|")
              => | leading space is preserved|

          strcat ("|", "trailing space is eliminated ", "|")
              => |trailing space is eliminated|

          strcat ("homogeneous space |", "  ", "| is also eliminated")
              => homogeneous space || is also eliminated

          s = [ "ab"; "cde" ];
          strcat (s, s, s)
              =>
                  "ababab   "
                  "cdecdecde"

          s = { "ab"; "cd " };
          strcat (s, s, s)
              =>
                  {
                    [1,1] = ababab
                    [2,1] = cd cd cd
                  }

     See also: cstrcat, char, strvcat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Return a string containing all the arguments concatenated  horizontally.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
strchr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 464
 -- Function File: IDX = strchr (STR, CHARS)
 -- Function File: IDX = strchr (STR, CHARS, N)
 -- Function File: IDX = strchr (STR, CHARS, N, DIRECTION)
 -- Function File: [I, J] = strchr (...)
     Search for the string STR for occurrences of characters from the
     set CHARS.  The return value(s), as well as the N and DIRECTION
     arguments behave identically as in 'find'.

     This will be faster than using regexp in most cases.

     See also: find.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Search for the string STR for occurrences of characters from the  set CHARS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strjoin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 745
 -- Function File: STR = strjoin (CSTR)
 -- Function File: STR = strjoin (CSTR, DELIMITER)
     Join the elements of the cell string array, CSTR, into a single
     string.

     If no DELIMITER is specified, the elements of CSTR separated by a
     space.

     If DELIMITER is specified as a string, the cell string array is
     joined using the string.  Escape sequences are supported.

     If DELIMITER is a cell string array whose length is one less than
     CSTR, then the elements of CSTR are joined by interleaving the cell
     string elements of DELIMITER.  Escape sequences are not supported.

          strjoin ({'Octave','Scilab','Lush','Yorick'}, '*')
                => 'Octave*Scilab*Lush*Yorick'

     See also: strsplit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Join the elements of the cell string array, CSTR, into a single  string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strjust


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 561
 -- Function File: strjust (S)
 -- Function File: strjust (S, POS)
     Return the text, S, justified according to POS, which may be
     "left", "center", or "right".  If POS is omitted it defaults to
     "right".

     Null characters are replaced by spaces.  All other character data
     are treated as non-white space.

     Example:

          strjust (["a"; "ab"; "abc"; "abcd"])
               =>
                  "   a"
                  "  ab"
                  " abc"
                  "abcd"

     See also: deblank, strrep, strtrim, untabify.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
Return the text, S, justified according to POS, which may be  "left", "center", or "right".



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
strmatch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 934
 -- Function File: strmatch (S, A)
 -- Function File: strmatch (S, A, "exact")
     Return indices of entries of A which begin with the string S.  The
     second argument A must be a string, character matrix, or a cell
     array of strings.  If the third argument "exact" is not given, then
     S only needs to match A up to the length of S.  Trailing spaces and
     nulls in S and A are ignored when matching.

     For example:

          strmatch ("apple", "apple juice")
               => 1

          strmatch ("apple", ["apple  "; "apple juice"; "an apple"])
               => [1; 2]

          strmatch ("apple", ["apple  "; "apple juice"; "an apple"], "exact")
               => [1]

     *Caution:* 'strmatch' is scheduled for deprecation.  Use 'strncmp'
     (normal case), or 'strcmp' ("exact" case), or 'regexp' in all new
     code.

     See also: strfind, findstr, strcmp, strncmp, strcmpi, strncmpi,
     find.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Return indices of entries of A which begin with the string S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
strsplit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3052
 -- Function File: [CSTR] = strsplit (S)
 -- Function File: [CSTR] = strsplit (S, DEL)
 -- Function File: [CSTR] = strsplit (..., NAME, VALUE)
 -- Function File: [CSTR, MATCHES] = strsplit (...)
     Split the string S using the delimiters specified by DEL and return
     a cell string array of substrings.  If a delimiter is not specified
     the string, S, is split at whitespace.  The delimiter, DEL may be a
     string, a scalar cell string, or cell string array.  By default,
     consecutive delimiters in the input string S are collapsed into
     one.

     The second output, MATCHES, returns the delimiters which were
     matched in the original string.

     Example:

          strsplit ("a b c")
                =>
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
                    }

          strsplit ("a,b,c", ",")
                =>
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
                    }

          strsplit ("a foo b,bar c", {"\s", "foo", "bar"})
                =>
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
                    }

          strsplit ("a,,b, c", {",", " "}, false)
                =>
                    {
                      [1,1] = a
                      [1,2] =
                      [1,3] = b
                      [1,4] =
                      [1,5] = c
                    }


     Supported NAME/VALUE pair arguments are;

        * COLLAPSEDELIMITERS may take the value of TRUE or FALSE with
          the default being FALSE.

        * DELIMITERTYPE may take the value of 'simple' or
          'regularexpression'.  The default is DELIMITERTYPE is
          'simple'.

     Example:

          strsplit ("a foo b,bar c", ",|\\s|foo|bar", "delimitertype", "regularexpression")
                =>
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
                    }

          strsplit ("a,,b, c", "[, ]", false, "delimitertype", "regularexpression")
                =>
                    {
                      [1,1] = a
                      [1,2] =
                      [1,3] = b
                      [1,4] =
                      [1,5] = c
                    }

          strsplit ("a,\t,b, c", {',', '\s'}, "delimitertype", "regularexpression")
                =>
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
                    }

          strsplit ("a,\t,b, c", {',', ' ', '\t'}, "collapsedelimiters", false)
                =>
                    {
                      [1,1] = a
                      [1,2] =
                      [1,3] =
                      [1,4] = b
                      [1,5] =
                      [1,6] = c
                    }

     See also: ostrsplit, strjoin, strtok, regexp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Split the string S using the delimiters specified by DEL and return  a cell string array of substrings.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
strtok


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 843
 -- Function File: [TOK, REM] = strtok (STR)
 -- Function File: [TOK, REM] = strtok (STR, DELIM)

     Find all characters in the string STR up to, but not including, the
     first character which is in the string DELIM.  If REM is requested,
     it contains the remainder of the string, starting at the first
     delimiter.  Leading delimiters are ignored.  If DELIM is not
     specified, whitespace is assumed.  STR may also be a cell array of
     strings in which case the function executes on every individual
     string and returns a cell array of tokens and remainders.

     Examples:

          strtok ("this is the life")
               => "this"

          [tok, rem] = strtok ("14*27+31", "+-*/")
               =>
                  tok = 14
                  rem = *27+31

     See also: index, strsplit, strchr, isspace.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
Find all characters in the string STR up to, but not including, the  first character which is in the string DELIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strtrim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 436
 -- Function File: strtrim (S)
     Remove leading and trailing whitespace from S.  If S is a matrix,
     STRTRIM trims each row to the length of longest string.  If S is a
     cell array of strings, operate recursively on each string element.
     For example:

          strtrim ("    abc  ")
               =>  "abc"

          strtrim ([" abc   "; "   def   "])
               =>  ["abc  "  ; "  def"]

     See also: deblank.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Remove leading and trailing whitespace from S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
strtrunc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 295
 -- Function File: strtrunc (S, N)
     Truncate the character string S to length N.  If S is a character
     matrix, then the number of columns is adjusted.  If S is a cell
     array of strings, then the operation is performed on each cell
     element and the new cell array is returned.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Truncate the character string S to length N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
substr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 808
 -- Function File: substr (S, OFFSET)
 -- Function File: substr (S, OFFSET, LEN)
     Return the substring of S which starts at character number OFFSET
     and is LEN characters long.

     Position numbering for offsets begins with 1.  If OFFSET is
     negative, extraction starts that far from the end of the string.

     If LEN is omitted, the substring extends to the end of S.  A
     negative value for LEN extracts to within LEN characters of the end
     of the string

     Examples:

          substr ("This is a test string", 6, 9)
               => "is a test"
          substr ("This is a test string", -11)
               => "test string"
          substr ("This is a test string", -11, -7)
               => "test"

     This function is patterned after the equivalent function in Perl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 94
Return the substring of S which starts at character number OFFSET  and is LEN characters long.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
untabify


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 954
 -- Function File: untabify (T)
 -- Function File: untabify (T, TW)
 -- Function File: untabify (T, TW, DEBLANK)
     Replace TAB characters in T, with spaces.  The tab width is
     specified by TW, or defaults to eight.  The input, T, may be either
     a 2-D character array, or a cell array of character strings.  The
     output is the same class as the input.

     If the optional argument DEBLANK is true, then the spaces will be
     removed from the end of the character data.

     The following example reads a file and writes an untabified version
     of the same file with trailing spaces stripped.

          fid = fopen ("tabbed_script.m");
          text = char (fread (fid, "uchar")');
          fclose (fid);
          fid = fopen ("untabified_script.m", "w");
          text = untabify (strsplit (text, "\n"), 8, true);
          fprintf (fid, "%s\n", text{:});
          fclose (fid);

     See also: strjust, strsplit, deblank.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Replace TAB characters in T, with spaces.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
validatestring


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1457
 -- Function File: VALIDSTR = validatestring (STR, STRARRAY)
 -- Function File: VALIDSTR = validatestring (STR, STRARRAY, FUNCNAME)
 -- Function File: VALIDSTR = validatestring (STR, STRARRAY, FUNCNAME,
          VARNAME)
 -- Function File: VALIDSTR = validatestring (..., POSITION)
     Verify that STR is an element, or substring of an element, in
     STRARRAY.

     When STR is a character string to be tested, and STRARRAY is a
     cellstr of valid values, then VALIDSTR will be the validated form
     of STR where validation is defined as STR being a member or
     substring of VALIDSTR.  This is useful for both verifying and
     expanding short options, such as "r", to their longer forms, such
     as "red".  If STR is a substring of VALIDSTR, and there are
     multiple matches, the shortest match will be returned if all
     matches are substrings of each other.  Otherwise, an error will be
     raised because the expansion of STR is ambiguous.  All comparisons
     are case insensitive.

     The additional inputs FUNCNAME, VARNAME, and POSITION are optional
     and will make any generated validation error message more specific.

     Examples:

          validatestring ("r", {"red", "green", "blue"})
          => "red"

          validatestring ("b", {"red", "green", "blue", "black"})
          => error: validatestring: multiple unique matches were found for 'b':
             blue, black

     See also: strcmp, strcmpi.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 82
VARNAME)  Verify that STR is an element, or substring of an element, in  STRARRAY.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
assert


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1656
 -- Function File: assert (COND)
 -- Function File: assert (COND, ERRMSG, ...)
 -- Function File: assert (COND, MSG_ID, ERRMSG, ...)
 -- Function File: assert (OBSERVED, EXPECTED)
 -- Function File: assert (OBSERVED, EXPECTED, TOL)

     Produce an error if the specified condition is not met.  'assert'
     can be called in three different ways.

     'assert (COND)'
     'assert (COND, ERRMSG, ...)'
     'assert (COND, MSG_ID, ERRMSG, ...)'
          Called with a single argument COND, 'assert' produces an error
          if COND is zero.  When called with more than one argument the
          additional arguments are passed to the 'error' function.

     'assert (OBSERVED, EXPECTED)'
          Produce an error if observed is not the same as expected.
          Note that OBSERVED and EXPECTED can be scalars, vectors,
          matrices, strings, cell arrays, or structures.

     'assert (OBSERVED, EXPECTED, TOL)'
          Produce an error if observed is not the same as expected but
          equality comparison for numeric data uses a tolerance TOL.  If
          TOL is positive then it is an absolute tolerance which will
          produce an error if 'abs (OBSERVED - EXPECTED) > abs (TOL)'.
          If TOL is negative then it is a relative tolerance which will
          produce an error if 'abs (OBSERVED - EXPECTED) > abs (TOL *
          EXPECTED)'.  If EXPECTED is zero TOL will always be
          interpreted as an absolute tolerance.  If TOL is not scalar
          its dimensions must agree with those of OBSERVED and EXPECTED
          and tests are performed on an element-wise basis.

     See also: test, fail, error.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Produce an error if the specified condition is not met.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
demo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2366
 -- Command: demo NAME
 -- Command: demo NAME N
 -- Function File: demo ("NAME")
 -- Function File: demo ("NAME", N)

     Run example code block N associated with the function NAME.  If N
     is not specified, all examples are run.

     Examples are stored in the script file, or in a file with the same
     name but no extension located on Octave's load path.  To keep
     examples separate from regular script code, all lines are prefixed
     by '%!'.  Each example must also be introduced by the keyword
     "demo" flush left to the prefix with no intervening spaces.  The
     remainder of the example can contain arbitrary Octave code.  For
     example:

          %!demo
          %! t = 0:0.01:2*pi;
          %! x = sin (t);
          %! plot (t, x);
          %! %-------------------------------------------------
          %! % the figure window shows one cycle of a sine wave

     Note that the code is displayed before it is executed, so a simple
     comment at the end suffices for labeling what is being shown.  It
     is generally not necessary to use 'disp' or 'printf' within the
     demo.

     Demos are run in a function environment with no access to external
     variables.  This means that every demo must have separate
     initialization code.  Alternatively, all demos can be combined into
     a single large demo with the code

          %! input("Press <enter> to continue: ","s");

     between the sections, but this is discouraged.  Other techniques to
     avoid multiple initialization blocks include using multiple plots
     with a new 'figure' command between each plot, or using 'subplot'
     to put multiple plots in the same window.

     Also, because demo evaluates within a function context, you cannot
     define new functions inside a demo.  If you must have function
     blocks, rather than just anonymous functions or inline functions,
     you will have to use 'eval (example ("function",n))' to see them.
     Because eval only evaluates one line, or one statement if the
     statement crosses multiple lines, you must wrap your demo in "if 1
     <demo stuff> endif" with the "if" on the same line as "demo".  For
     example:

          %!demo if 1
          %!  function y=f(x)
          %!    y=x;
          %!  endfunction
          %!  f(3)
          %! endif

     See also: test, example.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Run example code block N associated with the function NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
example


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 571
 -- Command: example NAME
 -- Command: example NAME N
 -- Function File: example ("NAME")
 -- Function File: example ("NAME", N)
 -- Function File: [S, IDX] = example (...)

     Display the code for example N associated with the function NAME,
     but do not run it.  If N is not specified, all examples are
     displayed.

     When called with output arguments, the examples are returned in the
     form of a string S, with IDX indicating the ending position of the
     various examples.

     See 'demo' for a complete explanation.

     See also: demo, test.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
Display the code for example N associated with the function NAME,  but do not run it.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fail


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1222
 -- Function File: fail (CODE)
 -- Function File: fail (CODE, PATTERN)
 -- Function File: fail (CODE, "warning", PATTERN)

     Return true if CODE fails with an error message matching PATTERN,
     otherwise produce an error.  Note that CODE is a string and if CODE
     runs successfully, the error produced is:

                    expected error <.> but got none

     Code must be in the form of a string that may be passed by 'fail'
     to the Octave interpreter via the 'evalin' function, that is, a
     (quoted) string constant or a string variable.

     If called with two arguments, the behavior is similar to 'fail
     (CODE)', except the return value will only be true if code fails
     with an error message containing pattern (case sensitive).  If the
     code fails with a different error to that given in pattern, the
     message produced is:

                    expected <pattern>
                    but got <text of actual error>

     The angle brackets are not part of the output.

     Called with three arguments, the behavior is similar to 'fail
     (CODE, PATTERN)', but produces an error if no warning is given
     during code execution or if the code fails.

     See also: assert.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 94
Return true if CODE fails with an error message matching PATTERN,  otherwise produce an error.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
rundemos


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 414
 -- Function File: rundemos ()
 -- Function File: rundemos (DIRECTORY)
     Execute built-in demos for all function files in the specified
     directory.  Also executes demos in any C++ source files found in
     the directory, for use with dynamically linked functions.

     If no directory is specified, operate on all directories in
     Octave's search path for functions.

     See also: runtests, path.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Execute built-in demos for all function files in the specified  directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
runtests


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 414
 -- Function File: runtests ()
 -- Function File: runtests (DIRECTORY)
     Execute built-in tests for all function files in the specified
     directory.  Also executes tests in any C++ source files found in
     the directory, for use with dynamically linked functions.

     If no directory is specified, operate on all directories in
     Octave's search path for functions.

     See also: rundemos, path.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Execute built-in tests for all function files in the specified  directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
speed


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4875
 -- Function File: speed (F, INIT, MAX_N, F2, TOL)
 -- Function File: [ORDER, N, T_F, T_F2] = speed (...)

     Determine the execution time of an expression (F) for various input
     values (N).  The N are log-spaced from 1 to MAX_N.  For each N, an
     initialization expression (INIT) is computed to create any data
     needed for the test.  If a second expression (F2) is given then the
     execution times of the two expressions are compared.  When called
     without output arguments the results are printed to stdout and
     displayed graphically.

     'F'
          The code expression to evaluate.

     'MAX_N'
          The maximum test length to run.  The default value is 100.
          Alternatively, use '[min_n, max_n]' or specify the N exactly
          with '[n1, n2, ..., nk]'.

     'INIT'
          Initialization expression for function argument values.  Use K
          for the test number and N for the size of the test.  This
          should compute values for all variables used by F.  Note that
          INIT will be evaluated first for k = 0, so things which are
          constant throughout the test series can be computed once.  The
          default value is 'X = randn (N, 1)'.

     'F2'
          An alternative expression to evaluate, so that the speed of
          two expressions can be directly compared.  The default is
          '[]'.

     'TOL'
          Tolerance used to compare the results of expression F and
          expression F2.  If TOL is positive, the tolerance is an
          absolute one.  If TOL is negative, the tolerance is a relative
          one.  The default is 'eps'.  If TOL is 'Inf', then no
          comparison will be made.

     'ORDER'
          The time complexity of the expression O(a*n^p).  This is a
          structure with fields 'a' and 'p'.

     'N'
          The values N for which the expression was calculated *AND* the
          execution time was greater than zero.

     'T_F'
          The nonzero execution times recorded for the expression F in
          seconds.

     'T_F2'
          The nonzero execution times recorded for the expression F2 in
          seconds.  If required, the mean time ratio is simply 'mean
          (T_f ./ T_f2)'.

     The slope of the execution time graph shows the approximate power
     of the asymptotic running time O(n^p).  This power is plotted for
     the region over which it is approximated (the latter half of the
     graph).  The estimated power is not very accurate, but should be
     sufficient to determine the general order of an algorithm.  It
     should indicate if, for example, the implementation is unexpectedly
     O(n^2) rather than O(n) because it extends a vector each time
     through the loop rather than pre-allocating storage.  In the
     current version of Octave, the following is not the expected O(n).

          speed ("for i = 1:n, y{i} = x(i); endfor", "", [1000, 10000])

     But it is if you preallocate the cell array 'y':

          speed ("for i = 1:n, y{i} = x(i); endfor", ...
                 "x = rand (n, 1); y = cell (size (x));", [1000, 10000])

     An attempt is made to approximate the cost of individual
     operations, but it is wildly inaccurate.  You can improve the
     stability somewhat by doing more work for each 'n'.  For example:

          speed ("airy(x)", "x = rand (n, 10)", [10000, 100000])

     When comparing two different expressions (F, F2), the slope of the
     line on the speedup ratio graph should be larger than 1 if the new
     expression is faster.  Better algorithms have a shallow slope.
     Generally, vectorizing an algorithm will not change the slope of
     the execution time graph, but will shift it relative to the
     original.  For example:

          speed ("sum (x)", "", [10000, 100000], ...
                 "v = 0; for i = 1:length (x), v += x(i); endfor")

     The following is a more complex example.  If there was an original
     version of 'xcorr' using for loops and a second version using an
     FFT, then one could compare the run speed for various lags as
     follows, or for a fixed lag with varying vector lengths as follows:

          speed ("xcorr (x, n)", "x = rand (128, 1);", 100,
                 "xcorr_orig (x, n)", -100*eps)
          speed ("xcorr (x, 15)", "x = rand (20+n, 1);", 100,
                 "xcorr_orig (x, n)", -100*eps)

     Assuming one of the two versions is in xcorr_orig, this would
     compare their speed and their output values.  Note that the FFT
     version is not exact, so one must specify an acceptable tolerance
     on the comparison '100*eps'.  In this case, the comparison should
     be computed relatively, as 'abs ((X - Y) ./ Y)' rather than
     absolutely as 'abs (X - Y)'.

     Type 'example ("speed")' to see some real examples or 'demo
     ("speed")' to run them.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Determine the execution time of an expression (F) for various input  values (N).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2121
 -- Command: test NAME
 -- Command: test NAME quiet|normal|verbose
 -- Function File: test ("NAME", "quiet|normal|verbose", FID)
 -- Function File: test ([], "explain", FID)
 -- Function File: SUCCESS = test (...)
 -- Function File: [N, MAX] = test (...)
 -- Function File: [CODE, IDX] = test ("NAME", "grabdemo")

     Perform tests from the first file in the loadpath matching NAME.
     'test' can be called as a command or as a function.  Called with a
     single argument NAME, the tests are run interactively and stop
     after the first error is encountered.

     With a second argument the tests which are performed and the amount
     of output is selected.

     "quiet"
          Don't report all the tests as they happen, just the errors.

     "normal"
          Report all tests as they happen, but don't do tests which
          require user interaction.

     "verbose"
          Do tests which require user interaction.

     The argument FID can be used to allow batch processing.  Errors can
     be written to the already open file defined by FID, and hopefully
     when Octave crashes this file will tell you what was happening when
     it did.  You can use 'stdout' if you want to see the results as
     they happen.  You can also give a file name rather than an FID, in
     which case the contents of the file will be replaced with the log
     from the current test.

     Called with a single output argument SUCCESS, 'test' returns true
     if all of the tests were successful.  Called with two output
     arguments N and MAX, the number of successful tests and the total
     number of tests in the file NAME are returned.

     If the second argument is the string "grabdemo", the contents of
     the demo blocks are extracted but not executed.  Code for all code
     blocks is concatenated and returned as CODE with IDX being a vector
     of positions of the ends of the demo blocks.

     If the second argument is "explain", then NAME is ignored and an
     explanation of the line markers used is written to the file FID.

     See also: assert, fail, error, demo, example.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Perform tests from the first file in the loadpath matching NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
addtodate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 252
 -- Function File: D = addtodate (D, Q, F)
     Add Q amount of time (with units F) to the serial datenum, D.

     F must be one of "year", "month", "day", "hour", "minute",
     "second", or "millisecond".

     See also: datenum, datevec, etime.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Add Q amount of time (with units F) to the serial datenum, D.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
asctime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 332
 -- Function File: asctime (TM_STRUCT)
     Convert a time structure to a string using the following format:
     "ddd mmm mm HH:MM:SS yyyy".  For example:

          asctime (localtime (time ()))
               => "Mon Feb 17 01:15:06 1997"

     This is equivalent to 'ctime (time ())'.

     See also: ctime, localtime, time.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Convert a time structure to a string using the following format:  "ddd mmm mm HH:MM:SS yyyy".



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
calendar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 573
 -- Function File: C = calendar ()
 -- Function File: C = calendar (D)
 -- Function File: C = calendar (Y, M)
 -- Function File: calendar (...)
     Return the current monthly calendar in a 6x7 matrix.

     If D is specified, return the calendar for the month containing the
     date D, which must be a serial date number or a date string.

     If Y and M are specified, return the calendar for year Y and month
     M.

     If no output arguments are specified, print the calendar on the
     screen instead of returning a matrix.

     See also: datenum, datestr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return the current monthly calendar in a 6x7 matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
clock


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 558
 -- Function File: clock ()
     Return the current local date and time as a date vector.  The date
     vector contains the following fields: current year, month (1-12),
     day (1-31), hour (0-23), minute (0-59), and second (0-61).  The
     seconds field has a fractional part after the decimal point for
     extended accuracy.

     For example:

          fix (clock ())
               => [ 1993, 8, 20, 4, 56, 1 ]

     The function clock is more accurate on systems that have the
     'gettimeofday' function.

     See also: now, date, datevec.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Return the current local date and time as a date vector.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ctime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 397
 -- Function File: ctime (T)
     Convert a value returned from 'time' (or any other non-negative
     integer), to the local time and return a string of the same form as
     'asctime'.  The function 'ctime (time)' is equivalent to 'asctime
     (localtime (time))'.  For example:

          ctime (time ())
             => "Mon Feb 17 01:15:06 1997"

     See also: asctime, time, localtime.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 144
Convert a value returned from 'time' (or any other non-negative  integer), to the local time and return a string of the same form as  'asctime'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
date


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 226
 -- Function File: date ()
     Return the current date as a character string in the form
     DD-MMM-YYYY.

     For example:

          date ()
            => "20-Aug-1993"

     See also: now, clock, datestr, localtime.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Return the current date as a character string in the form  DD-MMM-YYYY.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
datenum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2065
 -- Function File: DAYS = datenum (DATEVEC)
 -- Function File: DAYS = datenum (YEAR, MONTH, DAY)
 -- Function File: DAYS = datenum (YEAR, MONTH, DAY, HOUR)
 -- Function File: DAYS = datenum (YEAR, MONTH, DAY, HOUR, MINUTE)
 -- Function File: DAYS = datenum (YEAR, MONTH, DAY, HOUR, MINUTE,
          SECOND)
 -- Function File: DAYS = datenum ("datestr")
 -- Function File: DAYS = datenum ("datestr", P)
 -- Function File: [DAYS, SECS] = datenum (...)
     Return the date/time input as a serial day number, with Jan 1, 0000
     defined as day 1.

     The integer part, 'floor (DAYS)' counts the number of complete days
     in the date input.

     The fractional part, 'rem (DAYS, 1)' corresponds to the time on the
     given day.

     The input may be a date vector (see 'datevec'), datestr (see
     'datestr'), or directly specified as input.

     When processing input datestrings, P is the year at the start of
     the century to which two-digit years will be referenced.  If not
     specified, it defaults to the current year minus 50.

     The optional output SECS holds the time on the specified day with
     greater precision than DAYS.

     Notes:

        * Years can be negative and/or fractional.

        * Months below 1 are considered to be January.

        * Days of the month start at 1.

        * Days beyond the end of the month go into subsequent months.

        * Days before the beginning of the month go to the previous
          month.

        * Days can be fractional.

     *Caution:* this function does not attempt to handle Julian
     calendars so dates before October 15, 1582 are wrong by as much as
     eleven days.  Also, be aware that only Roman Catholic countries
     adopted the calendar in 1582.  It took until 1924 for it to be
     adopted everywhere.  See the Wikipedia entry on the Gregorian
     calendar for more details.

     *Warning:* leap seconds are ignored.  A table of leap seconds is
     available on the Wikipedia entry for leap seconds.

     See also: datestr, datevec, now, clock, date.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
SECOND)  Return the date/time input as a serial day number, with Jan 1, 0000  defined as day 1.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
datestr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4435
 -- Function File: STR = datestr (DATE)
 -- Function File: STR = datestr (DATE, F)
 -- Function File: STR = datestr (DATE, F, P)
     Format the given date/time according to the format 'f' and return
     the result in STR.  DATE is a serial date number (see 'datenum') or
     a date vector (see 'datevec').  The value of DATE may also be a
     string or cell array of strings.

     F can be an integer which corresponds to one of the codes in the
     table below, or a date format string.

     P is the year at the start of the century in which two-digit years
     are to be interpreted in.  If not specified, it defaults to the
     current year minus 50.

     For example, the date 730736.65149 (2000-09-07 15:38:09.0934) would
     be formatted as follows:

     Code    Format                           Example
     -------------------------------------------------------------------
     0       dd-mmm-yyyy HH:MM:SS             07-Sep-2000 15:38:09
     1       dd-mmm-yyyy                      07-Sep-2000
     2       mm/dd/yy                         09/07/00
     3       mmm                              Sep
     4       m                                S
     5       mm                               09
     6       mm/dd                            09/07
     7       dd                               07
     8       ddd                              Thu
     9       d                                T
     10      yyyy                             2000
     11      yy                               00
     12      mmmyy                            Sep00
     13      HH:MM:SS                         15:38:09
     14      HH:MM:SS PM                      03:38:09 PM
     15      HH:MM                            15:38
     16      HH:MM PM                         03:38 PM
     17      QQ-YY                            Q3-00
     18      QQ                               Q3
     19      dd/mm                            07/09
     20      dd/mm/yy                         07/09/00
     21      mmm.dd,yyyy HH:MM:SS             Sep.07,2000 15:38:08
     22      mmm.dd,yyyy                      Sep.07,2000
     23      mm/dd/yyyy                       09/07/2000
     24      dd/mm/yyyy                       07/09/2000
     25      yy/mm/dd                         00/09/07
     26      yyyy/mm/dd                       2000/09/07
     27      QQ-YYYY                          Q3-2000
     28      mmmyyyy                          Sep2000
     29      yyyy-mm-dd                       2000-09-07
     30      yyyymmddTHHMMSS                  20000907T153808
     31      yyyy-mm-dd HH:MM:SS              2000-09-07 15:38:08

     If F is a format string, the following symbols are recognized:

     Symbol  Meaning                                            Example
     --------------------------------------------------------------------------
     yyyy    Full year                                          2005
     yy      Two-digit year                                     05
     mmmm    Full month name                                    December
     mmm     Abbreviated month name                             Dec
     mm      Numeric month number (padded with zeros)           01, 08, 12
     m       First letter of month name (capitalized)           D
     dddd    Full weekday name                                  Sunday
     ddd     Abbreviated weekday name                           Sun
     dd      Numeric day of month (padded with zeros)           11
     d       First letter of weekday name (capitalized)         S
     HH      Hour of day, padded with zeros if PM is set        09:00
             and not padded with zeros otherwise                9:00 AM
     MM      Minute of hour (padded with zeros)                 10:05
     SS      Second of minute (padded with zeros)               10:05:03
     FFF     Milliseconds of second (padded with zeros)         10:05:03.012
     AM      Use 12-hour time format                            11:30 AM
     PM      Use 12-hour time format                            11:30 PM

     If F is not specified or is '-1', then use 0, 1 or 16, depending on
     whether the date portion or the time portion of DATE is empty.

     If P is nor specified, it defaults to the current year minus 50.

     If a matrix or cell array of dates is given, a column vector of
     date strings is returned.

     See also: datenum, datevec, date, now, clock.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
Format the given date/time according to the format 'f' and return  the result in STR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
datevec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1151
 -- Function File: V = datevec (DATE)
 -- Function File: V = datevec (DATE, F)
 -- Function File: V = datevec (DATE, P)
 -- Function File: V = datevec (DATE, F, P)
 -- Function File: [Y, M, D, H, MI, S] = datevec (...)
     Convert a serial date number (see 'datenum') or date string (see
     'datestr') into a date vector.

     A date vector is a row vector with six members, representing the
     year, month, day, hour, minute, and seconds respectively.

     F is the format string used to interpret date strings (see
     'datestr').  If DATE is a string, but no format is specified, then
     a relatively slow search is performed through various formats.  It
     is always preferable to specify the format string F if it is known.
     Formats which do not specify a particular time component will have
     the value set to zero.  Formats which do not specify a date will
     default to January 1st of the current year.

     P is the year at the start of the century to which two-digit years
     will be referenced.  If not specified, it defaults to the current
     year minus 50.

     See also: datenum, datestr, clock, now, date.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Convert a serial date number (see 'datenum') or date string (see  'datestr') into a date vector.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
eomday


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 163
 -- Function File: E = eomday (Y, M)
     Return the last day of the month M for the year Y.

     See also: weekday, datenum, datevec, is_leap_year, calendar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return the last day of the month M for the year Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
etime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 422
 -- Function File: etime (T2, T1)
     Return the difference in seconds between two time values returned
     from 'clock' (T2 - T1).  For example:

          t0 = clock ();
          # many computations later...
          elapsed_time = etime (clock (), t0);

     will set the variable 'elapsed_time' to the number of seconds since
     the variable 't0' was set.

     See also: tic, toc, clock, cputime, addtodate.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Return the difference in seconds between two time values returned  from 'clock' (T2 - T1).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
is_leap_year


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 313
 -- Function File: is_leap_year ()
 -- Function File: is_leap_year (YEAR)
     Return true if YEAR is a leap year and false otherwise.  If no year
     is specified, 'is_leap_year' uses the current year.  For example:

          is_leap_year (2000)
             => 1

     See also: weekday, eomday, calendar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Return true if YEAR is a leap year and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
now


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 345
 -- Function File: t = now ()
     Return the current local date/time as a serial day number (see
     'datenum').

     The integral part, 'floor (now)' corresponds to the number of days
     between today and Jan 1, 0000.

     The fractional part, 'rem (now, 1)' corresponds to the current
     time.

     See also: clock, date, datenum.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return the current local date/time as a serial day number (see  'datenum').



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
weekday


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 852
 -- Function File: [N, S] = weekday (D)
 -- Function File: [N, S] = weekday (D, FORMAT)
     Return the day of the week as a number in N and as a string in S.
     The days of the week are numbered 1-7 with the first day being
     Sunday.

     D is a serial date number or a date string.

     If the string FORMAT is not present or is equal to "short" then S
     will contain the abbreviated name of the weekday.  If FORMAT is
     "long" then S will contain the full name.

     Table of return values based on FORMAT:

     N    "short"   "long"
     ----------------------------
     1    Sun       Sunday
     2    Mon       Monday
     3    Tue       Tuesday
     4    Wed       Wednesday
     5    Thu       Thursday
     6    Fri       Friday
     7    Sat       Saturday

     See also: eomday, is_leap_year, calendar, datenum, datevec.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return the day of the week as a number in N and as a string in S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
gnuplot_binary


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 490
 -- Loadable Function: [PROG, ARGS] = gnuplot_binary ()
 -- Loadable Function: [OLD_PROG, OLD_ARGS] = gnuplot_binary (NEW_PROG,
          ARG1, ...)
     Query or set the name of the program invoked by the plot command
     when the graphics toolkit is set to "gnuplot".  Additional
     arguments to pass to the external plotting program may also be
     given.  The default value is "gnuplot" with no additional
     arguments.  *Note Installation::.

     See also: graphics_toolkit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ARG1, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
isguirunning


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
 -- Built-in Function: isguirunning ()
     Return true if Octave is running in GUI mode and false otherwise.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return true if Octave is running in GUI mode and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
argv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 528
 -- Built-in Function: argv ()
     Return the command line arguments passed to Octave.  For example,
     if you invoked Octave using the command

          octave --no-line-editing --silent

     'argv' would return a cell array of strings with the elements
     '--no-line-editing' and '--silent'.

     If you write an executable Octave script, 'argv' will return the
     list of arguments passed to the script.  *Note Executable Octave
     Programs::, for an example of how to create an executable Octave
     script.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return the command line arguments passed to Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
program_invocation_name


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 429
 -- Built-in Function: program_invocation_name ()
     Return the name that was typed at the shell prompt to run Octave.

     If executing a script from the command line (e.g., 'octave foo.m')
     or using an executable Octave script, the program name is set to
     the name of the script.  *Note Executable Octave Programs::, for an
     example of how to create an executable Octave script.

     See also: program_name.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return the name that was typed at the shell prompt to run Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
program_name


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 171
 -- Built-in Function: program_name ()
     Return the last component of the value returned by
     'program_invocation_name'.

     See also: program_invocation_name.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Return the last component of the value returned by  'program_invocation_name'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
sparse_auto_mutate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 813
 -- Built-in Function: VAL = sparse_auto_mutate ()
 -- Built-in Function: OLD_VAL = sparse_auto_mutate (NEW_VAL)
 -- Built-in Function: sparse_auto_mutate (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     will automatically mutate sparse matrices to full matrices to save
     memory.  For example:

          s = speye (3);
          sparse_auto_mutate (false);
          s(:, 1) = 1;
          typeinfo (s)
          => sparse matrix
          sparse_auto_mutate (true);
          s(1, :) = 1;
          typeinfo (s)
          => matrix

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 140
Query or set the internal variable that controls whether Octave  will automatically mutate sparse matrices to full matrices to save  memory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
logical


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 420
 -- Built-in Function: logical (X)
     Convert the numeric object X to logical type.

     Any non-zero values will be converted to true (1) while zero values
     will be converted to false (0).  The non-numeric value NaN cannot
     be converted and will produce an error.

     Compatibility Note: Octave accepts complex values as input, whereas
     MATLAB issues an error.

     See also: double, single, char.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Convert the numeric object X to logical type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
iscell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
 -- Built-in Function: iscell (X)
     Return true if X is a cell array object.

     See also: ismatrix, isstruct, iscellstr, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Return true if X is a cell array object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 480
 -- Built-in Function: cell (N)
 -- Built-in Function: cell (M, N)
 -- Built-in Function: cell (M, N, K, ...)
 -- Built-in Function: cell ([M N ...])
     Create a new cell array object.

     If invoked with a single scalar integer argument, return a square
     NxN cell array.  If invoked with two or more scalar integer
     arguments, or a vector of integer values, return an array with the
     given dimensions.

     See also: cellstr, mat2cell, num2cell, struct2cell.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Create a new cell array object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
iscellstr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
 -- Built-in Function: iscellstr (CELL)
     Return true if every element of the cell array CELL is a character
     string.

     See also: ischar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return true if every element of the cell array CELL is a character  string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cellstr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 354
 -- Built-in Function: CSTR = cellstr (STRMAT)
     Create a new cell array object from the elements of the string
     array STRMAT.

     Each row of STRMAT becomes an element of CSTR.  Any trailing spaces
     in a row are deleted before conversion.

     To convert back from a cellstr to a character array use 'char'.

     See also: cell, char.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Create a new cell array object from the elements of the string  array STRMAT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
struct2cell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 830
 -- Built-in Function: C = struct2cell (S)
     Create a new cell array from the objects stored in the struct
     object.  If F is the number of fields in the structure, the
     resulting cell array will have a dimension vector corresponding to
     '[F size(S)]'.  For example:

          s = struct ("name", {"Peter", "Hannah", "Robert"},
                     "age", {23, 16, 3});
          c = struct2cell (s)
             => c = {2x1x3 Cell Array}
          c(1,1,:)(:)
             =>
                {
                  [1,1] = Peter
                  [2,1] = Hannah
                  [3,1] = Robert
                }
          c(2,1,:)(:)
             =>
                {
                  [1,1] = 23
                  [2,1] = 16
                  [3,1] = 3
                }

     See also: cell2struct, fieldnames.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Create a new cell array from the objects stored in the struct  object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
class


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 359
 -- Function File: CLASSNAME = class (OBJ)
 -- Function File: class (S, ID)
 -- Function File: class (S, ID, P, ...)
     Return the class of the object OBJ or create a class with fields
     from structure S and name (string) ID.  Additional arguments name a
     list of parent classes from which the new class is derived.

     See also: typeinfo, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
Return the class of the object OBJ or create a class with fields  from structure S and name (string) ID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isobject


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 128
 -- Built-in Function: isobject (X)
     Return true if X is a class object.

     See also: class, typeinfo, isa, ismethod.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Return true if X is a class object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ismethod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 175
 -- Built-in Function: ismethod (X, METHOD)
     Return true if X is a class object and the string METHOD is a
     method of this class.

     See also: isprop, isobject.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Return true if X is a class object and the string METHOD is a  method of this class.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
superiorto


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 347
 -- Built-in Function: superiorto (CLASS_NAME, ...)
     When called from a class constructor, mark the object currently
     constructed as having a higher precedence than CLASS_NAME.  More
     that one such class can be specified in a single call.  This
     function may only be called from a class constructor.

     See also: inferiorto.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
When called from a class constructor, mark the object currently  constructed as having a higher precedence than CLASS_NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
inferiorto


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 346
 -- Built-in Function: inferiorto (CLASS_NAME, ...)
     When called from a class constructor, mark the object currently
     constructed as having a lower precedence than CLASS_NAME.  More
     that one such class can be specified in a single call.  This
     function may only be called from a class constructor.

     See also: superiorto.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 122
When called from a class constructor, mark the object currently  constructed as having a lower precedence than CLASS_NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
functions


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1161
 -- Built-in Function: S = functions (FCN_HANDLE)
     Return a structure containing information about the function handle
     FCN_HANDLE.

     The structure S always contains these 3 fields:

     function
          The function name.  For an anonymous function (no name) this
          will be the actual function definition.

     type
          Type of the function.

          anonymous
               The function is anonymous.

          private
               The function is private.

          overloaded
               The function overloads an existing function.

          simple
               The function is a built-in or m-file function.

          subfunction
               The function is a subfunction within an m-file.

     file
          The m-file that will be called to perform the function.  This
          field is empty for anonymous and built-in functions.

     In addition, some function types may return more information in
     additional fields.

     *Warning:* 'functions' is provided for debugging purposes only.
     It's behavior may change in the future and programs should not
     depend on a particular output.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a structure containing information about the function handle  FCN_HANDLE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
func2str


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 193
 -- Built-in Function: func2str (FCN_HANDLE)
     Return a string containing the name of the function referenced by
     the function handle FCN_HANDLE.

     See also: str2func, functions.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Return a string containing the name of the function referenced by  the function handle FCN_HANDLE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
str2func


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 310
 -- Built-in Function: str2func (FCN_NAME)
 -- Built-in Function: str2func (FCN_NAME, "global")
     Return a function handle constructed from the string FCN_NAME.  If
     the optional "global" argument is passed, locally visible functions
     are ignored in the lookup.

     See also: func2str, inline.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return a function handle constructed from the string FCN_NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
is_function_handle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 142
 -- Built-in Function: is_function_handle (X)
     Return true if X is a function handle.

     See also: isa, typeinfo, class, functions.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return true if X is a function handle.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
inline


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1266
 -- Built-in Function: inline (STR)
 -- Built-in Function: inline (STR, ARG1, ...)
 -- Built-in Function: inline (STR, N)
     Create an inline function from the character string STR.

     If called with a single argument, the arguments of the generated
     function are extracted from the function itself.  The generated
     function arguments will then be in alphabetical order.  It should
     be noted that i, and j are ignored as arguments due to the
     ambiguity between their use as a variable or their use as an
     inbuilt constant.  All arguments followed by a parenthesis are
     considered to be functions.  If no arguments are found, a function
     taking a single argument named 'x' will be created.

     If the second and subsequent arguments are character strings, they
     are the names of the arguments of the function.

     If the second argument is an integer N, the arguments are "x",
     "P1", ..., "PN".

     Programming Note: The use of 'inline' is discouraged and it may be
     removed from a future version of Octave.  The preferred way to
     create functions from strings is through the use of anonymous
     functions (*note Anonymous Functions::) or 'str2func'.

     See also: argnames, formula, vectorize, str2func.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Create an inline function from the character string STR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
formula


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 216
 -- Built-in Function: formula (FUN)
     Return a character string representing the inline function FUN.
     Note that 'char (FUN)' is equivalent to 'formula (FUN)'.

     See also: argnames, inline, vectorize.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return a character string representing the inline function FUN.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
argnames


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 202
 -- Built-in Function: argnames (FUN)
     Return a cell array of character strings containing the names of
     the arguments of the inline function FUN.

     See also: inline, formula, vectorize.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 107
Return a cell array of character strings containing the names of  the arguments of the inline function FUN.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
vectorize


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 516
 -- Built-in Function: vectorize (FUN)
     Create a vectorized version of the inline function FUN by replacing
     all occurrences of '*', '/', etc., with '.*', './', etc.

     This may be useful, for example, when using inline functions with
     numerical integration or optimization where a vector-valued
     function is expected.

          fcn = vectorize (inline ("x^2 - 1"))
             => fcn = f(x) = x.^2 - 1
          quadv (fcn, 0, 3)
             => 6

     See also: inline, formula, argnames.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
Create a vectorized version of the inline function FUN by replacing  all occurrences of '*', '/', etc.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
single


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
 -- Built-in Function: single (X)
     Convert X to single precision type.

     See also: double.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Convert X to single precision type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
javaObject


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 538
 -- Built-in Function: JOBJ = javaObject (CLASSNAME)
 -- Built-in Function: JOBJ = javaObject (CLASSNAME, ARG1, ...)
     Create a Java object of class CLASSSNAME, by calling the class
     constructor with the arguments ARG1, ...

     The first example below creates an uninitialized object, while the
     second example supplies an initial argument to the constructor.

          x = javaObject ("java.lang.StringBuffer")
          x = javaObject ("java.lang.StringBuffer", "Initial string")

     See also: javaMethod, javaArray.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
Create a Java object of class CLASSSNAME, by calling the class  constructor with the arguments ARG1, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
javaMethod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 708
 -- Built-in Function: RET = javaMethod (METHODNAME, OBJ)
 -- Built-in Function: RET = javaMethod (METHODNAME, OBJ, ARG1, ...)
     Invoke the method METHODNAME on the Java object OBJ with the
     arguments ARG1, ... For static methods, OBJ can be a string
     representing the fully qualified name of the corresponding class.
     The function returns the result of the method invocation.

     When OBJ is a regular Java object, structure-like indexing can be
     used as a shortcut syntax.  For instance, the two following
     statements are equivalent

            ret = javaMethod ("method1", x, 1.0, "a string")
            ret = x.method1 (1.0, "a string")

     See also: methods, javaObject.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Invoke the method METHODNAME on the Java object OBJ with the  arguments ARG1, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
java2mat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 82
 -- Built-in Function: java2mat (JAVAOBJ)
     Undocumented internal function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
java_matrix_autoconversion


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 648
 -- Built-in Function: VAL = java_matrix_autoconversion ()
 -- Built-in Function: OLD_VAL = java_matrix_autoconversion (NEW_VAL)
 -- Built-in Function: java_matrix_autoconversion (NEW_VAL, "local")
     Query or set the internal variable that controls whether Java
     arrays are automatically converted to Octave matrices.  The default
     value is false.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: java_unsigned_autoconversion, debug_java.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
Query or set the internal variable that controls whether Java  arrays are automatically converted to Octave matrices.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
java_unsigned_autoconversion


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 789
 -- Built-in Function: VAL = java_unsigned_autoconversion ()
 -- Built-in Function: OLD_VAL = java_unsigned_autoconversion (NEW_VAL)
 -- Built-in Function: java_unsigned_autoconversion (NEW_VAL, "local")
     Query or set the internal variable that controls how integer
     classes are converted when 'java_matrix_autoconversion' is enabled.
     When enabled, Java arrays of class Byte or Integer are converted to
     matrices of class uint8 or uint32 respectively.  The default value
     is true.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: java_matrix_autoconversion, debug_java.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
Query or set the internal variable that controls how integer  classes are converted when 'java_matrix_autoconversion' is enabled.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
debug_java


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 633
 -- Built-in Function: VAL = debug_java ()
 -- Built-in Function: OLD_VAL = debug_java (NEW_VAL)
 -- Built-in Function: debug_java (NEW_VAL, "local")
     Query or set the internal variable that determines whether extra
     debugging information regarding the initialization of the JVM and
     any Java exceptions is printed.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: java_matrix_autoconversion, java_unsigned_autoconversion.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
Query or set the internal variable that determines whether extra  debugging information regarding the initialization of the JVM and  any Java exceptions is printed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isjava


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
 -- Built-in Function: isjava (X)
     Return true if X is a Java object.

     See also: class, typeinfo, isa, javaObject.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return true if X is a Java object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isnull


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 559
 -- Built-in Function: isnull (X)
     Return true if X is a special null matrix, string, or single quoted
     string.  Indexed assignment with such a value on the right-hand
     side should delete array elements.  This function should be used
     when overloading indexed assignment for user-defined classes
     instead of 'isempty', to distinguish the cases:

     'A(I) = []'
          This should delete elements if 'I' is nonempty.

     'X = []; A(I) = X'
          This should give an error if 'I' is nonempty.

     See also: isempty, isindex.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Return true if X is a special null matrix, string, or single quoted  string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
onCleanup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 520
 -- Built-in Function: OBJ = onCleanup (FUNCTION)
     Create a special object that executes a given function upon
     destruction.  If the object is copied to multiple variables (or
     cell or struct array elements) or returned from a function,
     FUNCTION will be executed after clearing the last copy of the
     object.  Note that if multiple local onCleanup variables are
     created, the order in which they are called is unspecified.  For
     similar functionality *Note The unwind_protect Statement::.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Create a special object that executes a given function upon  destruction.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
allow_noninteger_range_as_index


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 760
 -- Built-in Function: VAL = allow_noninteger_range_as_index ()
 -- Built-in Function: OLD_VAL = allow_noninteger_range_as_index
          (NEW_VAL)
 -- Built-in Function: allow_noninteger_range_as_index (NEW_VAL,
          "local")
     Query or set the internal variable that controls whether
     non-integer ranges are allowed as indices.  This might be useful
     for MATLAB compatibility; however, it is still not entirely
     compatible because MATLAB treats the range expression differently
     in different contexts.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 121
(NEW_VAL)  "local")  Query or set the internal variable that controls whether  non-integer ranges are allowed as indices.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
double


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
 -- Built-in Function: double (X)
     Convert X to double precision type.

     See also: single.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Convert X to double precision type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
struct


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1951
 -- Built-in Function: S = struct ()
 -- Built-in Function: S = struct (FIELD1, VALUE1, FIELD2, VALUE2, ...)
 -- Built-in Function: S = struct (OBJ)

     Create a scalar or array structure and initialize its values.  The
     FIELD1, FIELD2, ... variables are strings specifying the names of
     the fields and the VALUE1, VALUE2, ... variables can be of any
     type.

     If the values are cell arrays, create a structure array and
     initialize its values.  The dimensions of each cell array of values
     must match.  Singleton cells and non-cell values are repeated so
     that they fill the entire array.  If the cells are empty, create an
     empty structure array with the specified field names.

     If the argument is an object, return the underlying struct.

     Observe that the syntax is optimized for struct *arrays*.  Consider
     the following examples:

          struct ("foo", 1)
            => scalar structure containing the fields:
              foo =  1

          struct ("foo", {})
            => 0x0 struct array containing the fields:
              foo

          struct ("foo", { {} })
            => scalar structure containing the fields:
              foo = {}(0x0)

          struct ("foo", {1, 2, 3})
            => 1x3 struct array containing the fields:
              foo


     The first case is an ordinary scalar struct--one field, one value.
     The second produces an empty struct array with one field and no
     values, since s being passed an empty cell array of struct array
     values.  When the value is a cell array containing a single entry,
     this becomes a scalar struct with that single entry as the value of
     the field.  That single entry happens to be an empty cell array.

     Finally, if the value is a non-scalar cell array, then 'struct'
     produces a struct *array*.

     See also: cell2struct, fieldnames, orderfields, getfield, setfield,
     rmfield, structfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Create a scalar or array structure and initialize its values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isstruct


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 137
 -- Built-in Function: isstruct (X)
     Return true if X is a structure or a structure array.

     See also: ismatrix, iscell, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return true if X is a structure or a structure array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isfield


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 294
 -- Built-in Function: isfield (X, "NAME")
 -- Built-in Function: isfield (X, NAME)
     Return true if the X is a structure and it includes an element
     named NAME.  If NAME is a cell array of strings then a logical
     array of equal dimension is returned.

     See also: fieldnames.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return true if the X is a structure and it includes an element  named NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nfields


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 119
 -- Built-in Function: nfields (S)
     Return the number of fields of the structure S.

     See also: fieldnames.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return the number of fields of the structure S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
cell2struct


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 675
 -- Built-in Function: cell2struct (CELL, FIELDS)
 -- Built-in Function: cell2struct (CELL, FIELDS, DIM)
     Convert CELL to a structure.  The number of fields in FIELDS must
     match the number of elements in CELL along dimension DIM, that is
     'numel (FIELDS) == size (CELL, DIM)'.  If DIM is omitted, a value
     of 1 is assumed.

          A = cell2struct ({"Peter", "Hannah", "Robert";
                             185, 170, 168},
                           {"Name","Height"}, 1);
          A(1)
             =>
                {
                  Name   = Peter
                  Height = 185
                }


     See also: struct2cell, cell2mat, struct.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Convert CELL to a structure.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rmfield


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 302
 -- Built-in Function: S = rmfield (S, "F")
 -- Built-in Function: S = rmfield (S, F)
     Return a _copy_ of the structure (array) S with the field F
     removed.  If F is a cell array of strings or a character array,
     remove each of the named fields.

     See also: orderfields, fieldnames.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Return a _copy_ of the structure (array) S with the field F  removed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
struct_levels_to_print


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 565
 -- Built-in Function: VAL = struct_levels_to_print ()
 -- Built-in Function: OLD_VAL = struct_levels_to_print (NEW_VAL)
 -- Built-in Function: struct_levels_to_print (NEW_VAL, "local")
     Query or set the internal variable that specifies the number of
     structure levels to display.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: print_struct_array_contents.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Query or set the internal variable that specifies the number of  structure levels to display.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
print_struct_array_contents


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 842
 -- Built-in Function: VAL = print_struct_array_contents ()
 -- Built-in Function: OLD_VAL = print_struct_array_contents (NEW_VAL)
 -- Built-in Function: print_struct_array_contents (NEW_VAL, "local")
     Query or set the internal variable that specifies whether to print
     struct array contents.

     If true, values of struct array elements are printed.  This
     variable does not affect scalar structures whose elements are
     always printed.  In both cases, however, printing will be limited
     to the number of levels specified by STRUCT_LEVELS_TO_PRINT.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: struct_levels_to_print.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Query or set the internal variable that specifies whether to print  struct array contents.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
typeinfo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 277
 -- Built-in Function: typeinfo ()
 -- Built-in Function: typeinfo (EXPR)

     Return the type of the expression EXPR, as a string.  If EXPR is
     omitted, return a cell array of strings containing all the
     currently installed data types.

     See also: class, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return the type of the expression EXPR, as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
nargin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 798
 -- Built-in Function: nargin ()
 -- Built-in Function: nargin (FCN)
     Within a function, return the number of arguments passed to the
     function.  At the top level, return the number of command line
     arguments passed to Octave.

     If called with the optional argument FCN--a function name or
     handle-- return the declared number of arguments that the function
     can accept.

     If the last argument to FCN is VARARGIN the returned value is
     negative.  For example, the function 'union' for sets is declared
     as

          function [y, ia, ib] = union (a, b, varargin)

          and

          nargin ("union")
          => -3

     Programming Note: 'nargin' does not work on built-in functions.

     See also: nargout, varargin, isargout, varargout, nthargout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Within a function, return the number of arguments passed to the  function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nargout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1105
 -- Built-in Function: nargout ()
 -- Built-in Function: nargout (FCN)
     Within a function, return the number of values the caller expects
     to receive.  If called with the optional argument FCN--a function
     name or handle--return the number of declared output values that
     the function can produce.  If the final output argument is
     VARARGOUT the returned value is negative.

     For example,

          f ()

     will cause 'nargout' to return 0 inside the function 'f' and

          [s, t] = f ()

     will cause 'nargout' to return 2 inside the function 'f'.

     In the second usage,

          nargout (@histc) % or nargout ("histc")

     will return 2, because 'histc' has two outputs, whereas

          nargout (@imread)

     will return -2, because 'imread' has two outputs and the second is
     VARARGOUT.

     At the top level, 'nargout' with no argument is undefined and will
     produce an error.  'nargout' does not work for built-in functions
     and returns -1 for all anonymous functions.

     See also: nargin, varargin, isargout, varargout, nthargout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Within a function, return the number of values the caller expects  to receive.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
optimize_subsasgn_calls


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 634
 -- Built-in Function: VAL = optimize_subsasgn_calls ()
 -- Built-in Function: OLD_VAL = optimize_subsasgn_calls (NEW_VAL)
 -- Built-in Function: optimize_subsasgn_calls (NEW_VAL, "local")
     Query or set the internal flag for subsasgn method call
     optimizations.

     If true, Octave will attempt to eliminate the redundant copying
     when calling the subsasgn method of a user-defined class.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Query or set the internal flag for subsasgn method call  optimizations.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isargout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 748
 -- Built-in Function: isargout (K)
     Within a function, return a logical value indicating whether the
     argument K will be assigned to a variable on output.  If the result
     is false, the argument has been ignored during the function call
     through the use of the tilde (~) special output argument.
     Functions can use 'isargout' to avoid performing unnecessary
     calculations for outputs which are unwanted.

     If K is outside the range '1:max (nargout)', the function returns
     false.  K can also be an array, in which case the function works
     element-by-element and a logical array is returned.  At the top
     level, 'isargout' returns an error.

     See also: nargout, nargin, varargin, varargout, nthargout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 118
Within a function, return a logical value indicating whether the  argument K will be assigned to a variable on output.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
sizeof


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
 -- Built-in Function: sizeof (VAL)
     Return the size of VAL in bytes.

     See also: whos.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Return the size of VAL in bytes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
subsref


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 960
 -- Built-in Function: subsref (VAL, IDX)
     Perform the subscripted element selection operation according to
     the subscript specified by IDX.

     The subscript IDX is expected to be a structure array with fields
     'type' and 'subs'.  Valid values for 'type' are '"()"', '"{}"', and
     '"."'.  The 'subs' field may be either '":"' or a cell array of
     index values.

     The following example shows how to extract the first two columns of
     a matrix

          val = magic (3)
              => val = [ 8   1   6
                         3   5   7
                         4   9   2 ]
          idx.type = "()";
          idx.subs = {":", 1:2};
          subsref (val, idx)
               => [ 8   1
                    3   5
                    4   9 ]

     Note that this is the same as writing 'val(:,1:2)'.

     If IDX is an empty structure array with fields 'type' and 'subs',
     return VAL.

     See also: subsasgn, substruct.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Perform the subscripted element selection operation according to  the subscript specified by IDX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
subsasgn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 887
 -- Built-in Function: subsasgn (VAL, IDX, RHS)
     Perform the subscripted assignment operation according to the
     subscript specified by IDX.

     The subscript IDX is expected to be a structure array with fields
     'type' and 'subs'.  Valid values for 'type' are '"()"', '"{}"', and
     '"."'.  The 'subs' field may be either '":"' or a cell array of
     index values.

     The following example shows how to set the two first columns of a
     3-by-3 matrix to zero.

          val = magic (3);
          idx.type = "()";
          idx.subs = {":", 1:2};
          subsasgn (val, idx, 0)
               =>  [ 0   0   6
                     0   0   7
                     0   0   2 ]

     Note that this is the same as writing 'val(:,1:2) = 0'.

     If IDX is an empty structure array with fields 'type' and 'subs',
     return RHS.

     See also: subsref, substruct.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Perform the subscripted assignment operation according to the  subscript specified by IDX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
is_sq_string


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 140
 -- Built-in Function: is_sq_string (X)
     Return true if X is a single-quoted character string.

     See also: is_dq_string, ischar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return true if X is a single-quoted character string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
is_dq_string


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 140
 -- Built-in Function: is_dq_string (X)
     Return true if X is a double-quoted character string.

     See also: is_sq_string, ischar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return true if X is a double-quoted character string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
int16


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 142
 -- Built-in Function: int16 (X)
     Convert X to 16-bit integer type.

     See also: int8, uint8, uint16, int32, uint32, int64, uint64.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Convert X to 16-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
int32


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 142
 -- Built-in Function: int32 (X)
     Convert X to 32-bit integer type.

     See also: int8, uint8, int16, uint16, uint32, int64, uint64.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Convert X to 32-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
int64


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 142
 -- Built-in Function: int64 (X)
     Convert X to 64-bit integer type.

     See also: int8, uint8, int16, uint16, int32, uint32, uint64.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Convert X to 64-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
int8


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 141
 -- Built-in Function: int8 (X)
     Convert X to 8-bit integer type.

     See also: uint8, int16, uint16, int32, uint32, int64, uint64.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Convert X to 8-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
uint16


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 151
 -- Built-in Function: uint16 (X)
     Convert X to unsigned 16-bit integer type.

     See also: int8, uint8, int16, int32, uint32, int64, uint64.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Convert X to unsigned 16-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
uint32


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 151
 -- Built-in Function: uint32 (X)
     Convert X to unsigned 32-bit integer type.

     See also: int8, uint8, int16, uint16, int32, int64, uint64.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Convert X to unsigned 32-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
uint64


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 151
 -- Built-in Function: uint64 (X)
     Convert X to unsigned 64-bit integer type.

     See also: int8, uint8, int16, uint16, int32, uint32, int64.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Convert X to unsigned 64-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
uint8


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
 -- Built-in Function: uint8 (X)
     Convert X to unsigned 8-bit integer type.

     See also: int8, int16, uint16, int32, uint32, int64, uint64.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Convert X to unsigned 8-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
end


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 298
 -- Built-in Function: end
     The magic index "end" refers to the last valid entry in an indexing
     operation.

     Example:

          X = [ 1 2 3
                4 5 6 ];
          X(1,end)
              => 3
          X(end,1)
              => 4
          X(end,end)
              => 6
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
The magic index "end" refers to the last valid entry in an indexing  operation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
do_braindead_shortcircuit_evaluation


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 961
 -- Built-in Function: VAL = do_braindead_shortcircuit_evaluation ()
 -- Built-in Function: OLD_VAL = do_braindead_shortcircuit_evaluation
          (NEW_VAL)
 -- Built-in Function: do_braindead_shortcircuit_evaluation (NEW_VAL,
          "local")
     Query or set the internal variable that controls whether Octave
     will do short-circuit evaluation of '|' and '&' operators inside
     the conditions of if or while statements.

     This feature is only provided for compatibility with MATLAB and
     should not be used unless you are porting old code that relies on
     this feature.

     To obtain short-circuit behavior for logical expressions in new
     programs, you should always use the '&&' and '||' operators.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 193
(NEW_VAL)  "local")  Query or set the internal variable that controls whether Octave  will do short-circuit evaluation of '|' and '&' operators inside  the conditions of if or while statements.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
max_recursion_depth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 609
 -- Built-in Function: VAL = max_recursion_depth ()
 -- Built-in Function: OLD_VAL = max_recursion_depth (NEW_VAL)
 -- Built-in Function: max_recursion_depth (NEW_VAL, "local")
     Query or set the internal limit on the number of times a function
     may be called recursively.  If the limit is exceeded, an error
     message is printed and control returns to the top level.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Query or set the internal limit on the number of times a function  may be called recursively.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
silent_functions


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 684
 -- Built-in Function: VAL = silent_functions ()
 -- Built-in Function: OLD_VAL = silent_functions (NEW_VAL)
 -- Built-in Function: silent_functions (NEW_VAL, "local")
     Query or set the internal variable that controls whether internal
     output from a function is suppressed.  If this option is disabled,
     Octave will display the results produced by evaluating expressions
     within a function body that are not terminated with a semicolon.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
Query or set the internal variable that controls whether internal  output from a function is suppressed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
string_fill_char


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 765
 -- Built-in Function: VAL = string_fill_char ()
 -- Built-in Function: OLD_VAL = string_fill_char (NEW_VAL)
 -- Built-in Function: string_fill_char (NEW_VAL, "local")
     Query or set the internal variable used to pad all rows of a
     character matrix to the same length; It must be a single character.
     The default value is " " (a single space).  For example:

          string_fill_char ("X");
          [ "these"; "are"; "strings" ]
                =>  "theseXX"
                    "areXXXX"
                    "strings"

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
Query or set the internal variable used to pad all rows of a  character matrix to the same length; It must be a single character.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
iskeyword


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 213
 -- Built-in Function: iskeyword ()
 -- Built-in Function: iskeyword (NAME)
     Return true if NAME is an Octave keyword.  If NAME is omitted,
     return a list of keywords.

     See also: isvarname, exist.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Return true if NAME is an Octave keyword.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
balance


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1488
 -- Built-in Function: AA = balance (A)
 -- Built-in Function: AA = balance (A, OPT)
 -- Built-in Function: [DD, AA] = balance (A, OPT)
 -- Built-in Function: [D, P, AA] = balance (A, OPT)
 -- Built-in Function: [CC, DD, AA, BB] = balance (A, B, OPT)

     Compute 'AA = DD \ A * DD' in which AA is a matrix whose row and
     column norms are roughly equal in magnitude, and 'DD = P * D', in
     which P is a permutation matrix and D is a diagonal matrix of
     powers of two.  This allows the equilibration to be computed
     without round-off.  Results of eigenvalue calculation are typically
     improved by balancing first.

     If two output values are requested, 'balance' returns the diagonal
     D and the permutation P separately as vectors.  In this case, 'DD =
     eye(n)(:,P) * diag (D)', where n is the matrix size.

     If four output values are requested, compute 'AA = CC*A*DD' and 'BB
     = CC*B*DD', in which AA and BB have non-zero elements of
     approximately the same magnitude and CC and DD are permuted
     diagonal matrices as in DD for the algebraic eigenvalue problem.

     The eigenvalue balancing option OPT may be one of:

     "noperm", "S"
          Scale only; do not permute.

     "noscal", "P"
          Permute only; do not scale.

     Algebraic eigenvalue balancing uses standard LAPACK routines.

     Generalized eigenvalue problem balancing uses Ward's algorithm
     (SIAM Journal on Scientific and Statistical Computing, 1981).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 210
Compute 'AA = DD \ A * DD' in which AA is a matrix whose row and  column norms are roughly equal in magnitude, and 'DD = P * D', in  which P is a permutation matrix and D is a diagonal matrix of  powers of two.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
besselj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2158
 -- Built-in Function: [J, IERR] = besselj (ALPHA, X, OPT)
 -- Built-in Function: [Y, IERR] = bessely (ALPHA, X, OPT)
 -- Built-in Function: [I, IERR] = besseli (ALPHA, X, OPT)
 -- Built-in Function: [K, IERR] = besselk (ALPHA, X, OPT)
 -- Built-in Function: [H, IERR] = besselh (ALPHA, K, X, OPT)
     Compute Bessel or Hankel functions of various kinds:

     'besselj'
          Bessel functions of the first kind.  If the argument OPT is
          supplied, the result is multiplied by 'exp (-abs (imag (X)))'.

     'bessely'
          Bessel functions of the second kind.  If the argument OPT is
          supplied, the result is multiplied by 'exp (-abs (imag (X)))'.

     'besseli'

          Modified Bessel functions of the first kind.  If the argument
          OPT is supplied, the result is multiplied by 'exp (-abs (real
          (X)))'.

     'besselk'

          Modified Bessel functions of the second kind.  If the argument
          OPT is supplied, the result is multiplied by 'exp (X)'.

     'besselh'
          Compute Hankel functions of the first (K = 1) or second (K =
          2) kind.  If the argument OPT is supplied, the result is
          multiplied by 'exp (-I*X)' for K = 1 or 'exp (I*X)' for K = 2.

     If ALPHA is a scalar, the result is the same size as X.  If X is a
     scalar, the result is the same size as ALPHA.  If ALPHA is a row
     vector and X is a column vector, the result is a matrix with
     'length (X)' rows and 'length (ALPHA)' columns.  Otherwise, ALPHA
     and X must conform and the result will be the same size.

     The value of ALPHA must be real.  The value of X may be complex.

     If requested, IERR contains the following status information and is
     the same size as the result.

       0. Normal return.

       1. Input error, return 'NaN'.

       2. Overflow, return 'Inf'.

       3. Loss of significance by argument reduction results in less
          than half of machine accuracy.

       4. Complete loss of significance by argument reduction, return
          'NaN'.

       5. Error--no computation, algorithm termination condition not
          met, return 'NaN'.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute Bessel or Hankel functions of various kinds: 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bessely


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 -- Built-in Function: [Y, IERR] = bessely (ALPHA, X, OPT)
     See besselj.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
See besselj.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
besseli


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 -- Built-in Function: [I, IERR] = besseli (ALPHA, X, OPT)
     See besselj.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
See besselj.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
besselk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 -- Built-in Function: [K, IERR] = besselk (ALPHA, X, OPT)
     See besselj.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
See besselj.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
besselh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
 -- Built-in Function: [H, IERR] = besselh (ALPHA, K, X, OPT)
     See besselj.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
See besselj.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
airy


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1122
 -- Built-in Function: [A, IERR] = airy (K, Z, OPT)
     Compute Airy functions of the first and second kind, and their
     derivatives.

           K   Function   Scale factor (if "opt" is supplied)
          ---  --------   ---------------------------------------
           0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))
           1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))
           2   Bi (Z)     exp (-abs (real ((2/3) * Z * sqrt (Z))))
           3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z * sqrt (Z))))

     The function call 'airy (Z)' is equivalent to 'airy (0, Z)'.

     The result is the same size as Z.

     If requested, IERR contains the following status information and is
     the same size as the result.

       0. Normal return.

       1. Input error, return 'NaN'.

       2. Overflow, return 'Inf'.

       3. Loss of significance by argument reduction results in less
          than half of machine accuracy.

       4. Complete loss of significance by argument reduction, return
          'NaN'.

       5. Error--no computation, algorithm termination condition not
          met, return 'NaN'.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Compute Airy functions of the first and second kind, and their  derivatives.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
betainc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 530
 -- Mapping Function: betainc (X, A, B)
     Return the regularized incomplete Beta function,

                                             x
                                    1       /
          betainc (x, a, b) = -----------   | t^(a-1) (1-t)^(b-1) dt.
                              beta (a, b)   /
                                         t=0

     If X has more than one component, both A and B must be scalars.  If
     X is a scalar, A and B must be of compatible dimensions.

     See also: betaincinv, beta, betaln.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Return the regularized incomplete Beta function, 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
betaincinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 200
 -- Mapping Function: betaincinv (Y, A, B)
     Compute the inverse of the incomplete Beta function, i.e., X such
     that

          Y == betainc (X, A, B)

     See also: betainc, beta, betaln.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Compute the inverse of the incomplete Beta function, i.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bitand


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 210
 -- Built-in Function: bitand (X, Y)
     Return the bitwise AND of non-negative integers.  X, Y must be in
     the range [0,bitmax]

     See also: bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the bitwise AND of non-negative integers.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
bitor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 208
 -- Built-in Function: bitor (X, Y)
     Return the bitwise OR of non-negative integers.  X, Y must be in
     the range [0,bitmax]

     See also: bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return the bitwise OR of non-negative integers.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bitxor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 210
 -- Built-in Function: bitxor (X, Y)
     Return the bitwise XOR of non-negative integers.  X, Y must be in
     the range [0,bitmax]

     See also: bitand, bitor, bitset, bitget, bitcmp, bitshift, bitmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the bitwise XOR of non-negative integers.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
bitshift


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 579
 -- Built-in Function: bitshift (A, K)
 -- Built-in Function: bitshift (A, K, N)
     Return a K bit shift of N-digit unsigned integers in A.  A positive
     K leads to a left shift; A negative value to a right shift.  If N
     is omitted it defaults to log2(bitmax)+1.  N must be in the range
     [1,log2(bitmax)+1] usually [1,33].

          bitshift (eye (3), 1)
          =>
          2 0 0
          0 2 0
          0 0 2

          bitshift (10, [-2, -1, 0, 1, 2])
          => 2   5  10  20  40

     See also: bitand, bitor, bitxor, bitset, bitget, bitcmp, bitmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Return a K bit shift of N-digit unsigned integers in A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bitmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 433
 -- Built-in Function: bitmax ()
 -- Built-in Function: bitmax ("double")
 -- Built-in Function: bitmax ("single")
     Return the largest integer that can be represented within a
     floating point value.  The default class is "double", but "single"
     is a valid option.  On IEEE-754 compatible systems, 'bitmax' is 2^{53} - 1
     for "double" and 2^{24} -1 for "single".

     See also: flintmax, intmax, realmax, realmin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 82
Return the largest integer that can be represented within a  floating point value.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
flintmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 438
 -- Built-in Function: flintmax ()
 -- Built-in Function: flintmax ("double")
 -- Built-in Function: flintmax ("single")
     Return the largest integer that can be represented consecutively in
     a floating point value.  The default class is "double", but
     "single" is a valid option.  On IEEE-754 compatible systems,
     'flintmax' is 2^53 for "double" and 2^24 for "single".

     See also: bitmax, intmax, realmax, realmin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
Return the largest integer that can be represented consecutively in  a floating point value.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
intmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 612
 -- Built-in Function: intmax (TYPE)
     Return the largest integer that can be represented in an integer
     type.  The variable TYPE can be

     'int8'
          signed 8-bit integer.

     'int16'
          signed 16-bit integer.

     'int32'
          signed 32-bit integer.

     'int64'
          signed 64-bit integer.

     'uint8'
          unsigned 8-bit integer.

     'uint16'
          unsigned 16-bit integer.

     'uint32'
          unsigned 32-bit integer.

     'uint64'
          unsigned 64-bit integer.

     The default for TYPE is 'int32'.

     See also: intmin, flintmax, bitmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Return the largest integer that can be represented in an integer  type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
intmin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 613
 -- Built-in Function: intmin (TYPE)
     Return the smallest integer that can be represented in an integer
     type.  The variable TYPE can be

     'int8'
          signed 8-bit integer.

     'int16'
          signed 16-bit integer.

     'int32'
          signed 32-bit integer.

     'int64'
          signed 64-bit integer.

     'uint8'
          unsigned 8-bit integer.

     'uint16'
          unsigned 16-bit integer.

     'uint32'
          unsigned 32-bit integer.

     'uint64'
          unsigned 64-bit integer.

     The default for TYPE is 'int32'.

     See also: intmax, flintmax, bitmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Return the smallest integer that can be represented in an integer  type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
sizemax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 377
 -- Built-in Function: sizemax ()
     Return the largest value allowed for the size of an array.  If
     Octave is compiled with 64-bit indexing, the result is of class
     int64, otherwise it is of class int32.  The maximum array size is
     slightly smaller than the maximum value allowable for the relevant
     class as reported by 'intmax'.

     See also: intmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Return the largest value allowed for the size of an array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bsxfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 758
 -- Built-in Function: bsxfun (F, A, B)
     The binary singleton expansion function applier performs
     broadcasting, that is, applies a binary function F
     element-by-element to two array arguments A and B, and expands as
     necessary singleton dimensions in either input argument.  F is a
     function handle, inline function, or string containing the name of
     the function to evaluate.  The function F must be capable of
     accepting two column-vector arguments of equal length, or one
     column vector argument and a scalar.

     The dimensions of A and B must be equal or singleton.  The
     singleton dimensions of the arrays will be expanded to the same
     dimensionality as the other array.

     See also: arrayfun, cellfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 233
The binary singleton expansion function applier performs  broadcasting, that is, applies a binary function F  element-by-element to two array arguments A and B, and expands as  necessary singleton dimensions in either input argument.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cellfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4149
 -- Built-in Function: cellfun (NAME, C)
 -- Built-in Function: cellfun ("size", C, K)
 -- Built-in Function: cellfun ("isclass", C, CLASS)
 -- Built-in Function: cellfun (FUNC, C)
 -- Built-in Function: cellfun (FUNC, C, D)
 -- Built-in Function: [A, ...] = cellfun (...)
 -- Built-in Function: cellfun (..., "ErrorHandler", ERRFUNC)
 -- Built-in Function: cellfun (..., "UniformOutput", VAL)

     Evaluate the function named NAME on the elements of the cell array
     C.  Elements in C are passed on to the named function individually.
     The function NAME can be one of the functions

     'isempty'
          Return 1 for empty elements.

     'islogical'
          Return 1 for logical elements.

     'isnumeric'
          Return 1 for numeric elements.

     'isreal'
          Return 1 for real elements.

     'length'
          Return a vector of the lengths of cell elements.

     'ndims'
          Return the number of dimensions of each element.

     'numel'
     'prodofsize'
          Return the number of elements contained within each cell
          element.  The number is the product of the dimensions of the
          object at each cell element.

     'size'
          Return the size along the K-th dimension.

     'isclass'
          Return 1 for elements of CLASS.

     Additionally, 'cellfun' accepts an arbitrary function FUNC in the
     form of an inline function, function handle, or the name of a
     function (in a character string).  The function can take one or
     more arguments, with the inputs arguments given by C, D, etc.
     Equally the function can return one or more output arguments.  For
     example:

          cellfun ("atan2", {1, 0}, {0, 1})
               => [ 1.57080   0.00000 ]

     The number of output arguments of 'cellfun' matches the number of
     output arguments of the function.  The outputs of the function will
     be collected into the output arguments of 'cellfun' like this:

          function [a, b] = twoouts (x)
            a = x;
            b = x*x;
          endfunction
          [aa, bb] = cellfun (@twoouts, {1, 2, 3})
               =>
                  aa =
                     1 2 3
                  bb =
                     1 4 9

     Note that per default the output argument(s) are arrays of the same
     size as the input arguments.  Input arguments that are singleton
     (1x1) cells will be automatically expanded to the size of the other
     arguments.

     If the parameter "UniformOutput" is set to true (the default), then
     the function must return scalars which will be concatenated into
     the return array(s).  If "UniformOutput" is false, the outputs are
     concatenated into a cell array (or cell arrays).  For example:

          cellfun ("tolower", {"Foo", "Bar", "FooBar"},
                   "UniformOutput", false)
          => {"foo", "bar", "foobar"}

     Given the parameter "ErrorHandler", then ERRFUNC defines a function
     to call in case FUNC generates an error.  The form of the function
     is

          function [...] = errfunc (S, ...)

     where there is an additional input argument to ERRFUNC relative to
     FUNC, given by S.  This is a structure with the elements
     "identifier", "message" and "index", giving respectively the error
     identifier, the error message, and the index into the input
     arguments of the element that caused the error.  For example:

          function y = foo (s, x), y = NaN; endfunction
          cellfun ("factorial", {-1,2}, "ErrorHandler", @foo)
          => [NaN 2]

     Use 'cellfun' intelligently.  The 'cellfun' function is a useful
     tool for avoiding loops.  It is often used with anonymous function
     handles; however, calling an anonymous function involves an
     overhead quite comparable to the overhead of an m-file function.
     Passing a handle to a built-in function is faster, because the
     interpreter is not involved in the internal loop.  For example:

          a = {...}
          v = cellfun (@(x) det (x), a); # compute determinants
          v = cellfun (@det, a); # faster

     See also: arrayfun, structfun, spfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Evaluate the function named NAME on the elements of the cell array  C.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
arrayfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3478
 -- Function File: arrayfun (FUNC, A)
 -- Function File: X = arrayfun (FUNC, A)
 -- Function File: X = arrayfun (FUNC, A, B, ...)
 -- Function File: [X, Y, ...] = arrayfun (FUNC, A, ...)
 -- Function File: arrayfun (..., "UniformOutput", VAL)
 -- Function File: arrayfun (..., "ErrorHandler", ERRFUNC)

     Execute a function on each element of an array.  This is useful for
     functions that do not accept array arguments.  If the function does
     accept array arguments it is better to call the function directly.

     The first input argument FUNC can be a string, a function handle,
     an inline function, or an anonymous function.  The input argument A
     can be a logic array, a numeric array, a string array, a structure
     array, or a cell array.  By a call of the function 'arrayfun' all
     elements of A are passed on to the named function FUNC
     individually.

     The named function can also take more than two input arguments,
     with the input arguments given as third input argument B, fourth
     input argument C, ... If given more than one array input argument
     then all input arguments must have the same sizes, for example:

          arrayfun (@atan2, [1, 0], [0, 1])
               => [ 1.5708   0.0000 ]

     If the parameter VAL after a further string input argument
     "UniformOutput" is set 'true' (the default), then the named
     function FUNC must return a single element which then will be
     concatenated into the return value and is of type matrix.
     Otherwise, if that parameter is set to 'false', then the outputs
     are concatenated in a cell array.  For example:

          arrayfun (@(x,y) x:y, "abc", "def", "UniformOutput", false)
          =>
             {
               [1,1] = abcd
               [1,2] = bcde
               [1,3] = cdef
             }

     If more than one output arguments are given then the named function
     must return the number of return values that also are expected, for
     example:

          [A, B, C] = arrayfun (@find, [10; 0], "UniformOutput", false)
          =>
          A =
          {
             [1,1] =  1
             [2,1] = [](0x0)
          }
          B =
          {
             [1,1] =  1
             [2,1] = [](0x0)
          }
          C =
          {
             [1,1] =  10
             [2,1] = [](0x0)
          }

     If the parameter ERRFUNC after a further string input argument
     "ErrorHandler" is another string, a function handle, an inline
     function, or an anonymous function, then ERRFUNC defines a function
     to call in the case that FUNC generates an error.  The definition
     of the function must be of the form

          function [...] = errfunc (S, ...)

     where there is an additional input argument to ERRFUNC relative to
     FUNC, given by S.  This is a structure with the elements
     "identifier", "message", and "index" giving, respectively, the
     error identifier, the error message, and the index of the array
     elements that caused the error.  The size of the output argument of
     ERRFUNC must have the same size as the output argument of FUNC,
     otherwise a real error is thrown.  For example:

          function y = ferr (s, x), y = "MyString"; endfunction
          arrayfun (@str2num, [1234],
                    "UniformOutput", false, "ErrorHandler", @ferr)
          =>
             {
               [1,1] = MyString
             }

     See also: spfun, cellfun, structfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Execute a function on each element of an array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
num2cell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 737
 -- Built-in Function: C = num2cell (A)
 -- Built-in Function: C = num2cell (A, DIM)
     Convert the numeric matrix A to a cell array.  If DIM is defined,
     the value C is of dimension 1 in this dimension and the elements of
     A are placed into C in slices.  For example:

          num2cell ([1,2;3,4])
             =>
                {
                  [1,1] =  1
                  [2,1] =  3
                  [1,2] =  2
                  [2,2] =  4
                }
          num2cell ([1,2;3,4],1)
             =>
                {
                  [1,1] =
                     1
                     3
                  [1,2] =
                     2
                     4
                }

     See also: mat2cell.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Convert the numeric matrix A to a cell array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
mat2cell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1004
 -- Built-in Function: C = mat2cell (A, M, N)
 -- Built-in Function: C = mat2cell (A, D1, D2, ...)
 -- Built-in Function: C = mat2cell (A, R)
     Convert the matrix A to a cell array.  If A is 2-D, then it is
     required that 'sum (M) == size (A, 1)' and 'sum (N) == size (A,
     2)'.  Similarly, if A is multi-dimensional and the number of
     dimensional arguments is equal to the dimensions of A, then it is
     required that 'sum (DI) == size (A, i)'.

     Given a single dimensional argument R, the other dimensional
     arguments are assumed to equal 'size (A,I)'.

     An example of the use of mat2cell is

          mat2cell (reshape (1:16,4,4), [3,1], [3,1])
          =>
          {
             [1,1] =

                1   5   9
                2   6  10
                3   7  11

             [2,1] =

                4   8  12

             [1,2] =

               13
               14
               15

             [2,2] = 16
          }

     See also: num2cell, cell2mat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Convert the matrix A to a cell array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
cellslices


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 634
 -- Built-in Function: SL = cellslices (X, LB, UB, DIM)
     Given an array X, this function produces a cell array of slices
     from the array determined by the index vectors LB, UB, for lower
     and upper bounds, respectively.  In other words, it is equivalent
     to the following code:

          n = length (lb);
          sl = cell (1, n);
          for i = 1:length (lb)
            sl{i} = x(:,...,lb(i):ub(i),...,:);
          endfor

     The position of the index is determined by DIM.  If not specified,
     slicing is done along the first non-singleton dimension.

     See also: cell2mat, cellindexmat, cellfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 162
Given an array X, this function produces a cell array of slices  from the array determined by the index vectors LB, UB, for lower  and upper bounds, respectively.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
cellindexmat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 273
 -- Built-in Function: Y = cellindexmat (X, VARARGIN)
     Given a cell array of matrices X, this function computes

          Y = cell (size (X));
          for i = 1:numel (X)
            Y{i} = X{i}(varargin{:});
          endfor

     See also: cellslices, cellfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Given a cell array of matrices X, this function computes 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
colloc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 307
 -- Built-in Function: [R, AMAT, BMAT, Q] = colloc (N, "left", "right")
     Compute derivative and integral weight matrices for orthogonal
     collocation using the subroutines given in J. Villadsen and M. L.
     Michelsen, 'Solution of Differential Equation Models by Polynomial
     Approximation'.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
Compute derivative and integral weight matrices for orthogonal  collocation using the subroutines given in J.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
conv2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 925
 -- Built-in Function: conv2 (A, B)
 -- Built-in Function: conv2 (V1, V2, M)
 -- Built-in Function: conv2 (..., SHAPE)
     Return the 2-D convolution of A and B.  The size of the result is
     determined by the optional SHAPE argument which takes the following
     values

     SHAPE = "full"
          Return the full convolution.  (default)

     SHAPE = "same"
          Return the central part of the convolution with the same size
          as A.  The central part of the convolution begins at the
          indices 'floor ([size(B)/2] + 1)'.

     SHAPE = "valid"
          Return only the parts which do not include zero-padded edges.
          The size of the result is 'max (size (A) - size (B) + 1, 0)'.

     When the third argument is a matrix, return the convolution of the
     matrix M by the vector V1 in the column direction and by the vector
     V2 in the row direction.

     See also: conv, convn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return the 2-D convolution of A and B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
convn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 713
 -- Built-in Function: C = convn (A, B)
 -- Built-in Function: C = convn (A, B, SHAPE)
     Return the n-D convolution of A and B.  The size of the result is
     determined by the optional SHAPE argument which takes the following
     values

     SHAPE = "full"
          Return the full convolution.  (default)

     SHAPE = "same"
          Return central part of the convolution with the same size as
          A.  The central part of the convolution begins at the indices
          'floor ([size(B)/2] + 1)'.

     SHAPE = "valid"
          Return only the parts which do not include zero-padded edges.
          The size of the result is 'max (size (A) - size (B) + 1, 0)'.

     See also: conv2, conv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return the n-D convolution of A and B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
daspk_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6424
 -- Built-in Function: daspk_options ()
 -- Built-in Function: val = daspk_options (OPT)
 -- Built-in Function: daspk_options (OPT, VAL)
     Query or set options for the function 'daspk'.  When called with no
     arguments, the names of all available options and their current
     values are displayed.  Given one argument, return the value of the
     corresponding option.  When called with two arguments,
     'daspk_options' set the option OPT to value VAL.

     Options include

     '"absolute tolerance"'
          Absolute tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the relative tolerance must also be a vector of the same
          length.

     '"relative tolerance"'
          Relative tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the absolute tolerance must also be a vector of the same
          length.

          The local error test applied at each integration step is

                 abs (local error in x(i))
                      <= rtol(i) * abs (Y(i)) + atol(i)

     '"compute consistent initial condition"'
          Denoting the differential variables in the state vector by
          'Y_d' and the algebraic variables by 'Y_a', 'ddaspk' can solve
          one of two initialization problems:

            1. Given Y_d, calculate Y_a and Y'_d

            2. Given Y', calculate Y.

          In either case, initial values for the given components are
          input, and initial guesses for the unknown components must
          also be provided as input.  Set this option to 1 to solve the
          first problem, or 2 to solve the second (the default is 0, so
          you must provide a set of initial conditions that are
          consistent).

          If this option is set to a nonzero value, you must also set
          the "algebraic variables" option to declare which variables in
          the problem are algebraic.

     '"use initial condition heuristics"'
          Set to a nonzero value to use the initial condition heuristics
          options described below.

     '"initial condition heuristics"'
          A vector of the following parameters that can be used to
          control the initial condition calculation.

          'MXNIT'
               Maximum number of Newton iterations (default is 5).

          'MXNJ'
               Maximum number of Jacobian evaluations (default is 6).

          'MXNH'
               Maximum number of values of the artificial stepsize
               parameter to be tried if the "compute consistent initial
               condition" option has been set to 1 (default is 5).

               Note that the maximum total number of Newton iterations
               allowed is 'MXNIT*MXNJ*MXNH' if the "compute consistent
               initial condition" option has been set to 1 and
               'MXNIT*MXNJ' if it is set to 2.

          'LSOFF'
               Set to a nonzero value to disable the linesearch
               algorithm (default is 0).

          'STPTOL'
               Minimum scaled step in linesearch algorithm (default is
               eps^(2/3)).

          'EPINIT'
               Swing factor in the Newton iteration convergence test.
               The test is applied to the residual vector, premultiplied
               by the approximate Jacobian.  For convergence, the
               weighted RMS norm of this vector (scaled by the error
               weights) must be less than 'EPINIT*EPCON', where 'EPCON'
               = 0.33 is the analogous test constant used in the time
               steps.  The default is 'EPINIT' = 0.01.

     '"print initial condition info"'
          Set this option to a nonzero value to display detailed
          information about the initial condition calculation (default
          is 0).

     '"exclude algebraic variables from error test"'
          Set to a nonzero value to exclude algebraic variables from the
          error test.  You must also set the "algebraic variables"
          option to declare which variables in the problem are algebraic
          (default is 0).

     '"algebraic variables"'
          A vector of the same length as the state vector.  A nonzero
          element indicates that the corresponding element of the state
          vector is an algebraic variable (i.e., its derivative does not
          appear explicitly in the equation set.

          This option is required by the compute consistent initial
          condition" and "exclude algebraic variables from error test"
          options.

     '"enforce inequality constraints"'
          Set to one of the following values to enforce the inequality
          constraints specified by the "inequality constraint types"
          option (default is 0).

            1. To have constraint checking only in the initial condition
               calculation.

            2. To enforce constraint checking during the integration.

            3. To enforce both options 1 and 2.

     '"inequality constraint types"'
          A vector of the same length as the state specifying the type
          of inequality constraint.  Each element of the vector
          corresponds to an element of the state and should be assigned
          one of the following codes

          -2
               Less than zero.

          -1
               Less than or equal to zero.

          0
               Not constrained.

          1
               Greater than or equal to zero.

          2
               Greater than zero.

          This option only has an effect if the "enforce inequality
          constraints" option is nonzero.

     '"initial step size"'
          Differential-algebraic problems may occasionally suffer from
          severe scaling difficulties on the first step.  If you know a
          great deal about the scaling of your problem, you can help to
          alleviate this problem by specifying an initial stepsize
          (default is computed automatically).

     '"maximum order"'
          Restrict the maximum order of the solution method.  This
          option must be between 1 and 5, inclusive (default is 5).

     '"maximum step size"'
          Setting the maximum stepsize will avoid passing over very
          large regions (default is not specified).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Query or set options for the function 'daspk'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
daspk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2574
 -- Built-in Function: [X, XDOT, ISTATE, MSG] = daspk (FCN, X_0, XDOT_0,
          T, T_CRIT)
     Solve the set of differential-algebraic equations

          0 = f (x, xdot, t)

     with

          x(t_0) = x_0, xdot(t_0) = xdot_0

     The solution is returned in the matrices X and XDOT, with each row
     in the result matrices corresponding to one of the elements in the
     vector T.  The first element of T should be t_0 and correspond to
     the initial state of the system X_0 and its derivative XDOT_0, so
     that the first row of the output X is X_0 and the first row of the
     output XDOT is XDOT_0.

     The first argument, FCN, is a string, inline, or function handle
     that names the function f to call to compute the vector of
     residuals for the set of equations.  It must have the form

          RES = f (X, XDOT, T)

     in which X, XDOT, and RES are vectors, and T is a scalar.

     If FCN is a two-element string array or a two-element cell array of
     strings, inline functions, or function handles, the first element
     names the function f described above, and the second element names
     a function to compute the modified Jacobian

                df       df
          jac = -- + c ------
                dx     d xdot

     The modified Jacobian function must have the form


          JAC = j (X, XDOT, T, C)


     The second and third arguments to 'daspk' specify the initial
     condition of the states and their derivatives, and the fourth
     argument specifies a vector of output times at which the solution
     is desired, including the time corresponding to the initial
     condition.

     The set of initial states and derivatives are not strictly required
     to be consistent.  If they are not consistent, you must use the
     'daspk_options' function to provide additional information so that
     'daspk' can compute a consistent starting point.

     The fifth argument is optional, and may be used to specify a set of
     times that the DAE solver should not integrate past.  It is useful
     for avoiding difficulties with singularities and points where there
     is a discontinuity in the derivative.

     After a successful computation, the value of ISTATE will be greater
     than zero (consistent with the Fortran version of DASPK).

     If the computation is not successful, the value of ISTATE will be
     less than zero and MSG will contain additional information.

     You can use the function 'daspk_options' to set optional parameters
     for 'daspk'.

     See also: dassl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
T, T_CRIT)  Solve the set of differential-algebraic equations 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
dasrt_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1882
 -- Built-in Function: dasrt_options ()
 -- Built-in Function: val = dasrt_options (OPT)
 -- Built-in Function: dasrt_options (OPT, VAL)
     Query or set options for the function 'dasrt'.  When called with no
     arguments, the names of all available options and their current
     values are displayed.  Given one argument, return the value of the
     corresponding option.  When called with two arguments,
     'dasrt_options' set the option OPT to value VAL.

     Options include

     '"absolute tolerance"'
          Absolute tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the relative tolerance must also be a vector of the same
          length.

     '"relative tolerance"'
          Relative tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the absolute tolerance must also be a vector of the same
          length.

          The local error test applied at each integration step is

                 abs (local error in x(i)) <= ...
                     rtol(i) * abs (Y(i)) + atol(i)

     '"initial step size"'
          Differential-algebraic problems may occasionally suffer from
          severe scaling difficulties on the first step.  If you know a
          great deal about the scaling of your problem, you can help to
          alleviate this problem by specifying an initial stepsize.

     '"maximum order"'
          Restrict the maximum order of the solution method.  This
          option must be between 1 and 5, inclusive.

     '"maximum step size"'
          Setting the maximum stepsize will avoid passing over very
          large regions.

     '"step limit"'
          Maximum number of integration steps to attempt on a single
          call to the underlying Fortran code.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Query or set options for the function 'dasrt'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
dasrt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4358
 -- Built-in Function: [X, XDOT, T_OUT, ISTAT, MSG] = dasrt (FCN, [],
          X_0, XDOT_0, T)
 -- Built-in Function: ... = dasrt (FCN, G, X_0, XDOT_0, T)
 -- Built-in Function: ... = dasrt (FCN, [], X_0, XDOT_0, T, T_CRIT)
 -- Built-in Function: ... = dasrt (FCN, G, X_0, XDOT_0, T, T_CRIT)
     Solve the set of differential-algebraic equations

          0 = f (x, xdot, t)

     with

          x(t_0) = x_0, xdot(t_0) = xdot_0

     with functional stopping criteria (root solving).

     The solution is returned in the matrices X and XDOT, with each row
     in the result matrices corresponding to one of the elements in the
     vector T_OUT.  The first element of T should be t_0 and correspond
     to the initial state of the system X_0 and its derivative XDOT_0,
     so that the first row of the output X is X_0 and the first row of
     the output XDOT is XDOT_0.

     The vector T provides an upper limit on the length of the
     integration.  If the stopping condition is met, the vector T_OUT
     will be shorter than T, and the final element of T_OUT will be the
     point at which the stopping condition was met, and may not
     correspond to any element of the vector T.

     The first argument, FCN, is a string, inline, or function handle
     that names the function f to call to compute the vector of
     residuals for the set of equations.  It must have the form

          RES = f (X, XDOT, T)

     in which X, XDOT, and RES are vectors, and T is a scalar.

     If FCN is a two-element string array or a two-element cell array of
     strings, inline functions, or function handles, the first element
     names the function f described above, and the second element names
     a function to compute the modified Jacobian

                df       df
          jac = -- + c ------
                dx     d xdot

     The modified Jacobian function must have the form


          JAC = j (X, XDOT, T, C)


     The optional second argument names a function that defines the
     constraint functions whose roots are desired during the
     integration.  This function must have the form

          G_OUT = g (X, T)

     and return a vector of the constraint function values.  If the
     value of any of the constraint functions changes sign, DASRT will
     attempt to stop the integration at the point of the sign change.

     If the name of the constraint function is omitted, 'dasrt' solves
     the same problem as 'daspk' or 'dassl'.

     Note that because of numerical errors in the constraint functions
     due to round-off and integration error, DASRT may return false
     roots, or return the same root at two or more nearly equal values
     of T.  If such false roots are suspected, the user should consider
     smaller error tolerances or higher precision in the evaluation of
     the constraint functions.

     If a root of some constraint function defines the end of the
     problem, the input to DASRT should nevertheless allow integration
     to a point slightly past that root, so that DASRT can locate the
     root by interpolation.

     The third and fourth arguments to 'dasrt' specify the initial
     condition of the states and their derivatives, and the fourth
     argument specifies a vector of output times at which the solution
     is desired, including the time corresponding to the initial
     condition.

     The set of initial states and derivatives are not strictly required
     to be consistent.  In practice, however, DASSL is not very good at
     determining a consistent set for you, so it is best if you ensure
     that the initial values result in the function evaluating to zero.

     The sixth argument is optional, and may be used to specify a set of
     times that the DAE solver should not integrate past.  It is useful
     for avoiding difficulties with singularities and points where there
     is a discontinuity in the derivative.

     After a successful computation, the value of ISTATE will be greater
     than zero (consistent with the Fortran version of DASSL).

     If the computation is not successful, the value of ISTATE will be
     less than zero and MSG will contain additional information.

     You can use the function 'dasrt_options' to set optional parameters
     for 'dasrt'.

     See also: dasrt_options, daspk, dasrt, lsode.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
X_0, XDOT_0, T)  Solve the set of differential-algebraic equations 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
dassl_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2560
 -- Built-in Function: dassl_options ()
 -- Built-in Function: val = dassl_options (OPT)
 -- Built-in Function: dassl_options (OPT, VAL)
     Query or set options for the function 'dassl'.  When called with no
     arguments, the names of all available options and their current
     values are displayed.  Given one argument, return the value of the
     corresponding option.  When called with two arguments,
     'dassl_options' set the option OPT to value VAL.

     Options include

     '"absolute tolerance"'
          Absolute tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the relative tolerance must also be a vector of the same
          length.

     '"relative tolerance"'
          Relative tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the absolute tolerance must also be a vector of the same
          length.

          The local error test applied at each integration step is

                 abs (local error in x(i))
                      <= rtol(i) * abs (Y(i)) + atol(i)

     '"compute consistent initial condition"'
          If nonzero, 'dassl' will attempt to compute a consistent set
          of initial conditions.  This is generally not reliable, so it
          is best to provide a consistent set and leave this option set
          to zero.

     '"enforce nonnegativity constraints"'
          If you know that the solutions to your equations will always
          be non-negative, it may help to set this parameter to a
          nonzero value.  However, it is probably best to try leaving
          this option set to zero first, and only setting it to a
          nonzero value if that doesn't work very well.

     '"initial step size"'
          Differential-algebraic problems may occasionally suffer from
          severe scaling difficulties on the first step.  If you know a
          great deal about the scaling of your problem, you can help to
          alleviate this problem by specifying an initial stepsize.

     '"maximum order"'
          Restrict the maximum order of the solution method.  This
          option must be between 1 and 5, inclusive.

     '"maximum step size"'
          Setting the maximum stepsize will avoid passing over very
          large regions (default is not specified).

     '"step limit"'
          Maximum number of integration steps to attempt on a single
          call to the underlying Fortran code.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Query or set options for the function 'dassl'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
dassl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2608
 -- Built-in Function: [X, XDOT, ISTATE, MSG] = dassl (FCN, X_0, XDOT_0,
          T, T_CRIT)
     Solve the set of differential-algebraic equations

          0 = f (x, xdot, t)

     with

          x(t_0) = x_0, xdot(t_0) = xdot_0

     The solution is returned in the matrices X and XDOT, with each row
     in the result matrices corresponding to one of the elements in the
     vector T.  The first element of T should be t_0 and correspond to
     the initial state of the system X_0 and its derivative XDOT_0, so
     that the first row of the output X is X_0 and the first row of the
     output XDOT is XDOT_0.

     The first argument, FCN, is a string, inline, or function handle
     that names the function f to call to compute the vector of
     residuals for the set of equations.  It must have the form

          RES = f (X, XDOT, T)

     in which X, XDOT, and RES are vectors, and T is a scalar.

     If FCN is a two-element string array or a two-element cell array of
     strings, inline functions, or function handles, the first element
     names the function f described above, and the second element names
     a function to compute the modified Jacobian

                df       df
          jac = -- + c ------
                dx     d xdot

     The modified Jacobian function must have the form


          JAC = j (X, XDOT, T, C)


     The second and third arguments to 'dassl' specify the initial
     condition of the states and their derivatives, and the fourth
     argument specifies a vector of output times at which the solution
     is desired, including the time corresponding to the initial
     condition.

     The set of initial states and derivatives are not strictly required
     to be consistent.  In practice, however, DASSL is not very good at
     determining a consistent set for you, so it is best if you ensure
     that the initial values result in the function evaluating to zero.

     The fifth argument is optional, and may be used to specify a set of
     times that the DAE solver should not integrate past.  It is useful
     for avoiding difficulties with singularities and points where there
     is a discontinuity in the derivative.

     After a successful computation, the value of ISTATE will be greater
     than zero (consistent with the Fortran version of DASSL).

     If the computation is not successful, the value of ISTATE will be
     less than zero and MSG will contain additional information.

     You can use the function 'dassl_options' to set optional parameters
     for 'dassl'.

     See also: daspk, dasrt, lsode.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
T, T_CRIT)  Solve the set of differential-algebraic equations 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
all


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 535
 -- Built-in Function: all (X)
 -- Built-in Function: all (X, DIM)
     For a vector argument, return true (logical 1) if all elements of
     the vector are non-zero.

     For a matrix argument, return a row vector of logical ones and
     zeros with each element indicating whether all of the elements of
     the corresponding column of the matrix are non-zero.  For example:

          all ([2, 3; 1, 0]))
              => [ 1, 0 ]

     If the optional argument DIM is supplied, work along dimension DIM.

     See also: any.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
For a vector argument, return true (logical 1) if all elements of  the vector are non-zero.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
any


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 605
 -- Built-in Function: any (X)
 -- Built-in Function: any (X, DIM)
     For a vector argument, return true (logical 1) if any element of
     the vector is non-zero.

     For a matrix argument, return a row vector of logical ones and
     zeros with each element indicating whether any of the elements of
     the corresponding column of the matrix are non-zero.  For example:

          any (eye (2, 4))
           => [ 1, 1, 0, 0 ]

     If the optional argument DIM is supplied, work along dimension DIM.
     For example:

          any (eye (2, 4), 2)
           => [ 1; 1 ]

     See also: all.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
For a vector argument, return true (logical 1) if any element of  the vector is non-zero.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
atan2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 214
 -- Mapping Function: atan2 (Y, X)
     Compute atan (Y / X) for corresponding elements of Y and X.  Signal
     an error if Y and X do not match in size and orientation.

     See also: tan, tand, tanh, atanh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Compute atan (Y / X) for corresponding elements of Y and X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
hypot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 517
 -- Built-in Function: hypot (X, Y)
 -- Built-in Function: hypot (X, Y, Z, ...)
     Compute the element-by-element square root of the sum of the
     squares of X and Y.  This is equivalent to 'sqrt (X.^2 + Y.^2)',
     but calculated in a manner that avoids overflows for large values
     of X or Y.  'hypot' can also be called with more than 2 arguments;
     in this case, the arguments are accumulated from left to right:

          hypot (hypot (X, Y), Z)
          hypot (hypot (hypot (X, Y), Z), W), etc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 81
Compute the element-by-element square root of the sum of the  squares of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
log2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 339
 -- Mapping Function: log2 (X)
 -- Mapping Function: [F, E] = log2 (X)
     Compute the base-2 logarithm of each element of X.

     If called with two output arguments, split X into binary mantissa
     and exponent so that '1/2 <= abs(f) < 1' and E is an integer.  If
     'x = 0', 'f = e = 0'.

     See also: pow2, log, log10, exp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute the base-2 logarithm of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
rem


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 340
 -- Mapping Function: rem (X, Y)
 -- Mapping Function: fmod (X, Y)
     Return the remainder of the division 'X / Y', computed using the
     expression

          x - y .* fix (x ./ y)

     An error message is printed if the dimensions of the arguments do
     not agree, or if either of the arguments is complex.

     See also: mod.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Return the remainder of the division 'X / Y', computed using the  expression 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
mod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 512
 -- Mapping Function: mod (X, Y)
     Compute the modulo of X and Y.  Conceptually this is given by

          x - y .* floor (x ./ y)

     and is written such that the correct modulus is returned for
     integer types.  This function handles negative values correctly.
     That is, 'mod (-1, 3)' is 2, not -1, as 'rem (-1, 3)' returns.
     'mod (X, 0)' returns X.

     An error results if the dimensions of the arguments do not agree,
     or if either of the arguments is complex.

     See also: rem.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Compute the modulo of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cumprod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 240
 -- Built-in Function: cumprod (X)
 -- Built-in Function: cumprod (X, DIM)
     Cumulative product of elements along dimension DIM.  If DIM is
     omitted, it defaults to the first non-singleton dimension.

     See also: prod, cumsum.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Cumulative product of elements along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
cumsum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 471
 -- Built-in Function: cumsum (X)
 -- Built-in Function: cumsum (X, DIM)
 -- Built-in Function: cumsum (..., "native")
 -- Built-in Function: cumsum (..., "double")
 -- Built-in Function: cumsum (..., "extra")
     Cumulative sum of elements along dimension DIM.  If DIM is omitted,
     it defaults to the first non-singleton dimension.

     See 'sum' for an explanation of the optional parameters "native",
     "double", and "extra".

     See also: sum, cumprod.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Cumulative sum of elements along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
diag


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 930
 -- Built-in Function: M = diag (V)
 -- Built-in Function: M = diag (V, K)
 -- Built-in Function: M = diag (V, M, N)
 -- Built-in Function: V = diag (M)
 -- Built-in Function: V = diag (M, K)
     Return a diagonal matrix with vector V on diagonal K.  The second
     argument is optional.  If it is positive, the vector is placed on
     the K-th super-diagonal.  If it is negative, it is placed on the
     -K-th sub-diagonal.  The default value of K is 0, and the vector is
     placed on the main diagonal.  For example:

          diag ([1, 2, 3], 1)
             =>  0  1  0  0
                 0  0  2  0
                 0  0  0  3
                 0  0  0  0

     The 3-input form returns a diagonal matrix with vector V on the
     main diagonal and the resulting matrix being of size M rows x N
     columns.

     Given a matrix argument, instead of a vector, 'diag' extracts the
     K-th diagonal of the matrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return a diagonal matrix with vector V on diagonal K.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
prod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 223
 -- Built-in Function: prod (X)
 -- Built-in Function: prod (X, DIM)
     Product of elements along dimension DIM.  If DIM is omitted, it
     defaults to the first non-singleton dimension.

     See also: cumprod, sum.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Product of elements along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
horzcat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 365
 -- Built-in Function: horzcat (ARRAY1, ARRAY2, ..., ARRAYN)
     Return the horizontal concatenation of N-D array objects, ARRAY1,
     ARRAY2, ..., ARRAYN along dimension 2.

     Arrays may also be concatenated horizontally using the syntax for
     creating new matrices.  For example:

          HCAT = [ ARRAY1, ARRAY2, ... ]

     See also: cat, vertcat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Return the horizontal concatenation of N-D array objects, ARRAY1,  ARRAY2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
vertcat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 361
 -- Built-in Function: vertcat (ARRAY1, ARRAY2, ..., ARRAYN)
     Return the vertical concatenation of N-D array objects, ARRAY1,
     ARRAY2, ..., ARRAYN along dimension 1.

     Arrays may also be concatenated vertically using the syntax for
     creating new matrices.  For example:

          VCAT = [ ARRAY1; ARRAY2; ... ]

     See also: cat, horzcat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Return the vertical concatenation of N-D array objects, ARRAY1,  ARRAY2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
cat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 800
 -- Built-in Function: cat (DIM, ARRAY1, ARRAY2, ..., ARRAYN)
     Return the concatenation of N-D array objects, ARRAY1, ARRAY2, ...,
     ARRAYN along dimension DIM.

          A = ones (2, 2);
          B = zeros (2, 2);
          cat (2, A, B)
            => 1 1 0 0
               1 1 0 0

     Alternatively, we can concatenate A and B along the second
     dimension in the following way:

          [A, B]

     DIM can be larger than the dimensions of the N-D array objects and
     the result will thus have DIM dimensions as the following example
     shows:

          cat (4, ones (2, 2), zeros (2, 2))
            => ans(:,:,1,1) =

                 1 1
                 1 1

               ans(:,:,1,2) =

                 0 0
                 0 0

     See also: horzcat, vertcat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return the concatenation of N-D array objects, ARRAY1, ARRAY2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
permute


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 270
 -- Built-in Function: permute (A, PERM)
     Return the generalized transpose for an N-D array object A.  The
     permutation vector PERM must contain the elements '1:ndims (A)' (in
     any order, but each element must appear only once).

     See also: ipermute.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Return the generalized transpose for an N-D array object A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ipermute


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 213
 -- Built-in Function: ipermute (A, IPERM)
     The inverse of the 'permute' function.  The expression

          ipermute (permute (A, perm), perm)

     returns the original array A.

     See also: permute.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
The inverse of the 'permute' function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
length


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 365
 -- Built-in Function: length (A)
     Return the length of the object A.

     The length is 0 for empty objects, 1 for scalars, and the number of
     elements for vectors.  For matrix objects, the length is the number
     of rows or columns, whichever is greater (this odd definition is
     used for compatibility with MATLAB).

     See also: numel, size.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return the length of the object A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ndims


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 284
 -- Built-in Function: ndims (A)
     Return the number of dimensions of A.  For any array, the result
     will always be larger than or equal to 2.  Trailing singleton
     dimensions are not counted.

          ndims (ones (4, 1, 2, 1))
              => 3

     See also: size.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Return the number of dimensions of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
numel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 665
 -- Built-in Function: numel (A)
 -- Built-in Function: numel (A, IDX1, IDX2, ...)
     Return the number of elements in the object A.  Optionally, if
     indices IDX1, IDX2, ... are supplied, return the number of elements
     that would result from the indexing

          A(IDX1, IDX2, ...)

     Note that the indices do not have to be numerical.  For example,

          A = 1;
          B = ones (2, 3);
          numel (A, B)

     will return 6, as this is the number of ways to index with B.

     This method is also called when an object appears as lvalue with
     cs-list indexing, i.e., 'object{...}' or 'object(...).field'.

     See also: size.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Return the number of elements in the object A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
size


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 817
 -- Built-in Function: size (A)
 -- Built-in Function: size (A, DIM)
     Return the number of rows and columns of A.

     With one input argument and one output argument, the result is
     returned in a row vector.  If there are multiple output arguments,
     the number of rows is assigned to the first, and the number of
     columns to the second, etc.  For example:

          size ([1, 2; 3, 4; 5, 6])
             => [ 3, 2 ]

          [nr, nc] = size ([1, 2; 3, 4; 5, 6])
              => nr = 3
              => nc = 2

     If given a second argument, 'size' will return the size of the
     corresponding dimension.  For example,

          size ([1, 2; 3, 4; 5, 6], 2)
              => 2

     returns the number of columns in the given matrix.

     See also: numel, ndims, length, rows, columns.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Return the number of rows and columns of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
size_equal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 261
 -- Built-in Function: size_equal (A, B, ...)
     Return true if the dimensions of all arguments agree.  Trailing
     singleton dimensions are ignored.  Called with a single or no
     argument, size_equal returns true.

     See also: size, numel, ndims.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return true if the dimensions of all arguments agree.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
nnz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
 -- Built-in Function: N = nnz (A)
     Return the number of non-zero elements in A.

     See also: nzmax, nonzeros, find.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return the number of non-zero elements in A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
nzmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 382
 -- Built-in Function: N = nzmax (SM)
     Return the amount of storage allocated to the sparse matrix SM.

     Note that Octave tends to crop unused memory at the first
     opportunity for sparse objects.  Thus, in general the value of
     'nzmax' will be the the same as 'nnz' except for some cases of
     user-created sparse objects.

     See also: nnz, spalloc, sparse.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return the amount of storage allocated to the sparse matrix SM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
rows


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
 -- Built-in Function: rows (A)
     Return the number of rows of A.

     See also: columns, size, length, numel, isscalar, isvector,
     ismatrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Return the number of rows of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
columns


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 151
 -- Built-in Function: columns (A)
     Return the number of columns of A.

     See also: rows, size, length, numel, isscalar, isvector, ismatrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return the number of columns of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
sum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1011
 -- Built-in Function: sum (X)
 -- Built-in Function: sum (X, DIM)
 -- Built-in Function: sum (..., "native")
 -- Built-in Function: sum (..., "double")
 -- Built-in Function: sum (..., "extra")
     Sum of elements along dimension DIM.  If DIM is omitted, it
     defaults to the first non-singleton dimension.

     If the optional argument "native" is given, then the sum is
     performed in the same type as the original argument, rather than in
     the default double type.  For example:

          sum ([true, true])
             => 2
          sum ([true, true], "native")
             => true

     On the contrary, if "double" is given, the sum is performed in
     double precision even for single precision inputs.

     For double precision inputs, "extra" indicates that a more accurate
     algorithm than straightforward summation is to be used.  For single
     precision inputs, "extra" is the same as "double".  Otherwise,
     "extra" has no effect.

     See also: cumsum, sumsq, prod.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Sum of elements along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
sumsq


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 395
 -- Built-in Function: sumsq (X)
 -- Built-in Function: sumsq (X, DIM)
     Sum of squares of elements along dimension DIM.  If DIM is omitted,
     it defaults to the first non-singleton dimension.

     This function is conceptually equivalent to computing

          sum (x .* conj (x), dim)

     but it uses less memory and avoids calling 'conj' if X is real.

     See also: sum, prod.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Sum of squares of elements along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
islogical


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 177
 -- Built-in Function: islogical (X)
 -- Built-in Function: isbool (X)
     Return true if X is a logical object.

     See also: isfloat, isinteger, ischar, isnumeric, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Return true if X is a logical object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
isinteger


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 297
 -- Built-in Function: isinteger (X)
     Return true if X is an integer object (int8, uint8, int16, etc.).
     Note that 'isinteger (14)' is false because numeric constants in
     Octave are double precision floating point values.

     See also: isfloat, ischar, islogical, isnumeric, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return true if X is an integer object (int8, uint8, int16, etc.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
iscomplex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 166
 -- Built-in Function: iscomplex (X)
     Return true if X is a complex-valued numeric object.

     See also: isreal, isnumeric, islogical, ischar, isfloat, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return true if X is a complex-valued numeric object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isfloat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 226
 -- Built-in Function: isfloat (X)
     Return true if X is a floating-point numeric object.  Objects of
     class double or single are floating-point objects.

     See also: isinteger, ischar, islogical, isnumeric, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return true if X is a floating-point numeric object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
complex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 475
 -- Built-in Function: complex (X)
 -- Built-in Function: complex (RE, IM)
     Return a complex result from real arguments.  With 1 real argument
     X, return the complex result 'X + 0i'.  With 2 real arguments,
     return the complex result 'RE + IM'.  'complex' can often be more
     convenient than expressions such as 'a + i*b'.  For example:

          complex ([1, 2], [3, 4])
            => [ 1 + 3i   2 + 4i ]

     See also: real, imag, iscomplex, abs, arg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return a complex result from real arguments.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isreal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 225
 -- Built-in Function: isreal (X)
     Return true if X is a non-complex matrix or scalar.  For
     compatibility with MATLAB, this includes logical and character
     matrices.

     See also: iscomplex, isnumeric, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return true if X is a non-complex matrix or scalar.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isempty


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 176
 -- Built-in Function: isempty (A)
     Return true if A is an empty matrix (any one of its dimensions is
     zero).  Otherwise, return false.

     See also: isnull, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Return true if A is an empty matrix (any one of its dimensions is  zero).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
isnumeric


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 301
 -- Built-in Function: isnumeric (X)
     Return true if X is a numeric object, i.e., an integer, real, or
     complex array.  Logical and character arrays are not considered to
     be numeric.

     See also: isinteger, isfloat, isreal, iscomplex, islogical, ischar,
     iscell, isstruct, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Return true if X is a numeric object, i.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ismatrix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 358
 -- Built-in Function: ismatrix (A)
     Return true if A is a numeric, logical, or character matrix.
     Scalars (1x1 matrices) and vectors (1xN or Nx1 matrices) are
     subsets of the more general N-dimensional matrix and 'ismatrix'
     will return true for these objects as well.

     See also: isscalar, isvector, iscell, isstruct, issparse, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Return true if A is a numeric, logical, or character matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
ones


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 819
 -- Built-in Function: ones (N)
 -- Built-in Function: ones (M, N)
 -- Built-in Function: ones (M, N, K, ...)
 -- Built-in Function: ones ([M N ...])
 -- Built-in Function: ones (..., CLASS)
     Return a matrix or N-dimensional array whose elements are all 1.
     If invoked with a single scalar integer argument N, return a square
     NxN matrix.  If invoked with two or more scalar integer arguments,
     or a vector of integer values, return an array with the given
     dimensions.

     If you need to create a matrix whose values are all the same, you
     should use an expression like

          val_matrix = val * ones (m, n)

     The optional argument CLASS specifies the class of the return array
     and defaults to double.  For example:

          val = ones (m,n, "uint8")

     See also: zeros.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return a matrix or N-dimensional array whose elements are all 1.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
zeros


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 673
 -- Built-in Function: zeros (N)
 -- Built-in Function: zeros (M, N)
 -- Built-in Function: zeros (M, N, K, ...)
 -- Built-in Function: zeros ([M N ...])
 -- Built-in Function: zeros (..., CLASS)
     Return a matrix or N-dimensional array whose elements are all 0.
     If invoked with a single scalar integer argument, return a square
     NxN matrix.  If invoked with two or more scalar integer arguments,
     or a vector of integer values, return an array with the given
     dimensions.

     The optional argument CLASS specifies the class of the return array
     and defaults to double.  For example:

          val = zeros (m,n, "uint8")

     See also: ones.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return a matrix or N-dimensional array whose elements are all 0.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
Inf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1074
 -- Built-in Function: Inf
 -- Built-in Function: Inf (N)
 -- Built-in Function: Inf (N, M)
 -- Built-in Function: Inf (N, M, K, ...)
 -- Built-in Function: Inf (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all equal to the IEEE representation for positive infinity.

     Infinity is produced when results are too large to be represented
     using the the IEEE floating point format for numbers.  Two common
     examples which produce infinity are division by zero and overflow.

          [ 1/0 e^800 ]
          => Inf   Inf

     When called with no arguments, return a scalar with the value
     'Inf'.  When called with a single argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The optional argument CLASS specifies the
     return type and may be either "double" or "single".

     See also: isinf, NaN.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
Return a scalar, matrix or N-dimensional array whose elements are  all equal to the IEEE representation for positive infinity.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
NaN


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1276
 -- Built-in Function: NaN
 -- Built-in Function: NaN (N)
 -- Built-in Function: NaN (N, M)
 -- Built-in Function: NaN (N, M, K, ...)
 -- Built-in Function: NaN (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the IEEE symbol NaN (Not a Number).  NaN is the result
     of operations which do not produce a well defined numerical result.
     Common operations which produce a NaN are arithmetic with infinity
     (Inf - Inf), zero divided by zero (0/0), and any operation
     involving another NaN value (5 + NaN).

     Note that NaN always compares not equal to NaN (NaN != NaN). This
     behavior is specified by the IEEE standard for floating point
     arithmetic.  To find NaN values, use the 'isnan' function.

     When called with no arguments, return a scalar with the value
     'NaN'.  When called with a single argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The optional argument CLASS specifies the
     return type and may be either "double" or "single".

     See also: isnan, Inf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
Return a scalar, matrix, or N-dimensional array whose elements are  all equal to the IEEE symbol NaN (Not a Number).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
e


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 848
 -- Built-in Function: e
 -- Built-in Function: e (N)
 -- Built-in Function: e (N, M)
 -- Built-in Function: e (N, M, K, ...)
 -- Built-in Function: e (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the base of natural logarithms.  The constant 'e'
     satisfies the equation 'log' (e) = 1.

     When called with no arguments, return a scalar with the value e.
     When called with a single argument, return a square matrix with the
     dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either "double" or "single".

     See also: log, exp, pi, I.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Return a scalar, matrix, or N-dimensional array whose elements are  all equal to the base of natural logarithms.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
eps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1138
 -- Built-in Function: eps
 -- Built-in Function: eps (X)
 -- Built-in Function: eps (N, M)
 -- Built-in Function: eps (N, M, K, ...)
 -- Built-in Function: eps (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all eps, the machine precision.  More precisely, 'eps' is the
     relative spacing between any two adjacent numbers in the machine's
     floating point system.  This number is obviously system dependent.
     On machines that support IEEE floating point arithmetic, 'eps' is
     approximately 2.2204e-16 for double precision and 1.1921e-07 for
     single precision.

     When called with no arguments, return a scalar with the value 'eps
     (1.0)'.  Given a single argument X, return the distance between X
     and the next largest value.  When called with more than one
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either "double" or "single".

     See also: realmax, realmin, intmax, bitmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Return a scalar, matrix or N-dimensional array whose elements are  all eps, the machine precision.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
pi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 872
 -- Built-in Function: pi
 -- Built-in Function: pi (N)
 -- Built-in Function: pi (N, M)
 -- Built-in Function: pi (N, M, K, ...)
 -- Built-in Function: pi (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the ratio of the circumference of a circle to its
     diameter.  Internally, 'pi' is computed as '4.0 * atan (1.0)'.

     When called with no arguments, return a scalar with the value of
     pi.  When called with a single argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The optional argument CLASS specifies the
     return type and may be either "double" or "single".

     See also: e, I.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 141
Return a scalar, matrix, or N-dimensional array whose elements are  all equal to the ratio of the circumference of a circle to its  diameter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
realmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1088
 -- Built-in Function: realmax
 -- Built-in Function: realmax (N)
 -- Built-in Function: realmax (N, M)
 -- Built-in Function: realmax (N, M, K, ...)
 -- Built-in Function: realmax (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all equal to the largest floating point number that is
     representable.  The actual value is system dependent.  On machines
     that support IEEE floating point arithmetic, 'realmax' is
     approximately 1.7977e+308 for double precision and 3.4028e+38 for
     single precision.

     When called with no arguments, return a scalar with the value
     'realmax ("double")'.  When called with a single argument, return a
     square matrix with the dimension specified.  When called with more
     than one scalar argument the first two arguments are taken as the
     number of rows and columns and any further arguments specify
     additional matrix dimensions.  The optional argument CLASS
     specifies the return type and may be either "double" or "single".

     See also: realmin, intmax, bitmax, eps.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 137
Return a scalar, matrix or N-dimensional array whose elements are  all equal to the largest floating point number that is  representable.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
realmin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1092
 -- Built-in Function: realmin
 -- Built-in Function: realmin (N)
 -- Built-in Function: realmin (N, M)
 -- Built-in Function: realmin (N, M, K, ...)
 -- Built-in Function: realmin (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all equal to the smallest normalized floating point number that is
     representable.  The actual value is system dependent.  On machines
     that support IEEE floating point arithmetic, 'realmin' is
     approximately 2.2251e-308 for double precision and 1.1755e-38 for
     single precision.

     When called with no arguments, return a scalar with the value
     'realmin ("double")'.  When called with a single argument, return a
     square matrix with the dimension specified.  When called with more
     than one scalar argument the first two arguments are taken as the
     number of rows and columns and any further arguments specify
     additional matrix dimensions.  The optional argument CLASS
     specifies the return type and may be either "double" or "single".

     See also: realmax, intmin, eps.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 149
Return a scalar, matrix or N-dimensional array whose elements are  all equal to the smallest normalized floating point number that is  representable.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
I


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 959
 -- Built-in Function: I
 -- Built-in Function: I (N)
 -- Built-in Function: I (N, M)
 -- Built-in Function: I (N, M, K, ...)
 -- Built-in Function: I (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the pure imaginary unit, defined as 'sqrt (-1)'.

     I, and its equivalents i, j, and J, are functions so any of the
     names may be reused for other purposes (such as i for a counter
     variable).

     When called with no arguments, return a scalar with the value i.
     When called with a single argument, return a square matrix with the
     dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either "double" or "single".

     See also: e, pi, log, exp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
Return a scalar, matrix, or N-dimensional array whose elements are  all equal to the pure imaginary unit, defined as 'sqrt (-1)'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
NA


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 919
 -- Built-in Function: NA
 -- Built-in Function: NA (N)
 -- Built-in Function: NA (N, M)
 -- Built-in Function: NA (N, M, K, ...)
 -- Built-in Function: NA (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the special constant used to designate missing values.

     Note that NA always compares not equal to NA (NA != NA). To find NA
     values, use the 'isna' function.

     When called with no arguments, return a scalar with the value 'NA'.
     When called with a single argument, return a square matrix with the
     dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either "double" or "single".

     See also: isna.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
Return a scalar, matrix, or N-dimensional array whose elements are  all equal to the special constant used to designate missing values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
false


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 458
 -- Built-in Function: false (X)
 -- Built-in Function: false (N, M)
 -- Built-in Function: false (N, M, K, ...)
     Return a matrix or N-dimensional array whose elements are all
     logical 0.  If invoked with a single scalar integer argument,
     return a square matrix of the specified size.  If invoked with two
     or more scalar integer arguments, or a vector of integer values,
     return an array with given dimensions.

     See also: true.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Return a matrix or N-dimensional array whose elements are all  logical 0.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
true


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 456
 -- Built-in Function: true (X)
 -- Built-in Function: true (N, M)
 -- Built-in Function: true (N, M, K, ...)
     Return a matrix or N-dimensional array whose elements are all
     logical 1.  If invoked with a single scalar integer argument,
     return a square matrix of the specified size.  If invoked with two
     or more scalar integer arguments, or a vector of integer values,
     return an array with given dimensions.

     See also: false.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Return a matrix or N-dimensional array whose elements are all  logical 1.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
eye


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1145
 -- Built-in Function: eye (N)
 -- Built-in Function: eye (M, N)
 -- Built-in Function: eye ([M N])
 -- Built-in Function: eye (..., CLASS)
     Return an identity matrix.  If invoked with a single scalar
     argument N, return a square NxN identity matrix.  If supplied two
     scalar arguments (M, N), 'eye' takes them to be the number of rows
     and columns.  If given a vector with two elements, 'eye' uses the
     values of the elements as the number of rows and columns,
     respectively.  For example:

          eye (3)
           =>  1  0  0
               0  1  0
               0  0  1

     The following expressions all produce the same result:

          eye (2)
          ==
          eye (2, 2)
          ==
          eye (size ([1, 2; 3, 4])

     The optional argument CLASS, allows 'eye' to return an array of the
     specified type, like

          val = zeros (n,m, "uint8")

     Calling 'eye' with no arguments is equivalent to calling it with an
     argument of 1.  Any negative dimensions are treated as zero.  These
     odd definitions are for compatibility with MATLAB.

     See also: speye, ones, zeros.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Return an identity matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
linspace


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 780
 -- Built-in Function: linspace (BASE, LIMIT)
 -- Built-in Function: linspace (BASE, LIMIT, N)
     Return a row vector with N linearly spaced elements between BASE
     and LIMIT.  If the number of elements is greater than one, then the
     endpoints BASE and LIMIT are always included in the range.  If BASE
     is greater than LIMIT, the elements are stored in decreasing order.
     If the number of points is not specified, a value of 100 is used.

     The 'linspace' function always returns a row vector if both BASE
     and LIMIT are scalars.  If one, or both, of them are column
     vectors, 'linspace' returns a matrix.

     For compatibility with MATLAB, return the second argument (LIMIT)
     if fewer than two values are requested.

     See also: logspace.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Return a row vector with N linearly spaced elements between BASE  and LIMIT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
resize


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1230
 -- Built-in Function: resize (X, M)
 -- Built-in Function: resize (X, M, N, ...)
 -- Built-in Function: resize (X, [M N ...])
     Resize X cutting off elements as necessary.

     In the result, element with certain indices is equal to the
     corresponding element of X if the indices are within the bounds of
     X; otherwise, the element is set to zero.

     In other words, the statement

          y = resize (x, dv)

     is equivalent to the following code:

          y = zeros (dv, class (x));
          sz = min (dv, size (x));
          for i = 1:length (sz)
            idx{i} = 1:sz(i);
          endfor
          y(idx{:}) = x(idx{:});

     but is performed more efficiently.

     If only M is supplied, and it is a scalar, the dimension of the
     result is M-by-M.  If M, N, ... are all scalars, then the
     dimensions of the result are M-by-N-by-....  If given a vector as
     input, then the dimensions of the result are given by the elements
     of that vector.

     An object can be resized to more dimensions than it has; in such
     case the missing dimensions are assumed to be 1.  Resizing an
     object to fewer dimensions is not possible.

     See also: reshape, postpad, prepad, cat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Resize X cutting off elements as necessary.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
reshape


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1015
 -- Built-in Function: reshape (A, M, N, ...)
 -- Built-in Function: reshape (A, [M N ...])
 -- Built-in Function: reshape (A, ..., [], ...)
 -- Built-in Function: reshape (A, SIZE)
     Return a matrix with the specified dimensions (M, N, ...) whose
     elements are taken from the matrix A.  The elements of the matrix
     are accessed in column-major order (like Fortran arrays are
     stored).

     The following code demonstrates reshaping a 1x4 row vector into a
     2x2 square matrix.

          reshape ([1, 2, 3, 4], 2, 2)
                =>  1  3
                    2  4

     Note that the total number of elements in the original matrix
     ('prod (size (A))') must match the total number of elements in the
     new matrix ('prod ([M N ...])').

     A single dimension of the return matrix may be left unspecified and
     Octave will determine its size automatically.  An empty matrix ([])
     is used to flag the unspecified dimension.

     See also: resize, vec, postpad, cat, squeeze.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Return a matrix with the specified dimensions (M, N, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
vec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 418
 -- Built-in Function: V = vec (X)
 -- Built-in Function: V = vec (X, DIM)
     Return the vector obtained by stacking the columns of the matrix X
     one above the other.  Without DIM this is equivalent to 'X(:)'.  If
     DIM is supplied, the dimensions of V are set to DIM with all
     elements along the last dimension.  This is equivalent to 'shiftdim
     (X(:), 1-DIM)'.

     See also: vech, resize, cat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
Return the vector obtained by stacking the columns of the matrix X  one above the other.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
squeeze


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 259
 -- Built-in Function: squeeze (X)
     Remove singleton dimensions from X and return the result.  Note
     that for compatibility with MATLAB, all objects have a minimum of
     two dimensions and row vectors are left unchanged.

     See also: reshape.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Remove singleton dimensions from X and return the result.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
full


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 171
 -- Built-in Function: FM = full (SM)
     Return a full storage matrix from a sparse, diagonal, permutation
     matrix, or a range.

     See also: sparse, issparse.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Return a full storage matrix from a sparse, diagonal, permutation  matrix, or a range.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
norm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1357
 -- Built-in Function: norm (A)
 -- Built-in Function: norm (A, P)
 -- Built-in Function: norm (A, P, OPT)
     Compute the p-norm of the matrix A.  If the second argument is
     missing, 'p = 2' is assumed.

     If A is a matrix (or sparse matrix):

     P = '1'
          1-norm, the largest column sum of the absolute values of A.

     P = '2'
          Largest singular value of A.

     P = 'Inf' or "inf"
          Infinity norm, the largest row sum of the absolute values of
          A.

     P = "fro"
          Frobenius norm of A, 'sqrt (sum (diag (A' * A)))'.

     other P, 'P > 1'
          maximum 'norm (A*x, p)' such that 'norm (x, p) == 1'

     If A is a vector or a scalar:

     P = 'Inf' or "inf"
          'max (abs (A))'.

     P = '-Inf'
          'min (abs (A))'.

     P = "fro"
          Frobenius norm of A, 'sqrt (sumsq (abs (A)))'.

     P = 0
          Hamming norm - the number of nonzero elements.

     other P, 'P > 1'
          p-norm of A, '(sum (abs (A) .^ P)) ^ (1/P)'.

     other P 'P < 1'
          the p-pseudonorm defined as above.

     If OPT is the value "rows", treat each row as a vector and compute
     its norm.  The result is returned as a column vector.  Similarly,
     if OPT is "columns" or "cols" then compute the norms of each column
     and return a row vector.

     See also: cond, svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Compute the p-norm of the matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
not


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 137
 -- Built-in Function: not (X)
     Return the logical NOT of X.  This function is equivalent to '! x'.

     See also: and, or, xor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Return the logical NOT of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
uplus


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
 -- Built-in Function: uplus (X)
     This function and + x are equivalent.

     See also: uminus, plus, minus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
This function and + x are equivalent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
uminus


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
 -- Built-in Function: uminus (X)
     This function and - x are equivalent.

     See also: uplus, minus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
This function and - x are equivalent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
transpose


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 140
 -- Built-in Function: transpose (X)
     Return the transpose of X.  This function and x.'  are equivalent.

     See also: ctranspose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Return the transpose of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
ctranspose


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 161
 -- Built-in Function: ctranspose (X)
     Return the complex conjugate transpose of X.  This function and x'
     are equivalent.

     See also: transpose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return the complex conjugate transpose of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
plus


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 328
 -- Built-in Function: plus (X, Y)
 -- Built-in Function: plus (X1, X2, ...)
     This function and x + y are equivalent.  If more arguments are
     given, the summation is applied cumulatively from left to right:

          (...((x1 + x2) + x3) + ...)

     At least one argument is required.

     See also: minus, uplus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
This function and x + y are equivalent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
minus


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
 -- Built-in Function: minus (X, Y)
     This function and x - y are equivalent.

     See also: plus, uminus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
This function and x - y are equivalent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mtimes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 438
 -- Built-in Function: mtimes (X, Y)
 -- Built-in Function: mtimes (X1, X2, ...)
     Return the matrix multiplication product of inputs.  This function
     and x * y are equivalent.  If more arguments are given, the
     multiplication is applied cumulatively from left to right:

          (...((x1 * x2) * x3) * ...)

     At least one argument is required.

     See also: times, plus, minus, rdivide, mrdivide, mldivide, mpower.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return the matrix multiplication product of inputs.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
mrdivide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 186
 -- Built-in Function: mrdivide (X, Y)
     Return the matrix right division of X and Y.  This function and x / y
     are equivalent.

     See also: mldivide, rdivide, plus, minus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return the matrix right division of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mpower


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 197
 -- Built-in Function: mpower (X, Y)
     Return the matrix power operation of X raised to the Y power.  This
     function and x ^ y are equivalent.

     See also: power, mtimes, plus, minus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Return the matrix power operation of X raised to the Y power.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
mldivide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 181
 -- Built-in Function: mldivide (X, Y)
     Return the matrix left division of X and Y.  This function and x \ y
     are equivalent.

     See also: mrdivide, ldivide, rdivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Return the matrix left division of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
lt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
 -- Built-in Function: lt (X, Y)
     This function is equivalent to 'x < y'.

     See also: le, eq, ge, gt, ne.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
This function is equivalent to 'x < y'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
le


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 118
 -- Built-in Function: le (X, Y)
     This function is equivalent to 'x <= y'.

     See also: eq, ge, gt, ne, lt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
This function is equivalent to 'x <= y'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
eq


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 178
 -- Built-in Function: eq (X, Y)
     Return true if the two inputs are equal.  This function is
     equivalent to 'x == y'.

     See also: ne, isequal, le, ge, gt, ne, lt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Return true if the two inputs are equal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
ge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 118
 -- Built-in Function: ge (X, Y)
     This function is equivalent to 'x >= y'.

     See also: le, eq, gt, ne, lt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
This function is equivalent to 'x >= y'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
gt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
 -- Built-in Function: gt (X, Y)
     This function is equivalent to 'x > y'.

     See also: le, eq, ge, ne, lt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
This function is equivalent to 'x > y'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
ne


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 174
 -- Built-in Function: ne (X, Y)
     Return true if the two inputs are not equal.  This function is
     equivalent to 'x != y'.

     See also: eq, isequal, le, ge, lt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return true if the two inputs are not equal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
times


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 416
 -- Built-in Function: times (X, Y)
 -- Built-in Function: times (X1, X2, ...)
     Return the element-by-element multiplication product of inputs.
     This function and x .* y are equivalent.  If more arguments are
     given, the multiplication is applied cumulatively from left to
     right:

          (...((x1 .* x2) .* x3) .* ...)

     At least one argument is required.

     See also: mtimes, rdivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return the element-by-element multiplication product of inputs.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rdivide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 198
 -- Built-in Function: rdivide (X, Y)
     Return the element-by-element right division of X and Y.  This
     function and x ./ y are equivalent.

     See also: ldivide, mrdivide, times, plus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Return the element-by-element right division of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
power


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 414
 -- Built-in Function: power (X, Y)
     Return the element-by-element operation of X raised to the Y power.
     If several complex results are possible, returns the one with
     smallest non-negative argument (angle).  Use 'realpow', 'realsqrt',
     'cbrt', or 'nthroot' if a real result is preferred.

     This function and x .^ y are equivalent.

     See also: mpower, realpow, realsqrt, cbrt, nthroot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Return the element-by-element operation of X raised to the Y power.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ldivide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 197
 -- Built-in Function: ldivide (X, Y)
     Return the element-by-element left division of X and Y.  This
     function and x .\ y are equivalent.

     See also: rdivide, mldivide, times, plus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Return the element-by-element left division of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
and


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 369
 -- Built-in Function: and (X, Y)
 -- Built-in Function: and (X1, X2, ...)
     Return the logical AND of X and Y.  This function is equivalent to
     'x & y'.  If more arguments are given, the logical and is applied
     cumulatively from left to right:

          (...((x1 & x2) & x3) & ...)

     At least one argument is required.

     See also: or, not, xor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return the logical AND of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
or


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 366
 -- Built-in Function: or (X, Y)
 -- Built-in Function: or (X1, X2, ...)
     Return the logical OR of X and Y.  This function is equivalent to
     'x | y'.  If more arguments are given, the logical or is applied
     cumulatively from left to right:

          (...((x1 | x2) | x3) | ...)

     At least one argument is required.

     See also: and, not, xor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Return the logical OR of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
tic


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1198
 -- Built-in Function: tic ()
 -- Built-in Function: ID = tic ()
 -- Built-in Function: toc ()
 -- Built-in Function: toc (ID)
 -- Built-in Function: VAL = toc (...)
     Set or check a wall-clock timer.  Calling 'tic' without an output
     argument sets the internal timer state.  Subsequent calls to 'toc'
     return the number of seconds since the timer was set.  For example,

          tic ();
          # many computations later...
          elapsed_time = toc ();

     will set the variable 'elapsed_time' to the number of seconds since
     the most recent call to the function 'tic'.

     If called with one output argument, 'tic' returns a scalar of type
     'uint64' that may be later passed to 'toc'.

          id = tic; sleep (5); toc (id)
                => 5.0010

     Calling 'tic' and 'toc' this way allows nested timing calls.

     If you are more interested in the CPU time that your process used,
     you should use the 'cputime' function instead.  The 'tic' and 'toc'
     functions report the actual wall clock time that elapsed between
     the calls.  This may include time spent processing other jobs or
     doing nothing at all.

     See also: toc, cputime.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Set or check a wall-clock timer.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
toc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
 -- Built-in Function: toc ()
 -- Built-in Function: toc (ID)
 -- Built-in Function: VAL = toc (...)

     See also: tic, cputime.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
See also: tic, cputime.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cputime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 719
 -- Built-in Function: [TOTAL, USER, SYSTEM] = cputime ();
     Return the CPU time used by your Octave session.  The first output
     is the total time spent executing your process and is equal to the
     sum of second and third outputs, which are the number of CPU
     seconds spent executing in user mode and the number of CPU seconds
     spent executing in system mode, respectively.  If your system does
     not have a way to report CPU time usage, 'cputime' returns 0 for
     each of its output values.  Note that because Octave used some CPU
     time to start, it is reasonable to check to see if 'cputime' works
     by checking to see if the total CPU time used is nonzero.

     See also: tic, toc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the CPU time used by your Octave session.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sort


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1876
 -- Built-in Function: [S, I] = sort (X)
 -- Built-in Function: [S, I] = sort (X, DIM)
 -- Built-in Function: [S, I] = sort (X, MODE)
 -- Built-in Function: [S, I] = sort (X, DIM, MODE)
     Return a copy of X with the elements arranged in increasing order.
     For matrices, 'sort' orders the elements within columns

     For example:

          sort ([1, 2; 2, 3; 3, 1])
             =>  1  1
                 2  2
                 3  3

     If the optional argument DIM is given, then the matrix is sorted
     along the dimension defined by DIM.  The optional argument 'mode'
     defines the order in which the values will be sorted.  Valid values
     of 'mode' are "ascend" or "descend".

     The 'sort' function may also be used to produce a matrix containing
     the original row indices of the elements in the sorted matrix.  For
     example:

          [s, i] = sort ([1, 2; 2, 3; 3, 1])
            => s = 1  1
                   2  2
                   3  3
            => i = 1  3
                   2  1
                   3  2

     For equal elements, the indices are such that equal elements are
     listed in the order in which they appeared in the original list.

     Sorting of complex entries is done first by magnitude ('abs (Z)')
     and for any ties by phase angle ('angle (z)').  For example:

          sort ([1+i; 1; 1-i])
              => 1 + 0i
                 1 - 1i
                 1 + 1i

     NaN values are treated as being greater than any other value and
     are sorted to the end of the list.

     The 'sort' function may also be used to sort strings and cell
     arrays of strings, in which case ASCII dictionary order (uppercase
     'A' precedes lowercase 'a') of the strings is used.

     The algorithm used in 'sort' is optimized for the sorting of
     partially ordered lists.

     See also: sortrows, issorted.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Return a copy of X with the elements arranged in increasing order.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
issorted


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 588
 -- Built-in Function: issorted (A)
 -- Built-in Function: issorted (A, MODE)
 -- Built-in Function: issorted (A, "rows", MODE)
     Return true if the array is sorted according to MODE, which may be
     either "ascending", "descending", or "either".  By default, MODE is
     "ascending".  NaNs are treated in the same manner as 'sort'.

     If the optional argument "rows" is supplied, check whether the
     array is sorted by rows as output by the function 'sortrows' (with
     no options).

     This function does not support sparse matrices.

     See also: sort, sortrows.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
Return true if the array is sorted according to MODE, which may be  either "ascending", "descending", or "either".



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
nth_element


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 903
 -- Built-in Function: nth_element (X, N)
 -- Built-in Function: nth_element (X, N, DIM)
     Select the n-th smallest element of a vector, using the ordering
     defined by 'sort'.  In other words, the result is equivalent to
     'sort(X)(N)'.  N can also be a contiguous range, either ascending
     'l:u' or descending 'u:-1:l', in which case a range of elements is
     returned.  If X is an array, 'nth_element' operates along the
     dimension defined by DIM, or the first non-singleton dimension if
     DIM is not given.

     nth_element encapsulates the C++ standard library algorithms
     nth_element and partial_sort.  On average, the complexity of the
     operation is O(M*log(K)), where 'M = size (X, DIM)' and
     'K = length (N)'.  This function is intended for cases where the
     ratio K/M is small; otherwise, it may be better to use 'sort'.

     See also: sort, min, max.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Select the n-th smallest element of a vector, using the ordering  defined by 'sort'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
merge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 852
 -- Built-in Function: merge (MASK, TVAL, FVAL)
 -- Built-in Function: ifelse (MASK, TVAL, FVAL)
     Merge elements of TRUE_VAL and FALSE_VAL, depending on the value of
     MASK.  If MASK is a logical scalar, the other two arguments can be
     arbitrary values.  Otherwise, MASK must be a logical array, and
     TVAL, FVAL should be arrays of matching class, or cell arrays.  In
     the scalar mask case, TVAL is returned if MASK is true, otherwise
     FVAL is returned.

     In the array mask case, both TVAL and FVAL must be either scalars
     or arrays with dimensions equal to MASK.  The result is constructed
     as follows:

          result(mask) = tval(mask);
          result(! mask) = fval(! mask);

     MASK can also be arbitrary numeric type, in which case it is first
     converted to logical.

     See also: logical, diff.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Merge elements of TRUE_VAL and FALSE_VAL, depending on the value of  MASK.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
diff


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 990
 -- Built-in Function: diff (X)
 -- Built-in Function: diff (X, K)
 -- Built-in Function: diff (X, K, DIM)
     If X is a vector of length n, 'diff (X)' is the vector of first
     differences X(2) - X(1), ..., X(n) - X(n-1).

     If X is a matrix, 'diff (X)' is the matrix of column differences
     along the first non-singleton dimension.

     The second argument is optional.  If supplied, 'diff (X, K)', where
     K is a non-negative integer, returns the K-th differences.  It is
     possible that K is larger than the first non-singleton dimension of
     the matrix.  In this case, 'diff' continues to take the differences
     along the next non-singleton dimension.

     The dimension along which to take the difference can be explicitly
     stated with the optional variable DIM.  In this case the K-th order
     differences are calculated along this dimension.  In the case where
     K exceeds 'size (X, DIM)' an empty matrix is returned.

     See also: sort, merge.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
If X is a vector of length n, 'diff (X)' is the vector of first  differences X(2) - X(1), .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
repelems


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 734
 -- Built-in Function: repelems (X, R)
     Construct a vector of repeated elements from X.  R is a 2xN integer
     matrix specifying which elements to repeat and how often to repeat
     each element.

     Entries in the first row, R(1,j), select an element to repeat.  The
     corresponding entry in the second row, R(2,j), specifies the repeat
     count.  If X is a matrix then the columns of X are imagined to be
     stacked on top of each other for purposes of the selection index.
     A row vector is always returned.

     Conceptually the result is calculated as follows:

          y = [];
          for i = 1:columns (R)
            y = [y, X(R(1,i)*ones(1, R(2,i)))];
          endfor

     See also: repmat, cat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Construct a vector of repeated elements from X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
base64_encode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 151
 -- Built-in Function: S = base64_encode (X)
     Encode a double matrix or array X into the base64 format string S.

     See also: base64_decode.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Encode a double matrix or array X into the base64 format string S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
base64_decode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 317
 -- Built-in Function: X = base64_decode (S)
 -- Built-in Function: X = base64_decode (S, DIMS)
     Decode the double matrix or array X from the base64 encoded string
     S.  The optional input parameter DIMS should be a vector containing
     the dimensions of the decoded array.

     See also: base64_encode.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Decode the double matrix or array X from the base64 encoded string  S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbstop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1067
 -- Built-in Function: RLINE = dbstop ("FUNC")
 -- Built-in Function: RLINE = dbstop ("FUNC", LINE)
 -- Built-in Function: RLINE = dbstop ("FUNC", LINE1, LINE2, ...)
     Set a breakpoint in function FUNC.

     Arguments are

     FUNC
          Function name as a string variable.  When already in debug
          mode this should be left out and only the line should be
          given.

     LINE
          Line number where the breakpoint should be set.  Multiple
          lines may be given as separate arguments or as a vector.

     When called with a single argument FUNC, the breakpoint is set at
     the first executable line in the named function.

     The optional output RLINE is the real line number where the
     breakpoint was set.  This can differ from specified line if the
     line is not executable.  For example, if a breakpoint attempted on
     a blank line then Octave will set the real breakpoint at the next
     executable line.

     See also: dbclear, dbstatus, dbstep, debug_on_error,
     debug_on_warning, debug_on_interrupt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Set a breakpoint in function FUNC.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dbclear


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 753
 -- Built-in Function: dbclear ("FUNC")
 -- Built-in Function: dbclear ("FUNC", LINE, ...)
 -- Built-in Function: dbclear (LINE, ...)
     Delete a breakpoint in the function FUNC.

     Arguments are

     FUNC
          Function name as a string variable.  When already in debug
          mode this argument should be omitted and only the line number
          should be given.

     LINE
          Line number from which to remove a breakpoint.  Multiple lines
          may be given as separate arguments or as a vector.

     When called without a line number specification all breakpoints in
     the named function are cleared.

     If the requested line is not a breakpoint no action is performed.

     See also: dbstop, dbstatus, dbwhere.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Delete a breakpoint in the function FUNC.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
dbstatus


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 801
 -- Built-in Function: dbstatus ()
 -- Built-in Function: BRK_LIST = dbstatus ()
 -- Built-in Function: BRK_LIST = dbstatus ("FUNC")
     Report the location of active breakpoints.

     When called with no input or output arguments, print the list of
     all functions with breakpoints and the line numbers where those
     breakpoints are set.  If a function name FUNC is specified then
     only report breakpoints for the named function.

     The optional return argument BRK_LIST is a struct array with the
     following fields.

     name
          The name of the function with a breakpoint.

     file
          The name of the m-file where the function code is located.

     line
          A line number, or vector of line numbers, with a breakpoint.

     See also: dbclear, dbwhere.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Report the location of active breakpoints.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dbwhere


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 169
 -- Command: dbwhere
     In debugging mode, report the current file and line number where
     execution is stopped.

     See also: dbstatus, dbcont, dbstep, dbup.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
In debugging mode, report the current file and line number where  execution is stopped.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbtype


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 726
 -- Command: dbtype
 -- Command: dbtype LINENO
 -- Command: dbtype STARTL:ENDL
 -- Command: dbtype STARTL:END
 -- Command: dbtype FUNC
 -- Command: dbtype FUNC LINENO
 -- Command: dbtype FUNC STARTL:ENDL
 -- Command: dbtype FUNC STARTL:END
     Display a script file with line numbers.

     When called with no arguments in debugging mode, display the script
     file currently being debugged.  An optional range specification can
     be used to list only a portion of the file.  The special keyword
     "end" is a valid line number specification for the last line of the
     file.

     When called with the name of a function, list that script file with
     line numbers.

     See also: dbwhere, dbstatus, dbstop.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Display a script file with line numbers.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dblist


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 252
 -- Command: dblist
 -- Command: dblist N
     In debugging mode, list N lines of the function being debugged
     centered around the current line to be executed.  If unspecified N
     defaults to 10 (+/- 5 lines)

     See also: dbwhere, dbtype.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
In debugging mode, list N lines of the function being debugged  centered around the current line to be executed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dbstack


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1078
 -- Command: dbstack
 -- Command: dbstack N
 -- Command: dbstack -COMPLETENAMES
 -- Built-in Function: [STACK, IDX] = dbstack (...)
     Display or return current debugging function stack information.
     With optional argument N, omit the N innermost stack frames.

     Although accepted, the argument -COMPLETENAMES is silently ignored.
     Octave always returns absolute file names.  The arguments N and
     -COMPLETENAMES can be both specified in any order.

     The optional return argument STACK is a struct array with the
     following fields:

     file
          The name of the m-file where the function code is located.

     name
          The name of the function with a breakpoint.

     line
          The line number of an active breakpoint.

     column
          The column number of the line where the breakpoint begins.

     scope
          Undocumented.

     context
          Undocumented.

     The return argument IDX specifies which element of the STACK struct
     array is currently active.

     See also: dbup, dbdown, dbwhere, dbstatus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Display or return current debugging function stack information.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
dbup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 200
 -- Built-in Function: dbup
 -- Built-in Function: dbup (N)
     In debugging mode, move up the execution stack N frames.  If N is
     omitted, move up one frame.

     See also: dbstack, dbdown.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
In debugging mode, move up the execution stack N frames.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbdown


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 206
 -- Built-in Function: dbdown
 -- Built-in Function: dbdown (N)
     In debugging mode, move down the execution stack N frames.  If N is
     omitted, move down one frame.

     See also: dbstack, dbup.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
In debugging mode, move down the execution stack N frames.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbstep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 629
 -- Command: dbstep
 -- Command: dbstep N
 -- Command: dbstep in
 -- Command: dbstep out
 -- Command: dbnext ...
     In debugging mode, execute the next N lines of code.  If N is
     omitted, execute the next single line of code.  If the next line of
     code is itself defined in terms of an m-file remain in the existing
     function.

     Using 'dbstep in' will cause execution of the next line to step
     into any m-files defined on the next line.  Using 'dbstep out' will
     cause execution to continue until the current function returns.

     'dbnext' is an alias for 'dbstep'.

     See also: dbcont, dbquit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
In debugging mode, execute the next N lines of code.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbcont


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 137
 -- Command: dbcont
     Leave command-line debugging mode and continue code execution
     normally.

     See also: dbstep, dbquit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Leave command-line debugging mode and continue code execution  normally.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbquit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 161
 -- Command: dbquit
     Quit debugging mode immediately without further code execution and
     return to the Octave prompt.

     See also: dbcont, dbstep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Quit debugging mode immediately without further code execution and  return to the Octave prompt.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
isdebugmode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 141
 -- Built-in Function: isdebugmode ()
     Return true if in debugging mode, otherwise false.

     See also: dbwhere, dbstack, dbstatus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return true if in debugging mode, otherwise false.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
EDITOR


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 674
 -- Built-in Function: VAL = EDITOR ()
 -- Built-in Function: OLD_VAL = EDITOR (NEW_VAL)
 -- Built-in Function: EDITOR (NEW_VAL, "local")
     Query or set the internal variable that specifies the default text
     editor.

     The default value is taken from the environment variable 'EDITOR'
     when Octave starts.  If the environment variable is not
     initialized, 'EDITOR' will be set to "emacs".

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: edit, edit_history.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Query or set the internal variable that specifies the default text  editor.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
EXEC_PATH


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 757
 -- Built-in Function: VAL = EXEC_PATH ()
 -- Built-in Function: OLD_VAL = EXEC_PATH (NEW_VAL)
 -- Built-in Function: EXEC_PATH (NEW_VAL, "local")
     Query or set the internal variable that specifies a colon separated
     list of directories to append to the shell PATH when executing
     external programs.  The initial value of is taken from the
     environment variable 'OCTAVE_EXEC_PATH', but that value can be
     overridden by the command line argument '--exec-path PATH'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: IMAGE_PATH, OCTAVE_HOME.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 151
Query or set the internal variable that specifies a colon separated  list of directories to append to the shell PATH when executing  external programs.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
IMAGE_PATH


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 555
 -- Built-in Function: VAL = IMAGE_PATH ()
 -- Built-in Function: OLD_VAL = IMAGE_PATH (NEW_VAL)
 -- Built-in Function: IMAGE_PATH (NEW_VAL, "local")
     Query or set the internal variable that specifies a colon separated
     list of directories in which to search for image files.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: EXEC_PATH, OCTAVE_HOME.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
Query or set the internal variable that specifies a colon separated  list of directories in which to search for image files.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
OCTAVE_HOME


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 149
 -- Built-in Function: OCTAVE_HOME ()
     Return the name of the top-level Octave installation directory.

     See also: EXEC_PATH, IMAGE_PATH.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return the name of the top-level Octave installation directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
OCTAVE_VERSION


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
 -- Built-in Function: OCTAVE_VERSION ()
     Return the version number of Octave, as a string.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Return the version number of Octave, as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
det


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 503
 -- Built-in Function: det (A)
 -- Built-in Function: [D, RCOND] = det (A)
     Compute the determinant of A.

     Return an estimate of the reciprocal condition number if requested.

     Routines from LAPACK are used for full matrices and code from
     UMFPACK is used for sparse matrices.

     The determinant should not be used to check a matrix for
     singularity.  For that, use any of the condition number functions:
     'cond', 'condest', 'rcond'.

     See also: cond, condest, rcond.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Compute the determinant of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
cd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 764
 -- Command: cd DIR
 -- Command: cd
 -- Built-in Function: OLD_DIR = cd DIR
 -- Command: chdir ...
     Change the current working directory to DIR.

     If DIR is omitted, the current directory is changed to the user's
     home directory ("~").

     For example,

          cd ~/octave

     changes the current working directory to '~/octave'.  If the
     directory does not exist, an error message is printed and the
     working directory is not changed.

     'chdir' is an alias for 'cd' and can be used in all of the same
     calling formats.

     Compatibility Note: When called with no arguments, MATLAB prints
     the present working directory rather than changing to the user's
     home directory.

     See also: pwd, mkdir, rmdir, dir, ls.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Change the current working directory to DIR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
pwd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 155
 -- Built-in Function: pwd ()
 -- Built-in Function: DIR = pwd ()
     Return the current working directory.

     See also: cd, dir, ls, mkdir, rmdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Return the current working directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
readdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 431
 -- Built-in Function: FILES = readdir (DIR)
 -- Built-in Function: [FILES, ERR, MSG] = readdir (DIR)
     Return the names of files in the directory DIR as a cell array of
     strings.

     If an error occurs, return an empty cell array in FILES.  If
     successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR is
     nonzero and MSG contains a system-dependent error message.

     See also: ls, dir, glob, what.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return the names of files in the directory DIR as a cell array of  strings.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
mkdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 532
 -- Built-in Function: mkdir DIR
 -- Built-in Function: mkdir (PARENT, DIR)
 -- Built-in Function: [STATUS, MSG, MSGID] = mkdir (...)
     Create a directory named DIR in the directory PARENT.

     If no PARENT directory is specified the present working directory
     is used.

     If successful, STATUS is 1, and MSG, MSGID are empty character
     strings ("").  Otherwise, STATUS is 0, MSG contains a
     system-dependent error message, and MSGID contains a unique message
     identifier.

     See also: rmdir, pwd, cd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Create a directory named DIR in the directory PARENT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
rmdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 561
 -- Built-in Function: rmdir DIR
 -- Built-in Function: rmdir (DIR, "s")
 -- Built-in Function: [STATUS, MSG, MSGID] = rmdir (...)
     Remove the directory named DIR.

     If successful, STATUS is 1, and MSG, MSGID are empty character
     strings ("").  Otherwise, STATUS is 0, MSG contains a
     system-dependent error message, and MSGID contains a unique message
     identifier.

     If the optional second parameter is supplied with value "s",
     recursively remove all subdirectories as well.

     See also: mkdir, confirm_recursive_rmdir, pwd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Remove the directory named DIR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
link


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 354
 -- Built-in Function: link OLD NEW
 -- Built-in Function: [ERR, MSG] = link (OLD, NEW)
     Create a new link (also known as a hard link) to an existing file.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR
     is nonzero and MSG contains a system-dependent error message.

     See also: symlink, unlink, readlink, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Create a new link (also known as a hard link) to an existing file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
symlink


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 348
 -- Built-in Function: symlink OLD NEW
 -- Built-in Function: [ERR, MSG] = symlink (OLD, NEW)
     Create a symbolic link NEW which contains the string OLD.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR
     is nonzero and MSG contains a system-dependent error message.

     See also: link, unlink, readlink, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Create a symbolic link NEW which contains the string OLD.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
readlink


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 416
 -- Built-in Function: readlink SYMLINK
 -- Built-in Function: [RESULT, ERR, MSG] = readlink (SYMLINK)
     Read the value of the symbolic link SYMLINK.

     If successful, RESULT contains the contents of the symbolic link
     SYMLINK, ERR is 0, and MSG is an empty string.  Otherwise, ERR is
     nonzero and MSG contains a system-dependent error message.

     See also: lstat, symlink, link, unlink, delete.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Read the value of the symbolic link SYMLINK.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rename


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 322
 -- Built-in Function: rename OLD NEW
 -- Built-in Function: [ERR, MSG] = rename (OLD, NEW)
     Change the name of file OLD to NEW.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR
     is nonzero and MSG contains a system-dependent error message.

     See also: movefile, copyfile, ls, dir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Change the name of file OLD to NEW.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
glob


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1206
 -- Built-in Function: glob (PATTERN)
     Given an array of pattern strings (as a char array or a cell array)
     in PATTERN, return a cell array of file names that match any of
     them, or an empty cell array if no patterns match.  The pattern
     strings are interpreted as filename globbing patterns (as they are
     used by Unix shells).  Within a pattern

     '*'
          matches any string, including the null string,

     '?'
          matches any single character, and

     '[...]'
          matches any of the enclosed characters.

     Tilde expansion is performed on each of the patterns before looking
     for matching file names.  For example:

          ls
             =>
                file1  file2  file3  myfile1 myfile1b
          glob ("*file1")
             =>
                {
                  [1,1] = file1
                  [2,1] = myfile1
                }
          glob ("myfile?")
             =>
                {
                  [1,1] = myfile1
                }
          glob ("file[12]")
             =>
                {
                  [1,1] = file1
                  [2,1] = file2
                }

     See also: ls, dir, readdir, what, fnmatch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 184
Given an array of pattern strings (as a char array or a cell array)  in PATTERN, return a cell array of file names that match any of  them, or an empty cell array if no patterns match.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
fnmatch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 350
 -- Built-in Function: fnmatch (PATTERN, STRING)
     Return true or false for each element of STRING that matches any of
     the elements of the string array PATTERN, using the rules of
     filename pattern matching.  For example:

          fnmatch ("a*b", {"ab"; "axyzb"; "xyzab"})
               => [ 1; 1; 0 ]

     See also: glob, regexp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 157
Return true or false for each element of STRING that matches any of  the elements of the string array PATTERN, using the rules of  filename pattern matching.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
filesep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 454
 -- Built-in Function: filesep ()
 -- Built-in Function: filesep ("all")
     Return the system-dependent character used to separate directory
     names.

     If "all" is given, the function returns all valid file separators
     in the form of a string.  The list of file separators is
     system-dependent.  It is '/' (forward slash) under UNIX or
     Mac OS X, '/' and '\' (forward and backward slashes) under Windows.

     See also: pathsep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Return the system-dependent character used to separate directory  names.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
pathsep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 191
 -- Built-in Function: VAL = pathsep ()
 -- Built-in Function: OLD_VAL = pathsep (NEW_VAL)
     Query or set the character used to separate directories in a path.

     See also: filesep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Query or set the character used to separate directories in a path.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
confirm_recursive_rmdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 594
 -- Built-in Function: VAL = confirm_recursive_rmdir ()
 -- Built-in Function: OLD_VAL = confirm_recursive_rmdir (NEW_VAL)
 -- Built-in Function: confirm_recursive_rmdir (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     will ask for confirmation before recursively removing a directory
     tree.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: rmdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 137
Query or set the internal variable that controls whether Octave  will ask for confirmation before recursively removing a directory  tree.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dlmread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1341
 -- Built-in Function: DATA = dlmread (FILE)
 -- Built-in Function: DATA = dlmread (FILE, SEP)
 -- Built-in Function: DATA = dlmread (FILE, SEP, R0, C0)
 -- Built-in Function: DATA = dlmread (FILE, SEP, RANGE)
 -- Built-in Function: DATA = dlmread (..., "emptyvalue", EMPTYVAL)
     Read the matrix DATA from a text file.  If not defined the
     separator between fields is determined from the file itself.
     Otherwise the separation character is defined by SEP.

     Given two scalar arguments R0 and C0, these define the starting row
     and column of the data to be read.  These values are indexed from
     zero, such that the first row corresponds to an index of zero.

     The RANGE parameter may be a 4-element vector containing the upper
     left and lower right corner '[R0,C0,R1,C1]' where the lowest index
     value is zero.  Alternatively, a spreadsheet style range such as
     "A2..Q15" or "T1:AA5" can be used.  The lowest alphabetical index
     'A' refers to the first column.  The lowest row index is 1.

     FILE should be a file name or file id given by 'fopen'.  In the
     latter case, the file is read until end of file is reached.

     The "emptyvalue" option may be used to specify the value used to
     fill empty fields.  The default is zero.

     See also: csvread, textscan, textread, dlmwrite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Read the matrix DATA from a text file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
dot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 509
 -- Built-in Function: dot (X, Y, DIM)
     Compute the dot product of two vectors.  If X and Y are matrices,
     calculate the dot products along the first non-singleton dimension.
     If the optional argument DIM is given, calculate the dot products
     along this dimension.

     This is equivalent to 'sum (conj (X) .* Y, DIM)', but avoids
     forming a temporary array and is faster.  When X and Y are column
     vectors, the result is equivalent to 'X' * Y'.

     See also: cross, divergence.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Compute the dot product of two vectors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
blkmm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 416
 -- Built-in Function: blkmm (A, B)
     Compute products of matrix blocks.  The blocks are given as
     2-dimensional subarrays of the arrays A, B.  The size of A must
     have the form '[m,k,...]' and size of B must be '[k,n,...]'.  The
     result is then of size '[m,n,...]' and is computed as follows:

          for i = 1:prod (size (A)(3:end))
            C(:,:,i) = A(:,:,i) * B(:,:,i)
          endfor
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Compute products of matrix blocks.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
eig


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 551
 -- Built-in Function: LAMBDA = eig (A)
 -- Built-in Function: LAMBDA = eig (A, B)
 -- Built-in Function: [V, LAMBDA] = eig (A)
 -- Built-in Function: [V, LAMBDA] = eig (A, B)
     Compute the eigenvalues (and optionally the eigenvectors) of a
     matrix or a pair of matrices

     The algorithm used depends on whether there are one or two input
     matrices, if they are real or complex and if they are symmetric
     (Hermitian if complex) or non-symmetric.

     The eigenvalues returned by 'eig' are not ordered.

     See also: eigs, svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Compute the eigenvalues (and optionally the eigenvectors) of a  matrix or a pair of matrices 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ellipj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1198
 -- Built-in Function: [SN, CN, DN, ERR] = ellipj (U, M)
 -- Built-in Function: [SN, CN, DN, ERR] = ellipj (U, M, TOL)
     Compute the Jacobi elliptic functions SN, CN, and DN of complex
     argument U and real parameter M.

     If M is a scalar, the results are the same size as U.  If U is a
     scalar, the results are the same size as M.  If U is a column
     vector and M is a row vector, the results are matrices with 'length
     (U)' rows and 'length (M)' columns.  Otherwise, U and M must
     conform in size and the results will be the same size as the
     inputs.

     The value of U may be complex.  The value of M must be 0 <= M <= 1.

     The optional input TOL is currently ignored (MATLAB uses this to
     allow faster, less accurate approximation).

     If requested, ERR contains the following status information and is
     the same size as the result.

       0. Normal return.

       1. Error--no computation, algorithm termination condition not
          met, return 'NaN'.

     Reference: Milton Abramowitz and Irene A Stegun, 'Handbook of
     Mathematical Functions', Chapter 16 (Sections 16.4, 16.13, and
     16.15), Dover, 1965.

     See also: ellipke.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Compute the Jacobi elliptic functions SN, CN, and DN of complex  argument U and real parameter M.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rethrow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 381
 -- Built-in Function: rethrow (ERR)
     Reissue a previous error as defined by ERR.  ERR is a structure
     that must contain at least the "message" and "identifier" fields.
     ERR can also contain a field "stack" that gives information on the
     assumed location of the error.  Typically ERR is returned from
     'lasterror'.

     See also: lasterror, lasterr, error.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Reissue a previous error as defined by ERR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
error


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2731
 -- Built-in Function: error (TEMPLATE, ...)
 -- Built-in Function: error (ID, TEMPLATE, ...)
     Format the optional arguments under the control of the template
     string TEMPLATE using the same rules as the 'printf' family of
     functions (*note Formatted Output::) and print the resulting
     message on the 'stderr' stream.  The message is prefixed by the
     character string 'error: '.

     Calling 'error' also sets Octave's internal error state such that
     control will return to the top level without evaluating any more
     commands.  This is useful for aborting from functions or scripts.

     If the error message does not end with a new line character, Octave
     will print a traceback of all the function calls leading to the
     error.  For example, given the following function definitions:

          function f () g (); end
          function g () h (); end
          function h () nargin == 1 || error ("nargin != 1"); end

     calling the function 'f' will result in a list of messages that can
     help you to quickly locate the exact location of the error:

          f ()
          error: nargin != 1
          error: called from:
          error:   error at line -1, column -1
          error:   h at line 1, column 27
          error:   g at line 1, column 15
          error:   f at line 1, column 15

     If the error message ends in a new line character, Octave will
     print the message but will not display any traceback messages as it
     returns control to the top level.  For example, modifying the error
     message in the previous example to end in a new line causes Octave
     to only print a single message:

          function h () nargin == 1 || error ("nargin != 1\n"); end
          f ()
          error: nargin != 1

     A null string ("") input to 'error' will be ignored and the code
     will continue running as if the statement were a NOP.  This is for
     compatibility with MATLAB.  It also makes it possible to write code
     such as

          err_msg = "";
          if (CONDITION 1)
            err_msg = "CONDITION 1 found";
          elseif (CONDITION2)
            err_msg = "CONDITION 2 found";
          ...
          endif
          error (err_msg);

     which will only stop execution if an error has been found.

     Implementation Note: For compatibility with MATLAB, escape
     sequences (e.g., "\n" => newline) are processed in TEMPLATE
     regardless of whether TEMPLATE has been defined within single
     quotes as long as there are two or more input arguments.  Use a
     second backslash to stop interpolation of the escape sequence
     (e.g., "\\n") or use the 'regexptranslate' function.

     See also: warning, lasterror.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 222
Format the optional arguments under the control of the template  string TEMPLATE using the same rules as the 'printf' family of  functions (*note Formatted Output::) and print the resulting  message on the 'stderr' stream.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
warning


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2506
 -- Built-in Function: warning (TEMPLATE, ...)
 -- Built-in Function: warning (ID, TEMPLATE, ...)
 -- Built-in Function: warning ("on", ID)
 -- Built-in Function: warning ("off", ID)
 -- Built-in Function: warning ("query", ID)
 -- Built-in Function: warning ("error", ID)
 -- Built-in Function: warning (STATE, ID, "local")
     Format the optional arguments under the control of the template
     string TEMPLATE using the same rules as the 'printf' family of
     functions (*note Formatted Output::) and print the resulting
     message on the 'stderr' stream.  The message is prefixed by the
     character string 'warning: '.  You should use this function when
     you want to notify the user of an unusual condition, but only when
     it makes sense for your program to go on.

     The optional message identifier allows users to enable or disable
     warnings tagged by ID.  A message identifier is of the form
     "NAMESPACE:WARNING-NAME". Octave's own warnings use the "Octave"
     namespace (*note XREFwarning_ids::).  The special identifier "all"
     may be used to set the state of all warnings.

     If the first argument is "on" or "off", set the state of a
     particular warning using the identifier ID.  If the first argument
     is "query", query the state of this warning instead.  If the
     identifier is omitted, a value of "all" is assumed.  If you set the
     state of a warning to "error", the warning named by ID is handled
     as if it were an error instead.  So, for example, the following
     handles all warnings as errors:

          warning ("error");

     If the state is "on", "off", or "error" and the third argument is
     "local", then the warning state will be set temporarily, until the
     end of the current function.  Changes to warning states that are
     set locally affect the current function and all functions called
     from the current scope.  The previous warning state is restored on
     return from the current function.  The "local" option is ignored if
     used in the top-level workspace.

     Implementation Note: For compatibility with MATLAB, escape
     sequences (e.g., "\n" => newline) are processed in TEMPLATE
     regardless of whether TEMPLATE has been defined within single
     quotes as long as there are two or more input arguments.  Use a
     second backslash to stop interpolation of the escape sequence
     (e.g., "\\n") or use the 'regexptranslate' function.

     See also: warning_ids, lastwarn, error.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 222
Format the optional arguments under the control of the template  string TEMPLATE using the same rules as the 'printf' family of  functions (*note Formatted Output::) and print the resulting  message on the 'stderr' stream.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
lasterror


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1434
 -- Built-in Function: LASTERR = lasterror ()
 -- Built-in Function: lasterror (ERR)
 -- Built-in Function: lasterror ("reset")
     Query or set the last error message structure.  When called without
     arguments, return a structure containing the last error message and
     other information related to this error.  The elements of the
     structure are:

     'message'
          The text of the last error message

     'identifier'
          The message identifier of this error message

     'stack'
          A structure containing information on where the message
          occurred.  This may be an empty structure if the information
          cannot be obtained.  The fields of the structure are:

          'file'
               The name of the file where the error occurred

          'name'
               The name of function in which the error occurred

          'line'
               The line number at which the error occurred

          'column'
               An optional field with the column number at which the
               error occurred

     The last error structure may be set by passing a scalar structure,
     ERR, as input.  Any fields of ERR that match those above are set
     while any unspecified fields are initialized with default values.

     If 'lasterror' is called with the argument "reset", all fields are
     set to their default values.

     See also: lasterr, error, lastwarn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Query or set the last error message structure.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
lasterr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 439
 -- Built-in Function: [MSG, MSGID] = lasterr ()
 -- Built-in Function: lasterr (MSG)
 -- Built-in Function: lasterr (MSG, MSGID)
     Query or set the last error message.  When called without input
     arguments, return the last error message and message identifier.
     With one argument, set the last error message to MSG.  With two
     arguments, also set the last message identifier.

     See also: lasterror, error, lastwarn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Query or set the last error message.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
lastwarn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 449
 -- Built-in Function: [MSG, MSGID] = lastwarn ()
 -- Built-in Function: lastwarn (MSG)
 -- Built-in Function: lastwarn (MSG, MSGID)
     Query or set the last warning message.  When called without input
     arguments, return the last warning message and message identifier.
     With one argument, set the last warning message to MSG.  With two
     arguments, also set the last message identifier.

     See also: warning, lasterror, lasterr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Query or set the last warning message.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
usage


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 853
 -- Built-in Function: usage (MSG)
     Print the message MSG, prefixed by the string 'usage: ', and set
     Octave's internal error state such that control will return to the
     top level without evaluating any more commands.  This is useful for
     aborting from functions.

     After 'usage' is evaluated, Octave will print a traceback of all
     the function calls leading to the usage message.

     You should use this function for reporting problems errors that
     result from an improper call to a function, such as calling a
     function with an incorrect number of arguments, or with arguments
     of the wrong type.  For example, most functions distributed with
     Octave begin with code like this

          if (nargin != 2)
            usage ("foo (a, b)");
          endif

     to check for the proper number of arguments.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 181
Print the message MSG, prefixed by the string 'usage: ', and set  Octave's internal error state such that control will return to the  top level without evaluating any more commands.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
beep_on_error


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 538
 -- Built-in Function: VAL = beep_on_error ()
 -- Built-in Function: OLD_VAL = beep_on_error (NEW_VAL)
 -- Built-in Function: beep_on_error (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     will try to ring the terminal bell before printing an error
     message.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
Query or set the internal variable that controls whether Octave  will try to ring the terminal bell before printing an error  message.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
debug_on_error


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 706
 -- Built-in Function: VAL = debug_on_error ()
 -- Built-in Function: OLD_VAL = debug_on_error (NEW_VAL)
 -- Built-in Function: debug_on_error (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     will try to enter the debugger when an error is encountered.  This
     will also inhibit printing of the normal traceback message (you
     will only see the top-level error message).

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: debug_on_warning, debug_on_interrupt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
Query or set the internal variable that controls whether Octave  will try to enter the debugger when an error is encountered.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
debug_on_warning


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 587
 -- Built-in Function: VAL = debug_on_warning ()
 -- Built-in Function: OLD_VAL = debug_on_warning (NEW_VAL)
 -- Built-in Function: debug_on_warning (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     will try to enter the debugger when a warning is encountered.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: debug_on_error, debug_on_interrupt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
Query or set the internal variable that controls whether Octave  will try to enter the debugger when a warning is encountered.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
fft


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 964
 -- Built-in Function: fft (X)
 -- Built-in Function: fft (X, N)
 -- Built-in Function: fft (X, N, DIM)
     Compute the discrete Fourier transform of A using a Fast Fourier
     Transform (FFT) algorithm.

     The FFT is calculated along the first non-singleton dimension of
     the array.  Thus if X is a matrix, 'fft (X)' computes the FFT for
     each column of X.

     If called with two arguments, N is expected to be an integer
     specifying the number of elements of X to use, or an empty matrix
     to specify that its value should be ignored.  If N is larger than
     the dimension along which the FFT is calculated, then X is resized
     and padded with zeros.  Otherwise, if N is smaller than the
     dimension along which the FFT is calculated, then X is truncated.

     If called with three arguments, DIM is an integer specifying the
     dimension of the matrix along which the FFT is performed

     See also: ifft, fft2, fftn, fftw.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
Compute the discrete Fourier transform of A using a Fast Fourier  Transform (FFT) algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
ifft


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1021
 -- Built-in Function: ifft (X)
 -- Built-in Function: ifft (X, N)
 -- Built-in Function: ifft (X, N, DIM)
     Compute the inverse discrete Fourier transform of A using a Fast
     Fourier Transform (FFT) algorithm.

     The inverse FFT is calculated along the first non-singleton
     dimension of the array.  Thus if X is a matrix, 'fft (X)' computes
     the inverse FFT for each column of X.

     If called with two arguments, N is expected to be an integer
     specifying the number of elements of X to use, or an empty matrix
     to specify that its value should be ignored.  If N is larger than
     the dimension along which the inverse FFT is calculated, then X is
     resized and padded with zeros.  Otherwise, if N is smaller than the
     dimension along which the inverse FFT is calculated, then X is
     truncated.

     If called with three arguments, DIM is an integer specifying the
     dimension of the matrix along which the inverse FFT is performed

     See also: fft, ifft2, ifftn, fftw.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
Compute the inverse discrete Fourier transform of A using a Fast  Fourier Transform (FFT) algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fft2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 535
 -- Built-in Function: fft2 (A)
 -- Built-in Function: fft2 (A, M, N)
     Compute the two-dimensional discrete Fourier transform of A using a
     Fast Fourier Transform (FFT) algorithm.

     The optional arguments M and N may be used specify the number of
     rows and columns of A to use.  If either of these is larger than
     the size of A, A is resized and padded with zeros.

     If A is a multi-dimensional matrix, each two-dimensional sub-matrix
     of A is treated separately.

     See also: ifft2, fft, fftn, fftw.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
Compute the two-dimensional discrete Fourier transform of A using a  Fast Fourier Transform (FFT) algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ifft2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 545
 -- Built-in Function: ifft2 (A)
 -- Built-in Function: ifft2 (A, M, N)
     Compute the inverse two-dimensional discrete Fourier transform of A
     using a Fast Fourier Transform (FFT) algorithm.

     The optional arguments M and N may be used specify the number of
     rows and columns of A to use.  If either of these is larger than
     the size of A, A is resized and padded with zeros.

     If A is a multi-dimensional matrix, each two-dimensional sub-matrix
     of A is treated separately

     See also: fft2, ifft, ifftn, fftw.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
Compute the inverse two-dimensional discrete Fourier transform of A  using a Fast Fourier Transform (FFT) algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fftn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 611
 -- Built-in Function: fftn (A)
 -- Built-in Function: fftn (A, SIZE)
     Compute the N-dimensional discrete Fourier transform of A using a
     Fast Fourier Transform (FFT) algorithm.

     The optional vector argument SIZE may be used specify the
     dimensions of the array to be used.  If an element of SIZE is
     smaller than the corresponding dimension of A, then the dimension
     of A is truncated prior to performing the FFT.  Otherwise, if an
     element of SIZE is larger than the corresponding dimension then A
     is resized and padded with zeros.

     See also: ifftn, fft, fft2, fftw.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 106
Compute the N-dimensional discrete Fourier transform of A using a  Fast Fourier Transform (FFT) algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ifftn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 630
 -- Built-in Function: ifftn (A)
 -- Built-in Function: ifftn (A, SIZE)
     Compute the inverse N-dimensional discrete Fourier transform of A
     using a Fast Fourier Transform (FFT) algorithm.

     The optional vector argument SIZE may be used specify the
     dimensions of the array to be used.  If an element of SIZE is
     smaller than the corresponding dimension of A, then the dimension
     of A is truncated prior to performing the inverse FFT.  Otherwise,
     if an element of SIZE is larger than the corresponding dimension
     then A is resized and padded with zeros.

     See also: fftn, ifft, ifft2, fftw.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
Compute the inverse N-dimensional discrete Fourier transform of A  using a Fast Fourier Transform (FFT) algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fclose


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 312
 -- Built-in Function: fclose (FID)
 -- Built-in Function: fclose ("all")
     Close the specified file.  If successful, 'fclose' returns 0,
     otherwise, it returns -1.  The second form of the 'fclose' call
     closes all open files except 'stdout', 'stderr', and 'stdin'.

     See also: fopen, freport.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Close the specified file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fclear


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
 -- Built-in Function: fclear (FID)
     Clear the stream state for the specified file.

     See also: fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Clear the stream state for the specified file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fflush


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 414
 -- Built-in Function: fflush (FID)
     Flush output to FID.  This is useful for ensuring that all pending
     output makes it to the screen before some other event occurs.  For
     example, it is always a good idea to flush the standard output
     stream before calling 'input'.

     'fflush' returns 0 on success and an OS dependent error value (-1
     on Unix) on error.

     See also: fopen, fclose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Flush output to FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fgetl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 545
 -- Built-in Function: STR = fgetl (FID)
 -- Built-in Function: STR = fgetl (FID, LEN)
     Read characters from a file, stopping after a newline, or EOF, or
     LEN characters have been read.  The characters read, excluding the
     possible trailing newline, are returned as a string.

     If LEN is omitted, 'fgetl' reads until the next newline character.

     If there are no more characters to read, 'fgetl' returns -1.

     To read a line and return the terminating newline see 'fgets'.

     See also: fgets, fscanf, fread, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Read characters from a file, stopping after a newline, or EOF, or  LEN characters have been read.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fgets


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 553
 -- Built-in Function: STR = fgets (FID)
 -- Built-in Function: STR = fgets (FID, LEN)
     Read characters from a file, stopping after a newline, or EOF, or
     LEN characters have been read.  The characters read, including the
     possible trailing newline, are returned as a string.

     If LEN is omitted, 'fgets' reads until the next newline character.

     If there are no more characters to read, 'fgets' returns -1.

     To read a line and discard the terminating newline see 'fgetl'.

     See also: fputs, fgetl, fscanf, fread, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Read characters from a file, stopping after a newline, or EOF, or  LEN characters have been read.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fskipl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 686
 -- Built-in Function: NLINES = fskipl (FID)
 -- Built-in Function: NLINES = fskipl (FID, COUNT)
 -- Built-in Function: NLINES = fskipl (FID, Inf)
     Read and skip COUNT lines from the file descriptor FID.  'fskipl'
     discards characters until an end-of-line is encountered exactly
     COUNT-times, or until the end-of-file marker is found.

     If COUNT is omitted, it defaults to 1.  COUNT may also be 'Inf', in
     which case lines are skipped until the end of the file.  This form
     is suitable for counting the number of lines in a file.

     Returns the number of lines skipped (end-of-line sequences
     encountered).

     See also: fgetl, fgets, fscanf, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Read and skip COUNT lines from the file descriptor FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fopen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3250
 -- Built-in Function: [FID, MSG] = fopen (NAME, MODE, ARCH)
 -- Built-in Function: FID_LIST = fopen ("all")
 -- Built-in Function: [FILE, MODE, ARCH] = fopen (FID)
     The first form of the 'fopen' function opens the named file with
     the specified mode (read-write, read-only, etc.)  and architecture
     interpretation (IEEE big endian, IEEE little endian, etc.), and
     returns an integer value that may be used to refer to the file
     later.  If an error occurs, FID is set to -1 and MSG contains the
     corresponding system error message.  The MODE is a one or two
     character string that specifies whether the file is to be opened
     for reading, writing, or both.

     The second form of the 'fopen' function returns a vector of file
     ids corresponding to all the currently open files, excluding the
     'stdin', 'stdout', and 'stderr' streams.

     The third form of the 'fopen' function returns information about
     the open file given its file id.

     For example,

          myfile = fopen ("splat.dat", "r", "ieee-le");

     opens the file 'splat.dat' for reading.  If necessary, binary
     numeric values will be read assuming they are stored in IEEE format
     with the least significant bit first, and then converted to the
     native representation.

     Opening a file that is already open simply opens it again and
     returns a separate file id.  It is not an error to open a file
     several times, though writing to the same file through several
     different file ids may produce unexpected results.

     The possible values 'mode' may have are

     'r'
          Open a file for reading.

     'w'
          Open a file for writing.  The previous contents are discarded.

     'a'
          Open or create a file for writing at the end of the file.

     'r+'
          Open an existing file for reading and writing.

     'w+'
          Open a file for reading or writing.  The previous contents are
          discarded.

     'a+'
          Open or create a file for reading or writing at the end of the
          file.

     Append a "t" to the mode string to open the file in text mode or a
     "b" to open in binary mode.  On Windows and Macintosh systems, text
     mode reading and writing automatically converts linefeeds to the
     appropriate line end character for the system (carriage-return
     linefeed on Windows, carriage-return on Macintosh).  The default if
     no mode is specified is binary mode.

     Additionally, you may append a "z" to the mode string to open a
     gzipped file for reading or writing.  For this to be successful,
     you must also open the file in binary mode.

     The parameter ARCH is a string specifying the default data format
     for the file.  Valid values for ARCH are:

     'native'
          The format of the current machine (this is the default).

     'ieee-be'
          IEEE big endian format.

     'ieee-le'
          IEEE little endian format.

     however, conversions are currently only supported for 'native'
     'ieee-be', and 'ieee-le' formats.

     See also: fclose, fgets, fgetl, fscanf, fread, fputs, fdisp,
     fprintf, fwrite, fskipl, fseek, frewind, ftell, feof, ferror,
     fclear, fflush, freport.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
The first form of the 'fopen' function opens the named file with  the specified mode (read-write, read-only, etc.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
freport


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 433
 -- Built-in Function: freport ()
     Print a list of which files have been opened, and whether they are
     open for reading, writing, or both.  For example:

          freport ()

               -|  number  mode  name
               -|
               -|       0     r  stdin
               -|       1     w  stdout
               -|       2     w  stderr
               -|       3     r  myfile

     See also: fopen, fclose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Print a list of which files have been opened, and whether they are  open for reading, writing, or both.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
frewind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 258
 -- Built-in Function: frewind (FID)
     Move the file pointer to the beginning of the file FID, returning 0
     for success, and -1 if an error was encountered.  It is equivalent
     to 'fseek (FID, 0, SEEK_SET)'.

     See also: fseek, ftell, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
Move the file pointer to the beginning of the file FID, returning 0  for success, and -1 if an error was encountered.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fseek


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 700
 -- Built-in Function: fseek (FID, OFFSET)
 -- Built-in Function: fseek (FID, OFFSET, ORIGIN)
 -- Built-in Function: STATUS = fseek (...)
     Set the file pointer to any location within the file FID.

     The pointer is positioned OFFSET characters from the ORIGIN, which
     may be one of the predefined variables 'SEEK_CUR' (current
     position), 'SEEK_SET' (beginning), or 'SEEK_END' (end of file) or
     strings "cof", "bof" or "eof".  If ORIGIN is omitted, 'SEEK_SET' is
     assumed.  OFFSET may be positive, negative, or zero but not all
     combinations of ORIGIN and OFFSET can be realized.

     Return 0 on success and -1 on error.

     See also: fskipl, frewind, ftell, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Set the file pointer to any location within the file FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ftell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 188
 -- Built-in Function: ftell (FID)
     Return the position of the file pointer as the number of characters
     from the beginning of the file FID.

     See also: fseek, feof, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
Return the position of the file pointer as the number of characters  from the beginning of the file FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
fprintf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 305
 -- Built-in Function: fprintf (FID, TEMPLATE, ...)
     This function is just like 'printf', except that the output is
     written to the stream FID instead of 'stdout'.  If FID is omitted,
     the output is written to 'stdout'.

     See also: fputs, fdisp, fwrite, fscanf, printf, sprintf, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
This function is just like 'printf', except that the output is  written to the stream FID instead of 'stdout'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
printf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 382
 -- Built-in Function: printf (TEMPLATE, ...)
     Print optional arguments under the control of the template string
     TEMPLATE to the stream 'stdout' and return the number of characters
     printed.

     See the Formatted Output section of the GNU Octave manual for a
     complete description of the syntax of the template string.

     See also: fprintf, sprintf, scanf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 144
Print optional arguments under the control of the template string  TEMPLATE to the stream 'stdout' and return the number of characters  printed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fputs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 207
 -- Built-in Function: fputs (FID, STRING)
     Write a string to a file with no formatting.

     Return a non-negative number on success and EOF on error.

     See also: fdisp, fprintf, fwrite, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Write a string to a file with no formatting.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
puts


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 196
 -- Built-in Function: puts (STRING)
     Write a string to the standard output with no formatting.

     Return a non-negative number on success and EOF on error.

     See also: fputs, disp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Write a string to the standard output with no formatting.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
sprintf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 393
 -- Built-in Function: sprintf (TEMPLATE, ...)
     This is like 'printf', except that the output is returned as a
     string.  Unlike the C library function, which requires you to
     provide a suitably sized string as an argument, Octave's 'sprintf'
     function returns the string, automatically sized to hold all of the
     items converted.

     See also: printf, fprintf, sscanf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
This is like 'printf', except that the output is returned as a  string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fscanf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1739
 -- Built-in Function: [VAL, COUNT, ERRMSG] = fscanf (FID, TEMPLATE,
          SIZE)
 -- Built-in Function: [V1, V2, ..., COUNT, ERRMSG] = fscanf (FID,
          TEMPLATE, "C")
     In the first form, read from FID according to TEMPLATE, returning
     the result in the matrix VAL.

     The optional argument SIZE specifies the amount of data to read and
     may be one of

     'Inf'
          Read as much as possible, returning a column vector.

     'NR'
          Read up to NR elements, returning a column vector.

     '[NR, Inf]'
          Read as much as possible, returning a matrix with NR rows.  If
          the number of elements read is not an exact multiple of NR,
          the last column is padded with zeros.

     '[NR, NC]'
          Read up to 'NR * NC' elements, returning a matrix with NR
          rows.  If the number of elements read is not an exact multiple
          of NR, the last column is padded with zeros.

     If SIZE is omitted, a value of 'Inf' is assumed.

     A string is returned if TEMPLATE specifies only character
     conversions.

     The number of items successfully read is returned in COUNT.

     If an error occurs, ERRMSG contains a system-dependent error
     message.

     In the second form, read from FID according to TEMPLATE, with each
     conversion specifier in TEMPLATE corresponding to a single scalar
     return value.  This form is more "C-like", and also compatible with
     previous versions of Octave.  The number of successful conversions
     is returned in COUNT

     See the Formatted Input section of the GNU Octave manual for a
     complete description of the syntax of the template string.

     See also: fgets, fgetl, fread, scanf, sscanf, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 119
SIZE)  TEMPLATE, "C")  In the first form, read from FID according to TEMPLATE, returning  the result in the matrix VAL.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
sscanf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 549
 -- Built-in Function: [VAL, COUNT, ERRMSG, POS] = sscanf (STRING,
          TEMPLATE, SIZE)
 -- Built-in Function: [V1, V2, ..., COUNT, ERRMSG] = sscanf (STRING,
          TEMPLATE, "C")
     This is like 'fscanf', except that the characters are taken from
     the string STRING instead of from a stream.  Reaching the end of
     the string is treated as an end-of-file condition.  In addition to
     the values returned by 'fscanf', the index of the next character to
     be read is returned in POS.

     See also: fscanf, scanf, sprintf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 142
TEMPLATE, SIZE)  TEMPLATE, "C")  This is like 'fscanf', except that the characters are taken from  the string STRING instead of from a stream.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
scanf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 337
 -- Built-in Function: [VAL, COUNT, ERRMSG] = scanf (TEMPLATE, SIZE)
 -- Built-in Function: [V1, V2, ..., COUNT, ERRMSG]] = scanf (TEMPLATE,
          "C")
     This is equivalent to calling 'fscanf' with FID = 'stdin'.

     It is currently not useful to call 'scanf' in interactive programs.

     See also: fscanf, sscanf, printf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
"C")  This is equivalent to calling 'fscanf' with FID = 'stdin'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4149
 -- Built-in Function: [VAL, COUNT] = fread (FID, SIZE, PRECISION, SKIP,
          ARCH)
     Read binary data of type PRECISION from the specified file ID FID.

     The optional argument SIZE specifies the amount of data to read and
     may be one of

     'Inf'
          Read as much as possible, returning a column vector.

     'NR'
          Read up to NR elements, returning a column vector.

     '[NR, Inf]'
          Read as much as possible, returning a matrix with NR rows.  If
          the number of elements read is not an exact multiple of NR,
          the last column is padded with zeros.

     '[NR, NC]'
          Read up to 'NR * NC' elements, returning a matrix with NR
          rows.  If the number of elements read is not an exact multiple
          of NR, the last column is padded with zeros.

     If SIZE is omitted, a value of 'Inf' is assumed.

     The optional argument PRECISION is a string specifying the type of
     data to read and may be one of

     "schar"
     "signed char"
          Signed character.

     "uchar"
     "unsigned char"
          Unsigned character.

     "int8"
     "integer*1"

          8-bit signed integer.

     "int16"
     "integer*2"
          16-bit signed integer.

     "int32"
     "integer*4"
          32-bit signed integer.

     "int64"
     "integer*8"
          64-bit signed integer.

     "uint8"
          8-bit unsigned integer.

     "uint16"
          16-bit unsigned integer.

     "uint32"
          32-bit unsigned integer.

     "uint64"
          64-bit unsigned integer.

     "single"
     "float32"
     "real*4"
          32-bit floating point number.

     "double"
     "float64"
     "real*8"
          64-bit floating point number.

     "char"
     "char*1"
          Single character.

     "short"
          Short integer (size is platform dependent).

     "int"
          Integer (size is platform dependent).

     "long"
          Long integer (size is platform dependent).

     "ushort"
     "unsigned short"
          Unsigned short integer (size is platform dependent).

     "uint"
     "unsigned int"
          Unsigned integer (size is platform dependent).

     "ulong"
     "unsigned long"
          Unsigned long integer (size is platform dependent).

     "float"
          Single precision floating point number (size is platform
          dependent).

     The default precision is "uchar".

     The PRECISION argument may also specify an optional repeat count.
     For example, '32*single' causes 'fread' to read a block of 32
     single precision floating point numbers.  Reading in blocks is
     useful in combination with the SKIP argument.

     The PRECISION argument may also specify a type conversion.  For
     example, 'int16=>int32' causes 'fread' to read 16-bit integer
     values and return an array of 32-bit integer values.  By default,
     'fread' returns a double precision array.  The special form '*TYPE'
     is shorthand for 'TYPE=>TYPE'.

     The conversion and repeat counts may be combined.  For example, the
     specification '32*single=>single' causes 'fread' to read blocks of
     single precision floating point values and return an array of
     single precision values instead of the default array of double
     precision values.

     The optional argument SKIP specifies the number of bytes to skip
     after each element (or block of elements) is read.  If it is not
     specified, a value of 0 is assumed.  If the final block read is not
     complete, the final skip is omitted.  For example,

          fread (f, 10, "3*single=>single", 8)

     will omit the final 8-byte skip because the last read will not be a
     complete block of 3 values.

     The optional argument ARCH is a string specifying the data format
     for the file.  Valid values are

     '"native"'
          The format of the current machine.

     '"ieee-be"'
          IEEE big endian.

     '"ieee-le"'
          IEEE little endian.

     The data read from the file is returned in VAL, and the number of
     values read is returned in 'count'

     See also: fwrite, fgets, fgetl, fscanf, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
ARCH)  Read binary data of type PRECISION from the specified file ID FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fwrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 653
 -- Built-in Function: COUNT = fwrite (FID, DATA, PRECISION, SKIP, ARCH)
     Write data in binary form of type PRECISION to the specified file
     ID FID, returning the number of values successfully written to the
     file.

     The argument DATA is a matrix of values that are to be written to
     the file.  The values are extracted in column-major order.

     The remaining arguments PRECISION, SKIP, and ARCH are optional, and
     are interpreted as described for 'fread'.

     The behavior of 'fwrite' is undefined if the values in DATA are too
     large to fit in the specified precision.

     See also: fread, fputs, fprintf, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 140
Write data in binary form of type PRECISION to the specified file  ID FID, returning the number of values successfully written to the  file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
feof


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 337
 -- Built-in Function: feof (FID)
     Return 1 if an end-of-file condition has been encountered for a
     given file and 0 otherwise.  Note that it will only return 1 if the
     end of the file has already been encountered, not if the next read
     operation will result in an end-of-file condition.

     See also: fread, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
Return 1 if an end-of-file condition has been encountered for a  given file and 0 otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ferror


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 482
 -- Built-in Function: [ERR, MSG] = ferror (FID)
 -- Built-in Function: [ERR, MSG] = ferror (FID, "clear")
     Return 1 if an error condition has been encountered for the file ID
     FID and 0 otherwise.  Note that it will only return 1 if an error
     has already been encountered, not if the next operation will result
     in an error condition.

     The second argument is optional.  If it is supplied, also clear the
     error condition.

     See also: fclear, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
Return 1 if an error condition has been encountered for the file ID  FID and 0 otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
popen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 888
 -- Built-in Function: FID = popen (COMMAND, MODE)
     Start a process and create a pipe.  The name of the command to run
     is given by COMMAND.  The file identifier corresponding to the
     input or output stream of the process is returned in FID.  The
     argument MODE may be

     '"r"'
          The pipe will be connected to the standard output of the
          process, and open for reading.

     '"w"'
          The pipe will be connected to the standard input of the
          process, and open for writing.

     For example:

          fid = popen ("ls -ltr / | tail -3", "r");
          while (ischar (s = fgets (fid)))
            fputs (stdout, s);
          endwhile

             -| drwxr-xr-x  33 root  root  3072 Feb 15 13:28 etc
             -| drwxr-xr-x   3 root  root  1024 Feb 15 13:28 lib
             -| drwxrwxrwt  15 root  root  2048 Feb 17 14:53 tmp
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Start a process and create a pipe.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
pclose


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
 -- Built-in Function: pclose (FID)
     Close a file identifier that was opened by 'popen'.  You may also
     use 'fclose' for the same purpose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Close a file identifier that was opened by 'popen'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
tmpnam


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 637
 -- Built-in Function: tmpnam ()
 -- Built-in Function: tmpnam (DIR)
 -- Built-in Function: tmpnam (DIR, PREFIX)
     Return a unique temporary file name as a string.

     If PREFIX is omitted, a value of "oct-" is used.  If DIR is also
     omitted, the default directory for temporary files is used.  If DIR
     is provided, it must exist, otherwise the default directory for
     temporary files is used.  Since the named file is not opened, by
     'tmpnam', it is possible (though relatively unlikely) that it will
     not be available by the time your program attempts to open it.

     See also: tmpfile, mkstemp, P_tmpdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return a unique temporary file name as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
tmpfile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 478
 -- Built-in Function: [FID, MSG] = tmpfile ()
     Return the file ID corresponding to a new temporary file with a
     unique name.  The file is opened in binary read/write ("w+b") mode.
     The file will be deleted automatically when it is closed or when
     Octave exits.

     If successful, FID is a valid file ID and MSG is an empty string.
     Otherwise, FID is -1 and MSG contains a system-dependent error
     message.

     See also: tmpnam, mkstemp, P_tmpdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Return the file ID corresponding to a new temporary file with a  unique name.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
mkstemp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 949
 -- Built-in Function: [FID, NAME, MSG] = mkstemp (TEMPLATE, DELETE)
     Return the file ID corresponding to a new temporary file with a
     unique name created from TEMPLATE.  The last six characters of
     TEMPLATE must be 'XXXXXX' and these are replaced with a string that
     makes the filename unique.  The file is then created with mode
     read/write and permissions that are system dependent (on GNU/Linux
     systems, the permissions will be 0600 for versions of glibc 2.0.7
     and later).  The file is opened in binary mode and with the 'O_EXCL'
     flag.

     If the optional argument DELETE is supplied and is true, the file
     will be deleted automatically when Octave exits.

     If successful, FID is a valid file ID, NAME is the name of the
     file, and MSG is an empty string.  Otherwise, FID is -1, NAME is
     empty, and MSG contains a system-dependent error message.

     See also: tmpfile, tmpnam, P_tmpdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
Return the file ID corresponding to a new temporary file with a  unique name created from TEMPLATE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
umask


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 317
 -- Built-in Function: umask (MASK)
     Set the permission mask for file creation.  The parameter MASK is
     an integer, interpreted as an octal number.  If successful, returns
     the previous value of the mask (as an integer to be interpreted as
     an octal number); otherwise an error message is printed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Set the permission mask for file creation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
P_tmpdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 174
 -- Built-in Function: P_tmpdir ()
     Return the default name of the directory for temporary files on
     this system.  The name of this directory is system dependent.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Return the default name of the directory for temporary files on  this system.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
SEEK_SET


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 433
 -- Built-in Function: SEEK_SET ()
 -- Built-in Function: SEEK_CUR ()
 -- Built-in Function: SEEK_END ()
     Return the numerical value to pass to 'fseek' to perform one of the
     following actions:

     'SEEK_SET'
          Position file relative to the beginning.

     'SEEK_CUR'
          Position file relative to the current position.

     'SEEK_END'
          Position file relative to the end.

     See also: fseek.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
Return the numerical value to pass to 'fseek' to perform one of the  following actions: 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
SEEK_CUR


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 193
 -- Built-in Function: SEEK_CUR ()
     Return the numerical value to pass to 'fseek' to position the file
     pointer relative to the current position.

     See also: SEEK_SET, SEEK_END.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
Return the numerical value to pass to 'fseek' to position the file  pointer relative to the current position.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
SEEK_END


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 192
 -- Built-in Function: SEEK_END ()
     Return the numerical value to pass to 'fseek' to position the file
     pointer relative to the end of the file.

     See also: SEEK_SET, SEEK_CUR.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
Return the numerical value to pass to 'fseek' to position the file  pointer relative to the end of the file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
stdin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 248
 -- Built-in Function: stdin ()
     Return the numeric value corresponding to the standard input
     stream.  When Octave is used interactively, this is filtered
     through the command line editing functions.

     See also: stdout, stderr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Return the numeric value corresponding to the standard input  stream.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
stdout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 229
 -- Built-in Function: stdout ()
     Return the numeric value corresponding to the standard output
     stream.  Data written to the standard output is normally filtered
     through the pager.

     See also: stdin, stderr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Return the numeric value corresponding to the standard output  stream.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
stderr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 272
 -- Built-in Function: stderr ()
     Return the numeric value corresponding to the standard error
     stream.  Even if paging is turned on, the standard error is not
     sent to the pager.  It is useful for error messages and prompts.

     See also: stdin, stdout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Return the numeric value corresponding to the standard error  stream.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
filter


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1611
 -- Built-in Function: y = filter (B, A, X)
 -- Built-in Function: [Y, SF] = filter (B, A, X, SI)
 -- Built-in Function: [Y, SF] = filter (B, A, X, [], DIM)
 -- Built-in Function: [Y, SF] = filter (B, A, X, SI, DIM)
     Return the solution to the following linear, time-invariant
     difference equation:

           N                   M
          SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)    for 1<=n<=length(x)
          k=0                 k=0

     where N=length(a)-1 and M=length(b)-1.  The result is calculated
     over the first non-singleton dimension of X or over DIM if
     supplied.

     An equivalent form of the equation is:

                    N                   M
          y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1<=n<=length(x)
                   k=1                 k=0

     where c = a/a(1) and d = b/a(1).

     If the fourth argument SI is provided, it is taken as the initial
     state of the system and the final state is returned as SF.  The
     state vector is a column vector whose length is equal to the length
     of the longest coefficient vector minus one.  If SI is not
     supplied, the initial state vector is set to all zeros.

     In terms of the Z Transform, y is the result of passing the
     discrete- time signal x through a system characterized by the
     following rational system function:

                    M
                   SUM d(k+1) z^(-k)
                   k=0
          H(z) = ---------------------
                      N
                 1 + SUM c(k+1) z^(-k)
                     k=1

     See also: filter2, fftfilt, freqz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 82
Return the solution to the following linear, time-invariant  difference equation: 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
find


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1737
 -- Built-in Function: IDX = find (X)
 -- Built-in Function: IDX = find (X, N)
 -- Built-in Function: IDX = find (X, N, DIRECTION)
 -- Built-in Function: [i, j] = find (...)
 -- Built-in Function: [i, j, v] = find (...)
     Return a vector of indices of nonzero elements of a matrix, as a
     row if X is a row vector or as a column otherwise.  To obtain a
     single index for each matrix element, Octave pretends that the
     columns of a matrix form one long vector (like Fortran arrays are
     stored).  For example:

          find (eye (2))
            => [ 1; 4 ]

     If two outputs are requested, 'find' returns the row and column
     indices of nonzero elements of a matrix.  For example:

          [i, j] = find (2 * eye (2))
              => i = [ 1; 2 ]
              => j = [ 1; 2 ]

     If three outputs are requested, 'find' also returns a vector
     containing the nonzero values.  For example:

          [i, j, v] = find (3 * eye (2))
                 => i = [ 1; 2 ]
                 => j = [ 1; 2 ]
                 => v = [ 3; 3 ]

     If two inputs are given, N indicates the maximum number of elements
     to find from the beginning of the matrix or vector.

     If three inputs are given, DIRECTION should be one of "first" or
     "last", requesting only the first or last N indices, respectively.
     However, the indices are always returned in ascending order.

     Note that this function is particularly useful for sparse matrices,
     as it extracts the non-zero elements as vectors, which can then be
     used to create the original matrix.  For example:

          sz = size (a);
          [i, j, v] = find (a);
          b = sparse (i, j, v, sz(1), sz(2));

     See also: nonzeros.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
Return a vector of indices of nonzero elements of a matrix, as a  row if X is a row vector or as a column otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
gammainc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1094
 -- Mapping Function: gammainc (X, A)
 -- Mapping Function: gammainc (X, A, "lower")
 -- Mapping Function: gammainc (X, A, "upper")
     Compute the normalized incomplete gamma function,

                                          x
                                 1       /
          gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
                            gamma (a)    /
                                      t=0

     with the limiting value of 1 as X approaches infinity.  The
     standard notation is P(a,x), e.g., Abramowitz and Stegun (6.5.1).

     If A is scalar, then 'gammainc (X, A)' is returned for each element
     of X and vice versa.

     If neither X nor A is scalar, the sizes of X and A must agree, and
     'gammainc' is applied element-by-element.

     By default the incomplete gamma function integrated from 0 to X is
     computed.  If "upper" is given then the complementary function
     integrated from X to infinity is calculated.  It should be noted
     that

          gammainc (X, A) == 1 - gammainc (X, A, "upper")

     See also: gamma, lgamma.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute the normalized incomplete gamma function, 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
gcd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 838
 -- Built-in Function: G = gcd (A1, A2, ...)
 -- Built-in Function: [G, V1, ...] = gcd (A1, A2, ...)

     Compute the greatest common divisor of A1, A2, ....  If more than
     one argument is given all arguments must be the same size or
     scalar.  In this case the greatest common divisor is calculated for
     each element individually.  All elements must be ordinary or
     Gaussian (complex) integers.  Note that for Gaussian integers, the
     gcd is not unique up to units (multiplication by 1, -1, I or -I),
     so an arbitrary greatest common divisor amongst four possible is
     returned.

     Example code:

          gcd ([15, 9], [20, 18])
             =>  5  9

     Optional return arguments V1, etc., contain integer vectors such
     that,

          G = V1 .* A1 + V2 .* A2 + ...

     See also: lcm, factor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Compute the greatest common divisor of A1, A2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getgrent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 188
 -- Built-in Function: GRP_STRUCT = getgrent ()
     Return an entry from the group database, opening it if necessary.
     Once the end of data has been reached, 'getgrent' returns 0.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return an entry from the group database, opening it if necessary.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getgrgid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 211
 -- Built-in Function: GRP_STRUCT = getgrgid (GID).
     Return the first entry from the group database with the group ID
     GID.  If the group ID does not exist in the database, 'getgrgid'
     returns 0.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Return the first entry from the group database with the group ID  GID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getgrnam


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 216
 -- Built-in Function: GRP_STRUCT = getgrnam (NAME)
     Return the first entry from the group database with the group name
     NAME.  If the group name does not exist in the database, 'getgrnam'
     returns 0.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Return the first entry from the group database with the group name  NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
setgrent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
 -- Built-in Function: setgrent ()
     Return the internal pointer to the beginning of the group database.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Return the internal pointer to the beginning of the group database.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
endgrent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
 -- Built-in Function: endgrent ()
     Close the group database.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Close the group database.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getpwent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 223
 -- Built-in Function: PW_STRUCT = getpwent ()
     Return a structure containing an entry from the password database,
     opening it if necessary.  Once the end of the data has been
     reached, 'getpwent' returns 0.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
Return a structure containing an entry from the password database,  opening it if necessary.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getpwuid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 234
 -- Built-in Function: PW_STRUCT = getpwuid (UID).
     Return a structure containing the first entry from the password
     database with the user ID UID.  If the user ID does not exist in
     the database, 'getpwuid' returns 0.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Return a structure containing the first entry from the password  database with the user ID UID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getpwnam


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 240
 -- Built-in Function: PW_STRUCT = getpwnam (NAME)
     Return a structure containing the first entry from the password
     database with the user name NAME.  If the user name does not exist
     in the database, 'getpwname' returns 0.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Return a structure containing the first entry from the password  database with the user name NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
setpwent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 119
 -- Built-in Function: setpwent ()
     Return the internal pointer to the beginning of the password
     database.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Return the internal pointer to the beginning of the password  database.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
endpwent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
 -- Built-in Function: endpwent ()
     Close the password database.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Close the password database.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
getrusage


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1407
 -- Built-in Function: getrusage ()
     Return a structure containing a number of statistics about the
     current Octave process.  Not all fields are available on all
     systems.  If it is not possible to get CPU time statistics, the CPU
     time slots are set to zero.  Other missing data are replaced by
     NaN.  The list of possible fields is:

     'idrss'
          Unshared data size.

     'inblock'
          Number of block input operations.

     'isrss'
          Unshared stack size.

     'ixrss'
          Shared memory size.

     'majflt'
          Number of major page faults.

     'maxrss'
          Maximum data size.

     'minflt'
          Number of minor page faults.

     'msgrcv'
          Number of messages received.

     'msgsnd'
          Number of messages sent.

     'nivcsw'
          Number of involuntary context switches.

     'nsignals'
          Number of signals received.

     'nswap'
          Number of swaps.

     'nvcsw'
          Number of voluntary context switches.

     'oublock'
          Number of block output operations.

     'stime'
          A structure containing the system CPU time used.  The
          structure has the elements 'sec' (seconds) 'usec'
          (microseconds).

     'utime'
          A structure containing the user CPU time used.  The structure
          has the elements 'sec' (seconds) 'usec' (microseconds).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Return a structure containing a number of statistics about the  current Octave process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
givens


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 321
 -- Built-in Function: G = givens (X, Y)
 -- Built-in Function: [C, S] = givens (X, Y)
     Return a 2 by 2 orthogonal matrix 'G = [C S; -S' C]' such that 'G
     [X; Y] = [*; 0]' with X and Y scalars.

     For example:

          givens (1, 1)
             =>   0.70711   0.70711
                 -0.70711   0.70711
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
Return a 2 by 2 orthogonal matrix 'G = [C S; -S' C]' such that 'G  [X; Y] = [*; 0]' with X and Y scalars.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ishandle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 317
 -- Built-in Function: ishandle (H)
     Return true if H is a graphics handle and false otherwise.

     H may also be a matrix of handles in which case a logical array is
     returned that is true where the elements of H are graphics handles
     and false where they are not.

     See also: isaxes, isfigure.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Return true if H is a graphics handle and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
reset


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 293
 -- Built-in Function: reset (H, PROPERTY)
     Remove any defaults set for the handle H.  The default figure
     properties of "position", "units", "windowstyle" and "paperunits"
     and the default axes properties of "position" and "units" are not
     reset.

     See also: cla, clf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Remove any defaults set for the handle H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
set


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1508
 -- Built-in Function: set (H, PROPERTY, VALUE, ...)
 -- Built-in Function: set (H, PROPERTIES, VALUES)
 -- Built-in Function: set (H, PV)
     Set named property values for the graphics handle (or vector of
     graphics handles) H.  There are three ways how to give the property
     names and values:

        * as a comma separated list of PROPERTY, VALUE pairs

          Here, each PROPERTY is a string containing the property name,
          each VALUE is a value of the appropriate type for the
          property.

        * as a cell array of strings PROPERTIES containing property
          names and a cell array VALUES containing property values.

          In this case, the number of columns of VALUES must match the
          number of elements in PROPERTIES.  The first column of VALUES
          contains values for the first entry in PROPERTIES, etc.  The
          number of rows of VALUES must be 1 or match the number of
          elements of H.  In the first case, each handle in H will be
          assigned the same values.  In the latter case, the first
          handle in H will be assigned the values from the first row of
          VALUES and so on.

        * as a structure array PV

          Here, the field names of PV represent the property names, and
          the field values give the property values.  In contrast to the
          previous case, all elements of PV will be set in all handles
          in H independent of the dimensions of PV.

     See also: get.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
Set named property values for the graphics handle (or vector of  graphics handles) H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
get


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 341
 -- Built-in Function: VAL = get (H)
 -- Built-in Function: VAL = get (H, P)
     Return the value of the named property P from the graphics handle
     H.  If P is omitted, return the complete property list for H.  If H
     is a vector, return a cell array including the property values or
     lists respectively.

     See also: set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Return the value of the named property P from the graphics handle  H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
available_graphics_toolkits


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 176
 -- Built-in Function: available_graphics_toolkits ()
     Return a cell array of registered graphics toolkits.

     See also: graphics_toolkit, register_graphics_toolkit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return a cell array of registered graphics toolkits.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
register_graphics_toolkit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 159
 -- Built-in Function: register_graphics_toolkit (TOOLKIT)
     List TOOLKIT as an available graphics toolkit.

     See also: available_graphics_toolkits.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
List TOOLKIT as an available graphics toolkit.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
loaded_graphics_toolkits


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 167
 -- Built-in Function: loaded_graphics_toolkits ()
     Return a cell array of the currently loaded graphics toolkits.

     See also: available_graphics_toolkits.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return a cell array of the currently loaded graphics toolkits.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
drawnow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 472
 -- Built-in Function: drawnow ()
 -- Built-in Function: drawnow ("expose")
 -- Built-in Function: drawnow (TERM, FILE, MONO, DEBUG_FILE)
     Update figure windows and their children.  The event queue is
     flushed and any callbacks generated are executed.  With the
     optional argument "expose", only graphic objects are updated and no
     other events or callbacks are processed.  The third calling form of
     'drawnow' is for debugging and is undocumented.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Update figure windows and their children.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
addlistener


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1178
 -- Built-in Function: addlistener (H, PROP, FCN)
     Register FCN as listener for the property PROP of the graphics
     object H.  Property listeners are executed (in order of
     registration) when the property is set.  The new value is already
     available when the listeners are executed.

     PROP must be a string naming a valid property in H.

     FCN can be a function handle, a string or a cell array whose first
     element is a function handle.  If FCN is a function handle, the
     corresponding function should accept at least 2 arguments, that
     will be set to the object handle and the empty matrix respectively.
     If FCN is a string, it must be any valid octave expression.  If FCN
     is a cell array, the first element must be a function handle with
     the same signature as described above.  The next elements of the
     cell array are passed as additional arguments to the function.

     Example:

          function my_listener (h, dummy, p1)
            fprintf ("my_listener called with p1=%s\n", p1);
          endfunction

          addlistener (gcf, "position", {@my_listener, "my string"})

     See also: addproperty, hggroup.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Register FCN as listener for the property PROP of the graphics  object H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
dellistener


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 650
 -- Built-in Function: dellistener (H, PROP, FCN)
     Remove the registration of FCN as a listener for the property PROP
     of the graphics object H.  The function FCN must be the same
     variable (not just the same value), as was passed to the original
     call to 'addlistener'.

     If FCN is not defined then all listener functions of PROP are
     removed.

     Example:

          function my_listener (h, dummy, p1)
            fprintf ("my_listener called with p1=%s\n", p1);
          endfunction

          c = {@my_listener, "my string"};
          addlistener (gcf, "position", c);
          dellistener (gcf, "position", c);

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Remove the registration of FCN as a listener for the property PROP  of the graphics object H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
addproperty


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2633
 -- Built-in Function: addproperty (NAME, H, TYPE)
 -- Built-in Function: addproperty (NAME, H, TYPE, ARG, ...)
     Create a new property named NAME in graphics object H.  TYPE
     determines the type of the property to create.  ARGS usually
     contains the default value of the property, but additional
     arguments might be given, depending on the type of the property.

     The supported property types are:

     'string'
          A string property.  ARG contains the default string value.

     'any'
          An un-typed property.  This kind of property can hold any
          octave value.  ARGS contains the default value.

     'radio'
          A string property with a limited set of accepted values.  The
          first argument must be a string with all accepted values
          separated by a vertical bar ('|').  The default value can be
          marked by enclosing it with a '{' '}' pair.  The default value
          may also be given as an optional second string argument.

     'boolean'
          A boolean property.  This property type is equivalent to a
          radio property with "on|off" as accepted values.  ARG contains
          the default property value.

     'double'
          A scalar double property.  ARG contains the default value.

     'handle'
          A handle property.  This kind of property holds the handle of
          a graphics object.  ARG contains the default handle value.
          When no default value is given, the property is initialized to
          the empty matrix.

     'data'
          A data (matrix) property.  ARG contains the default data
          value.  When no default value is given, the data is
          initialized to the empty matrix.

     'color'
          A color property.  ARG contains the default color value.  When
          no default color is given, the property is set to black.  An
          optional second string argument may be given to specify an
          additional set of accepted string values (like a radio
          property).

     TYPE may also be the concatenation of a core object type and a
     valid property name for that object type.  The property created
     then has the same characteristics as the referenced property (type,
     possible values, hidden state...).  This allows to clone an
     existing property into the graphics object H.

     Examples:

          addproperty ("my_property", gcf, "string", "a string value");
          addproperty ("my_radio", gcf, "radio", "val_1|val_2|{val_3}");
          addproperty ("my_style", gcf, "linelinestyle", "--");

     See also: addlistener, hggroup.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Create a new property named NAME in graphics object H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
waitfor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1938
 -- Built-in Function: waitfor (H)
 -- Built-in Function: waitfor (H, PROP)
 -- Built-in Function: waitfor (H, PROP, VALUE)
 -- Built-in Function: waitfor (..., "timeout", TIMEOUT)
     Suspend the execution of the current program until a condition is
     satisfied on the graphics handle H.

     While the program is suspended graphics events are still being
     processed normally, allowing callbacks to modify the state of
     graphics objects.  This function is reentrant and can be called
     from a callback, while another 'waitfor' call is pending at the
     top-level.

     In the first form, program execution is suspended until the
     graphics object H is destroyed.  If the graphics handle is invalid,
     the function returns immediately.

     In the second form, execution is suspended until the graphics
     object is destroyed or the property named PROP is modified.  If the
     graphics handle is invalid or the property does not exist, the
     function returns immediately.

     In the third form, execution is suspended until the graphics object
     is destroyed or the property named PROP is set to VALUE.  The
     function 'isequal' is used to compare property values.  If the
     graphics handle is invalid, the property does not exist or the
     property is already set to VALUE, the function returns immediately.

     An optional timeout can be specified using the property 'timeout'.
     This timeout value is the number of seconds to wait for the
     condition to be true.  TIMEOUT must be at least 1.  If a smaller
     value is specified, a warning is issued and a value of 1 is used
     instead.  If the timeout value is not an integer, it is truncated
     towards 0.

     To define a condition on a property named 'timeout', use the string
     '\timeout' instead.

     In all cases, typing CTRL-C stops program execution immediately.

     See also: waitforbuttonpress, isequal.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
Suspend the execution of the current program until a condition is  satisfied on the graphics handle H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
built_in_docstrings_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 879
 -- Built-in Function: VAL = built_in_docstrings_file ()
 -- Built-in Function: OLD_VAL = built_in_docstrings_file (NEW_VAL)
 -- Built-in Function: built_in_docstrings_file (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the
     file containing docstrings for built-in Octave functions.  The
     default value is
     'OCTAVE-HOME/share/octave/VERSION/etc/built-in-docstrings', in
     which OCTAVE-HOME is the root directory of the Octave installation,
     and VERSION is the Octave version number.  The default value may be
     overridden by the environment variable
     'OCTAVE_BUILT_IN_DOCSTRINGS_FILE', or the command line argument
     '--built-in-docstrings-file FNAME'.

     Note: This variable is only used when Octave is initializing
     itself.  Modifying it during a running session of Octave will have
     no effect.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
Query or set the internal variable that specifies the name of the  file containing docstrings for built-in Octave functions.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
get_help_text


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 266
 -- Built-in Function: [TEXT, FORMAT] = get_help_text (NAME)
     Return the raw help text of function NAME.

     The raw help text is returned in TEXT and the format in FORMAT The
     format is a string which is one of "texinfo", "html", or "plain
     text".
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Return the raw help text of function NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
get_help_text_from_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 280
 -- Built-in Function: [TEXT, FORMAT] = get_help_text_from_file (FNAME)
     Return the raw help text from the file FNAME.

     The raw help text is returned in TEXT and the format in FORMAT The
     format is a string which is one of "texinfo", "html", or "plain
     text".
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Return the raw help text from the file FNAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
doc_cache_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1032
 -- Built-in Function: VAL = doc_cache_file ()
 -- Built-in Function: OLD_VAL = doc_cache_file (NEW_VAL)
 -- Built-in Function: doc_cache_file (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the
     Octave documentation cache file.  A cache file significantly
     improves the performance of the 'lookfor' command.  The default
     value is 'OCTAVE-HOME/share/octave/VERSION/etc/doc-cache', in which
     OCTAVE-HOME is the root directory of the Octave installation, and
     VERSION is the Octave version number.  The default value may be
     overridden by the environment variable 'OCTAVE_DOC_CACHE_FILE', or
     the command line argument '--doc-cache-file FNAME'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: doc_cache_create, lookfor, info_program, doc, help,
     makeinfo_program.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
Query or set the internal variable that specifies the name of the  Octave documentation cache file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
texi_macros_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 986
 -- Built-in Function: VAL = texi_macros_file ()
 -- Built-in Function: OLD_VAL = texi_macros_file (NEW_VAL)
 -- Built-in Function: texi_macros_file (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the
     file containing Texinfo macros that are prepended to documentation
     strings before they are passed to makeinfo.  The default value is
     'OCTAVE-HOME/share/octave/VERSION/etc/macros.texi', in which
     OCTAVE-HOME is the root directory of the Octave installation, and
     VERSION is the Octave version number.  The default value may be
     overridden by the environment variable 'OCTAVE_TEXI_MACROS_FILE',
     or the command line argument '--texi-macros-file FNAME'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: makeinfo_program.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 178
Query or set the internal variable that specifies the name of the  file containing Texinfo macros that are prepended to documentation  strings before they are passed to makeinfo.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
info_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 811
 -- Built-in Function: VAL = info_file ()
 -- Built-in Function: OLD_VAL = info_file (NEW_VAL)
 -- Built-in Function: info_file (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the
     Octave info file.  The default value is
     'OCTAVE-HOME/info/octave.info', in which OCTAVE-HOME is the root
     directory of the Octave installation.  The default value may be
     overridden by the environment variable 'OCTAVE_INFO_FILE', or the
     command line argument '--info-file FNAME'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: info_program, doc, help, makeinfo_program.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Query or set the internal variable that specifies the name of the  Octave info file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
info_program


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 957
 -- Built-in Function: VAL = info_program ()
 -- Built-in Function: OLD_VAL = info_program (NEW_VAL)
 -- Built-in Function: info_program (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the
     info program to run.  The default value is
     'OCTAVE-HOME/libexec/octave/VERSION/exec/ARCH/info' in which
     OCTAVE-HOME is the root directory of the Octave installation,
     VERSION is the Octave version number, and ARCH is the system type
     (for example, 'i686-pc-linux-gnu').  The default value may be
     overridden by the environment variable 'OCTAVE_INFO_PROGRAM', or
     the command line argument '--info-program NAME'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: info_file, doc, help, makeinfo_program.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Query or set the internal variable that specifies the name of the  info program to run.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
makeinfo_program


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 665
 -- Built-in Function: VAL = makeinfo_program ()
 -- Built-in Function: OLD_VAL = makeinfo_program (NEW_VAL)
 -- Built-in Function: makeinfo_program (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the
     program that Octave runs to format help text containing Texinfo
     markup commands.  The default value is 'makeinfo'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: texi_macros_file, info_file, info_program, doc, help.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 148
Query or set the internal variable that specifies the name of the  program that Octave runs to format help text containing Texinfo  markup commands.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
suppress_verbose_help_message


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 645
 -- Built-in Function: VAL = suppress_verbose_help_message ()
 -- Built-in Function: OLD_VAL = suppress_verbose_help_message (NEW_VAL)
 -- Built-in Function: suppress_verbose_help_message (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     will add additional help information to the end of the output from
     the 'help' command and usage messages for built-in commands.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 193
Query or set the internal variable that controls whether Octave  will add additional help information to the end of the output from  the 'help' command and usage messages for built-in commands.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
hess


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 636
 -- Built-in Function: H = hess (A)
 -- Built-in Function: [P, H] = hess (A)
     Compute the Hessenberg decomposition of the matrix A.

     The Hessenberg decomposition is 'P * H * P' = A' where P is a
     square unitary matrix ('P' * P = I', using complex-conjugate
     transposition) and H is upper Hessenberg ('H(i, j) = 0 forall i >=
     j+1)'.

     The Hessenberg decomposition is usually used as the first step in
     an eigenvalue computation, but has other applications as well (see
     Golub, Nash, and Van Loan, IEEE Transactions on Automatic Control,
     1979).

     See also: eig, chol, lu, qr, qz, schur, svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute the Hessenberg decomposition of the matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hex2num


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 843
 -- Built-in Function: N = hex2num (S)
 -- Built-in Function: N = hex2num (S, CLASS)
     Typecast the 16 character hexadecimal character string to an IEEE
     754 double precision number.  If fewer than 16 characters are given
     the strings are right padded with '0' characters.

     Given a string matrix, 'hex2num' treats each row as a separate
     number.

          hex2num (["4005bf0a8b145769"; "4024000000000000"])
             => [2.7183; 10.000]

     The optional argument CLASS can be passed as the string "single" to
     specify that the given string should be interpreted as a single
     precision number.  In this case, S should be an 8 character
     hexadecimal string.  For example:

          hex2num (["402df854"; "41200000"], "single")
             => [2.7183; 10.000]

     See also: num2hex, hex2dec, dec2hex.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Typecast the 16 character hexadecimal character string to an IEEE  754 double precision number.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
num2hex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 680
 -- Built-in Function: S = num2hex (N)
     Typecast a double or single precision number or vector to a 8 or 16
     character hexadecimal string of the IEEE 754 representation of the
     number.  For example:

          num2hex ([-1, 1, e, Inf])
          => "bff0000000000000
              3ff0000000000000
              4005bf0a8b145769
              7ff0000000000000"

     If the argument N is a single precision number or vector, the
     returned string has a length of 8.  For example:

          num2hex (single ([-1, 1, e, Inf]))
          => "bf800000
              3f800000
              402df854
              7f800000"

     See also: hex2num, hex2dec, dec2hex.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 144
Typecast a double or single precision number or vector to a 8 or 16  character hexadecimal string of the IEEE 754 representation of the  number.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
input


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1167
 -- Built-in Function: ANS = input (PROMPT)
 -- Built-in Function: ANS = input (PROMPT, "s")
     Print PROMPT and wait for user input.

     For example,

          input ("Pick a number, any number! ")

     prints the prompt

          Pick a number, any number!

     and waits for the user to enter a value.  The string entered by the
     user is evaluated as an expression, so it may be a literal
     constant, a variable name, or any other valid expression.

     Currently, 'input' only returns one value, regardless of the number
     of values produced by the evaluation of the expression.

     If you are only interested in getting a literal string value, you
     can call 'input' with the character string "s" as the second
     argument.  This tells Octave to return the string entered by the
     user directly, without evaluating it first.

     Because there may be output waiting to be displayed by the pager,
     it is a good idea to always call 'fflush (stdout)' before calling
     'input'.  This will ensure that all pending output is written to
     the screen before your prompt.

     See also: yes_or_no, kbhit, pause, menu, listdlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Print PROMPT and wait for user input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
yes_or_no


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 475
 -- Built-in Function: ANS = yes_or_no ("PROMPT")
     Ask the user a yes-or-no question.

     Return logical true if the answer is yes or false if the answer is
     no.  Takes one argument, PROMPT, which is the string to display
     when asking the question.  PROMPT should end in a space;
     'yes-or-no' adds the string '(yes or no) ' to it.  The user must
     confirm the answer with <RET> and can edit it until it has been
     confirmed.

     See also: input.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Ask the user a yes-or-no question.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
keyboard


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 720
 -- Built-in Function: keyboard ()
 -- Built-in Function: keyboard ("PROMPT")
     This function is normally used for simple debugging.  When the
     'keyboard' function is executed, Octave prints a prompt and waits
     for user input.  The input strings are then evaluated and the
     results are printed.  This makes it possible to examine the values
     of variables within a function, and to assign new values if
     necessary.  To leave the prompt and return to normal execution type
     'return' or 'dbcont'.  The 'keyboard' function does not return an
     exit status.

     If 'keyboard' is invoked without arguments, a default prompt of
     'debug> ' is used.

     See also: dbstop, dbcont, dbquit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
This function is normally used for simple debugging.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
echo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 608
 -- Command: echo options
     Control whether commands are displayed as they are executed.  Valid
     options are:

     'on'
          Enable echoing of commands as they are executed in script
          files.

     'off'
          Disable echoing of commands as they are executed in script
          files.

     'on all'
          Enable echoing of commands as they are executed in script
          files and functions.

     'off all'
          Disable echoing of commands as they are executed in script
          files and functions.

     With no arguments, 'echo' toggles the current echo state.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Control whether commands are displayed as they are executed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
completion_matches


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 352
 -- Built-in Function: completion_matches (HINT)
     Generate possible completions given HINT.

     This function is provided for the benefit of programs like Emacs
     which might be controlling Octave and handling user input.  The
     current command number is not incremented when this function is
     called.  This is a feature, not a bug.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Generate possible completions given HINT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
readline_read_init_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 308
 -- Built-in Function: readline_read_init_file (FILE)
     Read the readline library initialization file FILE.  If FILE is
     omitted, read the default initialization file (normally
     '~/.inputrc').

     *Note (readline)Readline Init File::, for details.

     See also: readline_re_read_init_file.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Read the readline library initialization file FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
readline_re_read_init_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 228
 -- Built-in Function: readline_re_read_init_file ()
     Re-read the last readline library initialization file that was
     read.  *Note (readline)Readline Init File::, for details.

     See also: readline_read_init_file.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Re-read the last readline library initialization file that was  read.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
add_input_event_hook


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 553
 -- Built-in Function: ID = add_input_event_hook (FCN)
 -- Built-in Function: ID = add_input_event_hook (FCN, DATA)
     Add the named function or function handle FCN to the list of
     functions to call periodically when Octave is waiting for input.
     The function should have the form

          FCN (DATA)

     If DATA is omitted, Octave calls the function without any
     arguments.

     The returned identifier may be used to remove the function handle
     from the list of input hook functions.

     See also: remove_input_event_hook.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
Add the named function or function handle FCN to the list of  functions to call periodically when Octave is waiting for input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
remove_input_event_hook


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 319
 -- Built-in Function: remove_input_event_hook (NAME)
 -- Built-in Function: remove_input_event_hook (FCN_ID)
     Remove the named function or function handle with the given
     identifier from the list of functions to call periodically when
     Octave is waiting for input.

     See also: add_input_event_hook.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 154
Remove the named function or function handle with the given  identifier from the list of functions to call periodically when  Octave is waiting for input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
PS1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1191
 -- Built-in Function: VAL = PS1 ()
 -- Built-in Function: OLD_VAL = PS1 (NEW_VAL)
 -- Built-in Function: PS1 (NEW_VAL, "local")
     Query or set the primary prompt string.  When executing
     interactively, Octave displays the primary prompt when it is ready
     to read a command.

     The default value of the primary prompt string is "octave:\#> ".
     To change it, use a command like

          PS1 ("\\u@\\H> ")

     which will result in the prompt 'boris@kremvax> ' for the user
     'boris' logged in on the host 'kremvax.kgb.su'.  Note that two
     backslashes are required to enter a backslash into a double-quoted
     character string.  *Note Strings::.

     You can also use ANSI escape sequences if your terminal supports
     them.  This can be useful for coloring the prompt.  For example,

          PS1 ("\\[\\033[01;31m\\]\\s:\\#> \\[\\033[0m\\]")

     will give the default Octave prompt a red coloring.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: PS2, PS4.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Query or set the primary prompt string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
PS2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 772
 -- Built-in Function: VAL = PS2 ()
 -- Built-in Function: OLD_VAL = PS2 (NEW_VAL)
 -- Built-in Function: PS2 (NEW_VAL, "local")
     Query or set the secondary prompt string.  The secondary prompt is
     printed when Octave is expecting additional input to complete a
     command.  For example, if you are typing a 'for' loop that spans
     several lines, Octave will print the secondary prompt at the
     beginning of each line after the first.  The default value of the
     secondary prompt string is "> ".

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: PS1, PS4.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Query or set the secondary prompt string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
PS4


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 636
 -- Built-in Function: VAL = PS4 ()
 -- Built-in Function: OLD_VAL = PS4 (NEW_VAL)
 -- Built-in Function: PS4 (NEW_VAL, "local")
     Query or set the character string used to prefix output produced
     when echoing commands is enabled.  The default value is "+ ".
     *Note Diary and Echo Commands::, for a description of echoing
     commands.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: echo, echo_executing_commands, PS1, PS2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
Query or set the character string used to prefix output produced  when echoing commands is enabled.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
completion_append_char


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 586
 -- Built-in Function: VAL = completion_append_char ()
 -- Built-in Function: OLD_VAL = completion_append_char (NEW_VAL)
 -- Built-in Function: completion_append_char (NEW_VAL, "local")
     Query or set the internal character variable that is appended to
     successful command-line completion attempts.  The default value is
     " " (a single space).

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
Query or set the internal character variable that is appended to  successful command-line completion attempts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
echo_executing_commands


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 952
 -- Built-in Function: VAL = echo_executing_commands ()
 -- Built-in Function: OLD_VAL = echo_executing_commands (NEW_VAL)
 -- Built-in Function: echo_executing_commands (NEW_VAL, "local")
     Query or set the internal variable that controls the echo state.
     It may be the sum of the following values:

     1
          Echo commands read from script files.

     2
          Echo commands from functions.

     4
          Echo commands read from command line.

     More than one state can be active at once.  For example, a value of
     3 is equivalent to the command 'echo on all'.

     The value of 'echo_executing_commands' may be set by the 'echo'
     command or the command line option '--echo-commands'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Query or set the internal variable that controls the echo state.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
filemarker


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1012
 -- Built-in Function: VAL = filemarker ()
 -- Built-in Function: filemarker (NEW_VAL)
 -- Built-in Function: filemarker (NEW_VAL, "local")
     Query or set the character used to separate filename from the the
     subfunction names contained within the file.  This can be used in a
     generic manner to interact with subfunctions.  For example,

          help (["myfunc", filemarker, "mysubfunc"])

     returns the help string associated with the subfunction 'mysubfunc'
     of the function 'myfunc'.  Another use of 'filemarker' is when
     debugging it allows easier placement of breakpoints within
     subfunctions.  For example,

          dbstop (["myfunc", filemarker, "mysubfunc"])

     will set a breakpoint at the first line of the subfunction
     'mysubfunc'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
Query or set the character used to separate filename from the the  subfunction names contained within the file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
inv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 755
 -- Built-in Function: X = inv (A)
 -- Built-in Function: [X, RCOND] = inv (A)
     Compute the inverse of the square matrix A.  Return an estimate of
     the reciprocal condition number if requested, otherwise warn of an
     ill-conditioned matrix if the reciprocal condition number is small.

     In general it is best to avoid calculating the inverse of a matrix
     directly.  For example, it is both faster and more accurate to
     solve systems of equations (A*x = b) with 'Y = A \ b', rather than
     'Y = inv (A) * b'.

     If called with a sparse matrix, then in general X will be a full
     matrix requiring significantly more storage.  Avoid forming the
     inverse of a sparse matrix if possible.

     See also: ldivide, rdivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Compute the inverse of the square matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
inverse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 194
 -- Built-in Function: X = inverse (A)
 -- Built-in Function: [X, RCOND] = inverse (A)
     Compute the inverse of the square matrix A.

     This is an alias for 'inv'.

     See also: inv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Compute the inverse of the square matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
kron


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 560
 -- Built-in Function: kron (A, B)
 -- Built-in Function: kron (A1, A2, ...)
     Form the Kronecker product of two or more matrices, defined block
     by block as

          x = [ a(i,j)*b ]

     For example:

          kron (1:4, ones (3, 1))
               =>  1  2  3  4
                   1  2  3  4
                   1  2  3  4

     If there are more than two input arguments A1, A2, ..., AN the
     Kronecker product is computed as

          kron (kron (A1, A2), ..., AN)

     Since the Kronecker product is associative, this is well-defined.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Form the Kronecker product of two or more matrices, defined block  by block as 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
genpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 272
 -- Built-in Function: genpath (DIR)
 -- Built-in Function: genpath (DIR, SKIP, ...)
     Return a path constructed from DIR and all its subdirectories.  If
     additional string parameters are given, the resulting path will
     exclude directories with those names.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return a path constructed from DIR and all its subdirectories.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rehash


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
 -- Built-in Function: rehash ()
     Reinitialize Octave's load path directory cache.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Reinitialize Octave's load path directory cache.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
command_line_path


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 175
 -- Built-in Function: command_line_path (...)
     Return the command line path variable.

     See also: path, addpath, rmpath, genpath, pathdef, savepath,
     pathsep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return the command line path variable.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
restoredefaultpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 192
 -- Built-in Function: restoredefaultpath (...)
     Restore Octave's path to its initial state at startup.

     See also: path, addpath, rmpath, genpath, pathdef, savepath,
     pathsep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Restore Octave's path to its initial state at startup.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
path


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 571
 -- Built-in Function: path (...)
     Modify or display Octave's load path.

     If NARGIN and NARGOUT are zero, display the elements of Octave's
     load path in an easy to read format.

     If NARGIN is zero and nargout is greater than zero, return the
     current load path.

     If NARGIN is greater than zero, concatenate the arguments,
     separating them with 'pathsep'.  Set the internal search path to
     the result and return it.

     No checks are made for duplicate elements.

     See also: addpath, rmpath, genpath, pathdef, savepath, pathsep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Modify or display Octave's load path.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
addpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 638
 -- Built-in Function: addpath (DIR1, ...)
 -- Built-in Function: addpath (DIR1, ..., OPTION)
     Add named directories to the function search path.  If OPTION is
     "-begin" or 0 (the default), prepend the directory name to the
     current path.  If OPTION is "-end" or 1, append the directory name
     to the current path.  Directories added to the path must exist.

     In addition to accepting individual directory arguments, lists of
     directory names separated by 'pathsep' are also accepted.  For
     example:

          addpath ("dir1:/dir2:~/dir3")

     See also: path, rmpath, genpath, pathdef, savepath, pathsep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Add named directories to the function search path.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rmpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 368
 -- Built-in Function: rmpath (DIR1, ...)
     Remove DIR1, ... from the current function search path.

     In addition to accepting individual directory arguments, lists of
     directory names separated by 'pathsep' are also accepted.  For
     example:

          rmpath ("dir1:/dir2:~/dir3")

     See also: path, addpath, genpath, pathdef, savepath, pathsep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
Remove DIR1, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
load


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3862
 -- Command: load file
 -- Command: load options file
 -- Command: load options file v1 v2 ...
 -- Command: S = load ("options", "file", "v1", "v2", ...)
 -- Command: load file options
 -- Command: load file options v1 v2 ...
 -- Command: S = load ("file", "options", "v1", "v2", ...)
     Load the named variables V1, V2, ..., from the file FILE.  If no
     variables are specified then all variables found in the file will
     be loaded.  As with 'save', the list of variables to extract can be
     full names or use a pattern syntax.  The format of the file is
     automatically detected but may be overridden by supplying the
     appropriate option.

     If load is invoked using the functional form

          load ("-option1", ..., "file", "v1", ...)

     then the OPTIONS, FILE, and variable name arguments (V1, ...) must
     be specified as character strings.

     If a variable that is not marked as global is loaded from a file
     when a global symbol with the same name already exists, it is
     loaded in the global symbol table.  Also, if a variable is marked
     as global in a file and a local symbol exists, the local symbol is
     moved to the global symbol table and given the value from the file.

     If invoked with a single output argument, Octave returns data
     instead of inserting variables in the symbol table.  If the data
     file contains only numbers (TAB- or space-delimited columns), a
     matrix of values is returned.  Otherwise, 'load' returns a
     structure with members corresponding to the names of the variables
     in the file.

     The 'load' command can read data stored in Octave's text and binary
     formats, and MATLAB's binary format.  If compiled with zlib
     support, it can also load gzip-compressed files.  It will
     automatically detect the type of file and do conversion from
     different floating point formats (currently only IEEE big and
     little endian, though other formats may be added in the future).

     Valid options for 'load' are listed in the following table.

     '-force'
          This option is accepted for backward compatibility but is
          ignored.  Octave now overwrites variables currently in memory
          with those of the same name found in the file.

     '-ascii'
          Force Octave to assume the file contains columns of numbers in
          text format without any header or other information.  Data in
          the file will be loaded as a single numeric matrix with the
          name of the variable derived from the name of the file.

     '-binary'
          Force Octave to assume the file is in Octave's binary format.

     '-hdf5'
          Force Octave to assume the file is in HDF5 format.  (HDF5 is a
          free, portable binary format developed by the National Center
          for Supercomputing Applications at the University of
          Illinois.)  Note that Octave can read HDF5 files not created
          by itself, but may skip some datasets in formats that it
          cannot support.  This format is only available if Octave was
          built with a link to the HDF5 libraries.

     '-import'
          This option is accepted for backward compatibility but is
          ignored.  Octave can now support multi-dimensional HDF data
          and automatically modifies variable names if they are invalid
          Octave identifiers.

     '-mat'
     '-mat-binary'
     '-6'
     '-v6'
     '-7'
     '-v7'
          Force Octave to assume the file is in MATLAB's version 6 or 7
          binary format.

     '-mat4-binary'
     '-4'
     '-v4'
     '-V4'
          Force Octave to assume the file is in the binary format
          written by MATLAB version 4.

     '-text'
          Force Octave to assume the file is in Octave's text format.

     See also: save, dlmwrite, csvwrite, fwrite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Load the named variables V1, V2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
save


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4091
 -- Command: save file
 -- Command: save options file
 -- Command: save options file V1 V2 ...
 -- Command: save options file -struct STRUCT F1 F2 ...
     Save the named variables V1, V2, ..., in the file FILE.  The
     special filename '-' may be used to write output to the terminal.
     If no variable names are listed, Octave saves all the variables in
     the current scope.  Otherwise, full variable names or pattern
     syntax can be used to specify the variables to save.  If the
     '-struct' modifier is used, fields F1 F2 ... of the scalar
     structure STRUCT are saved as if they were variables with
     corresponding names.  Valid options for the 'save' command are
     listed in the following table.  Options that modify the output
     format override the format specified by 'save_default_options'.

     If save is invoked using the functional form

          save ("-option1", ..., "file", "v1", ...)

     then the OPTIONS, FILE, and variable name arguments (V1, ...) must
     be specified as character strings.

     '-append'
          Append to the destination instead of overwriting.

     '-ascii'
          Save a single matrix in a text file without header or any
          other information.

     '-binary'
          Save the data in Octave's binary data format.

     '-float-binary'
          Save the data in Octave's binary data format but only using
          single precision.  Only use this format if you know that all
          the values to be saved can be represented in single precision.

     '-hdf5'
          Save the data in HDF5 format.  (HDF5 is a free, portable
          binary format developed by the National Center for
          Supercomputing Applications at the University of Illinois.)
          This format is only available if Octave was built with a link
          to the HDF5 libraries.

     '-float-hdf5'
          Save the data in HDF5 format but only using single precision.
          Only use this format if you know that all the values to be
          saved can be represented in single precision.

     '-V7'
     '-v7'
     '-7'
     '-mat7-binary'
          Save the data in MATLAB's v7 binary data format.

     '-V6'
     '-v6'
     '-6'
     '-mat'
     '-mat-binary'
          Save the data in MATLAB's v6 binary data format.

     '-V4'
     '-v4'
     '-4'
     '-mat4-binary'
          Save the data in the binary format written by MATLAB version
          4.

     '-text'
          Save the data in Octave's text data format.  (default).

     '-zip'
     '-z'
          Use the gzip algorithm to compress the file.  This works
          equally on files that are compressed with gzip outside of
          octave, and gzip can equally be used to convert the files for
          backward compatibility.  This option is only available if
          Octave was built with a link to the zlib libraries.

     The list of variables to save may use wildcard patterns containing
     the following special characters:

     '?'
          Match any single character.

     '*'
          Match zero or more characters.

     '[ LIST ]'
          Match the list of characters specified by LIST.  If the first
          character is '!' or '^', match all characters except those
          specified by LIST.  For example, the pattern '[a-zA-Z]' will
          match all lower and uppercase alphabetic characters.

          Wildcards may also be used in the field name specifications
          when using the '-struct' modifier (but not in the struct name
          itself).

     Except when using the MATLAB binary data file format or the
     '-ascii' format, saving global variables also saves the global
     status of the variable.  If the variable is restored at a later
     time using 'load', it will be restored as a global variable.

     The command

          save -binary data a b*

     saves the variable 'a' and all variables beginning with 'b' to the
     file 'data' in Octave's binary format.

     See also: load, save_default_options, save_header_format_string,
     dlmread, csvread, fread.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Save the named variables V1, V2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
crash_dumps_octave_core


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 725
 -- Built-in Function: VAL = crash_dumps_octave_core ()
 -- Built-in Function: OLD_VAL = crash_dumps_octave_core (NEW_VAL)
 -- Built-in Function: crash_dumps_octave_core (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     tries to save all current variables to the file 'octave-workspace'
     if it crashes or receives a hangup, terminate or similar signal.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: octave_core_file_limit, octave_core_file_name,
     octave_core_file_options.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 197
Query or set the internal variable that controls whether Octave  tries to save all current variables to the file 'octave-workspace'  if it crashes or receives a hangup, terminate or similar signal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
save_default_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 657
 -- Built-in Function: VAL = save_default_options ()
 -- Built-in Function: OLD_VAL = save_default_options (NEW_VAL)
 -- Built-in Function: save_default_options (NEW_VAL, "local")
     Query or set the internal variable that specifies the default
     options for the 'save' command, and defines the default format.
     Typical values include "-ascii", "-text -zip".  The default value
     is '-text'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: save.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
Query or set the internal variable that specifies the default  options for the 'save' command, and defines the default format.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
octave_core_file_limit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1068
 -- Built-in Function: VAL = octave_core_file_limit ()
 -- Built-in Function: OLD_VAL = octave_core_file_limit (NEW_VAL)
 -- Built-in Function: octave_core_file_limit (NEW_VAL, "local")
     Query or set the internal variable that specifies the maximum
     amount of memory (in kilobytes) of the top-level workspace that
     Octave will attempt to save when writing data to the crash dump
     file (the name of the file is specified by OCTAVE_CORE_FILE_NAME).
     If OCTAVE_CORE_FILE_OPTIONS flags specify a binary format, then
     OCTAVE_CORE_FILE_LIMIT will be approximately the maximum size of
     the file.  If a text file format is used, then the file could be
     much larger than the limit.  The default value is -1 (unlimited)

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: crash_dumps_octave_core, octave_core_file_name,
     octave_core_file_options.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 259
Query or set the internal variable that specifies the maximum  amount of memory (in kilobytes) of the top-level workspace that  Octave will attempt to save when writing data to the crash dump  file (the name of the file is specified by OCTAVE_CORE_FILE_NAME).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
octave_core_file_name


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 704
 -- Built-in Function: VAL = octave_core_file_name ()
 -- Built-in Function: OLD_VAL = octave_core_file_name (NEW_VAL)
 -- Built-in Function: octave_core_file_name (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the
     file used for saving data from the top-level workspace if Octave
     aborts.  The default value is "octave-workspace"

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: crash_dumps_octave_core, octave_core_file_name,
     octave_core_file_options.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 140
Query or set the internal variable that specifies the name of the  file used for saving data from the top-level workspace if Octave  aborts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
octave_core_file_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 813
 -- Built-in Function: VAL = octave_core_file_options ()
 -- Built-in Function: OLD_VAL = octave_core_file_options (NEW_VAL)
 -- Built-in Function: octave_core_file_options (NEW_VAL, "local")
     Query or set the internal variable that specifies the options used
     for saving the workspace data if Octave aborts.  The value of
     'octave_core_file_options' should follow the same format as the
     options for the 'save' function.  The default value is Octave's
     binary format.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: crash_dumps_octave_core, octave_core_file_name,
     octave_core_file_limit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
Query or set the internal variable that specifies the options used  for saving the workspace data if Octave aborts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
save_header_format_string


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 998
 -- Built-in Function: VAL = save_header_format_string ()
 -- Built-in Function: OLD_VAL = save_header_format_string (NEW_VAL)
 -- Built-in Function: save_header_format_string (NEW_VAL, "local")
     Query or set the internal variable that specifies the format string
     used for the comment line written at the beginning of text-format
     data files saved by Octave.  The format string is passed to
     'strftime' and should begin with the character '#' and contain no
     newline characters.  If the value of 'save_header_format_string' is
     the empty string, the header comment is omitted from text-format
     data files.  The default value is

          "# Created by Octave VERSION, %a %b %d %H:%M:%S %Y %Z <USER@HOST>"

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: strftime, save.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 163
Query or set the internal variable that specifies the format string  used for the comment line written at the beginning of text-format  data files saved by Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
lookup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1652
 -- Built-in Function: IDX = lookup (TABLE, Y)
 -- Built-in Function: IDX = lookup (TABLE, Y, OPT)
     Lookup values in a sorted table.  Usually used as a prelude to
     interpolation.

     If table is increasing and 'idx = lookup (table, y)', then
     'table(idx(i)) <= y(i) < table(idx(i+1))' for all 'y(i)' within the
     table.  If 'y(i) < table(1)' then 'idx(i)' is 0.  If 'y(i) >=
     table(end)' or 'isnan (y(i))' then 'idx(i)' is 'n'.

     If the table is decreasing, then the tests are reversed.  For
     non-strictly monotonic tables, empty intervals are always skipped.
     The result is undefined if TABLE is not monotonic, or if TABLE
     contains a NaN.

     The complexity of the lookup is O(M*log(N)) where N is the size of
     TABLE and M is the size of Y.  In the special case when Y is also
     sorted, the complexity is O(min(M*log(N),M+N)).

     TABLE and Y can also be cell arrays of strings (or Y can be a
     single string).  In this case, string lookup is performed using
     lexicographical comparison.

     If OPTS is specified, it must be a string with letters indicating
     additional options.

     'm'
          'table(idx(i)) == val(i)' if 'val(i)' occurs in table;
          otherwise, 'idx(i)' is zero.

     'b'
          'idx(i)' is a logical 1 or 0, indicating whether 'val(i)' is
          contained in table or not.

     'l'
          For numeric lookups the leftmost subinterval shall be extended
          to infinity (i.e., all indices at least 1)

     'r'
          For numeric lookups the rightmost subinterval shall be
          extended to infinity (i.e., all indices at most n-1).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Lookup values in a sorted table.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
save_precision


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 515
 -- Built-in Function: VAL = save_precision ()
 -- Built-in Function: OLD_VAL = save_precision (NEW_VAL)
 -- Built-in Function: save_precision (NEW_VAL, "local")
     Query or set the internal variable that specifies the number of
     digits to keep when saving data in text format.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Query or set the internal variable that specifies the number of  digits to keep when saving data in text format.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
lsode_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2183
 -- Built-in Function: lsode_options ()
 -- Built-in Function: val = lsode_options (OPT)
 -- Built-in Function: lsode_options (OPT, VAL)
     Query or set options for the function 'lsode'.  When called with no
     arguments, the names of all available options and their current
     values are displayed.  Given one argument, return the value of the
     corresponding option.  When called with two arguments,
     'lsode_options' set the option OPT to value VAL.

     Options include

     '"absolute tolerance"'
          Absolute tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector.

     '"relative tolerance"'
          Relative tolerance parameter.  Unlike the absolute tolerance,
          this parameter may only be a scalar.

          The local error test applied at each integration step is

                 abs (local error in x(i)) <= ...
                     rtol * abs (y(i)) + atol(i)

     '"integration method"'
          A string specifying the method of integration to use to solve
          the ODE system.  Valid values are

          "adams"
          "non-stiff"
               No Jacobian used (even if it is available).

          "bdf"
          "stiff"
               Use stiff backward differentiation formula (BDF) method.
               If a function to compute the Jacobian is not supplied,
               'lsode' will compute a finite difference approximation of
               the Jacobian matrix.

     '"initial step size"'
          The step size to be attempted on the first step (default is
          determined automatically).

     '"maximum order"'
          Restrict the maximum order of the solution method.  If using
          the Adams method, this option must be between 1 and 12.
          Otherwise, it must be between 1 and 5, inclusive.

     '"maximum step size"'
          Setting the maximum stepsize will avoid passing over very
          large regions (default is not specified).

     '"minimum step size"'
          The minimum absolute step size allowed (default is 0).

     '"step limit"'
          Maximum number of steps allowed (default is 100000).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Query or set options for the function 'lsode'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
lsode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2753
 -- Built-in Function: [X, ISTATE, MSG] = lsode (FCN, X_0, T)
 -- Built-in Function: [X, ISTATE, MSG] = lsode (FCN, X_0, T, T_CRIT)
     Solve the set of differential equations

          dx
          -- = f (x, t)
          dt

     with

          x(t_0) = x_0

     The solution is returned in the matrix X, with each row
     corresponding to an element of the vector T.  The first element of
     T should be t_0 and should correspond to the initial state of the
     system X_0, so that the first row of the output is X_0.

     The first argument, FCN, is a string, inline, or function handle
     that names the function f to call to compute the vector of right
     hand sides for the set of equations.  The function must have the
     form

          XDOT = f (X, T)

     in which XDOT and X are vectors and T is a scalar.

     If FCN is a two-element string array or a two-element cell array of
     strings, inline functions, or function handles, the first element
     names the function f described above, and the second element names
     a function to compute the Jacobian of f.  The Jacobian function
     must have the form

          JAC = j (X, T)

     in which JAC is the matrix of partial derivatives

                       | df_1  df_1       df_1 |
                       | ----  ----  ...  ---- |
                       | dx_1  dx_2       dx_N |
                       |                       |
                       | df_2  df_2       df_2 |
                       | ----  ----  ...  ---- |
                df_i   | dx_1  dx_2       dx_N |
          jac = ---- = |                       |
                dx_j   |  .    .     .    .    |
                       |  .    .      .   .    |
                       |  .    .       .  .    |
                       |                       |
                       | df_N  df_N       df_N |
                       | ----  ----  ...  ---- |
                       | dx_1  dx_2       dx_N |

     The second and third arguments specify the initial state of the
     system, x_0, and the initial value of the independent variable t_0.

     The fourth argument is optional, and may be used to specify a set
     of times that the ODE solver should not integrate past.  It is
     useful for avoiding difficulties with singularities and points
     where there is a discontinuity in the derivative.

     After a successful computation, the value of ISTATE will be 2
     (consistent with the Fortran version of LSODE).

     If the computation is not successful, ISTATE will be something
     other than 2 and MSG will contain additional information.

     You can use the function 'lsode_options' to set optional parameters
     for 'lsode'.

     See also: daspk, dassl, dasrt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Solve the set of differential equations 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
lu


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2599
 -- Built-in Function: [L, U] = lu (A)
 -- Built-in Function: [L, U, P] = lu (A)
 -- Built-in Function: [L, U, P, Q] = lu (S)
 -- Built-in Function: [L, U, P, Q, R] = lu (S)
 -- Built-in Function: [...] = lu (S, THRES)
 -- Built-in Function: Y = lu (...)
 -- Built-in Function: [...] = lu (..., "vector")
     Compute the LU decomposition of A.  If A is full subroutines from
     LAPACK are used and if A is sparse then UMFPACK is used.  The
     result is returned in a permuted form, according to the optional
     return value P.  For example, given the matrix 'a = [1, 2; 3, 4]',

          [l, u, p] = lu (A)

     returns

          l =

            1.00000  0.00000
            0.33333  1.00000

          u =

            3.00000  4.00000
            0.00000  0.66667

          p =

            0  1
            1  0

     The matrix is not required to be square.

     When called with two or three output arguments and a spare input
     matrix, 'lu' does not attempt to perform sparsity preserving column
     permutations.  Called with a fourth output argument, the sparsity
     preserving column transformation Q is returned, such that 'P * A *
     Q = L * U'.

     Called with a fifth output argument and a sparse input matrix, 'lu'
     attempts to use a scaling factor R on the input matrix such that 'P
     * (R \ A) * Q = L * U'.  This typically leads to a sparser and more
     stable factorization.

     An additional input argument THRES, that defines the pivoting
     threshold can be given.  THRES can be a scalar, in which case it
     defines the UMFPACK pivoting tolerance for both symmetric and
     unsymmetric cases.  If THRES is a 2-element vector, then the first
     element defines the pivoting tolerance for the unsymmetric UMFPACK
     pivoting strategy and the second for the symmetric strategy.  By
     default, the values defined by 'spparms' are used ([0.1, 0.001]).

     Given the string argument "vector", 'lu' returns the values of P
     and Q as vector values, such that for full matrix, 'A (P,:) = L *
     U', and 'R(P,:) * A (:, Q) = L * U'.

     With two output arguments, returns the permuted forms of the upper
     and lower triangular matrices, such that 'A = L * U'.  With one
     output argument Y, then the matrix returned by the LAPACK routines
     is returned.  If the input matrix is sparse then the matrix L is
     embedded into U to give a return value similar to the full case.
     For both full and sparse matrices, 'lu' loses the permutation
     information.

     See also: luupdate, chol, hess, qr, qz, schur, svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Compute the LU decomposition of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
luupdate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1231
 -- Built-in Function: [L, U] = luupdate (L, U, X, Y)
 -- Built-in Function: [L, U, P] = luupdate (L, U, P, X, Y)
     Given an LU factorization of a real or complex matrix A = L*U,
     L lower unit trapezoidal and U upper trapezoidal, return the
     LU factorization of A + X*Y.', where X and Y are column vectors
     (rank-1 update) or matrices with equal number of columns (rank-k
     update).  Optionally, row-pivoted updating can be used by supplying
     a row permutation (pivoting) matrix P; in that case, an updated
     permutation matrix is returned.  Note that if L, U, P is a pivoted
     LU factorization as obtained by 'lu':

          [L, U, P] = lu (A);

     then a factorization of A+X*Y.'  can be obtained either as

          [L1, U1] = lu (L, U, P*X, Y)

     or

          [L1, U1, P1] = lu (L, U, P, X, Y)

     The first form uses the unpivoted algorithm, which is faster, but
     less stable.  The second form uses a slower pivoted algorithm,
     which is more stable.

     The matrix case is done as a sequence of rank-1 updates; thus, for
     large enough k, it will be both faster and more accurate to
     recompute the factorization from scratch.

     See also: lu, cholupdate, qrupdate.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 154
Given an LU factorization of a real or complex matrix A = L*U,  L lower unit trapezoidal and U upper trapezoidal, return the  LU factorization of A + X*Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
luinc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2422
 -- Built-in Function: [L, U, P, Q] = luinc (A, '0')
 -- Built-in Function: [L, U, P, Q] = luinc (A, DROPTOL)
 -- Built-in Function: [L, U, P, Q] = luinc (A, OPTS)
     Produce the incomplete LU factorization of the sparse matrix A.
     Two types of incomplete factorization are possible, and the type is
     determined by the second argument to 'luinc'.

     Called with a second argument of '0', the zero-level incomplete
     LU factorization is produced.  This creates a factorization of A
     where the position of the non-zero arguments correspond to the same
     positions as in the matrix A.

     Alternatively, the fill-in of the incomplete LU factorization can
     be controlled through the variable DROPTOL or the structure OPTS.
     The UMFPACK multifrontal factorization code by Tim A. Davis is used
     for the incomplete LU factorization, (availability
     <http://www.cise.ufl.edu/research/sparse/umfpack/>)

     DROPTOL determines the values below which the values in the LU 
     factorization are dropped and replaced by zero.  It must be a
     positive scalar, and any values in the factorization whose absolute
     value are less than this value are dropped, expect if leaving them
     increase the sparsity of the matrix.  Setting DROPTOL to zero
     results in a complete LU factorization which is the default.

     OPTS is a structure containing one or more of the fields

     'droptol'
          The drop tolerance as above.  If OPTS only contains 'droptol'
          then this is equivalent to using the variable DROPTOL.

     'milu'
          A logical variable flagging whether to use the modified
          incomplete LU  factorization.  In the case that 'milu' is
          true, the dropped values are subtracted from the diagonal of
          the matrix U of the factorization.  The default is 'false'.

     'udiag'
          A logical variable that flags whether zero elements on the
          diagonal of U should be replaced with DROPTOL to attempt to
          avoid singular factors.  The default is 'false'.

     'thresh'
          Defines the pivot threshold in the interval [0,1].  Values
          outside that range are ignored.

     All other fields in OPTS are ignored.  The outputs from 'luinc' are
     the same as for 'lu'.

     Given the string argument "vector", 'luinc' returns the values of P
     Q as vector values.

     See also: sparse, lu.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Produce the incomplete LU factorization of the sparse matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
abs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 166
 -- Mapping Function: abs (Z)
     Compute the magnitude of Z, defined as |Z| = 'sqrt (x^2 + y^2)'.

     For example:

          abs (3 + 4i)
               => 5
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Compute the magnitude of Z, defined as |Z| = 'sqrt (x^2 + y^2)'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
acos


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 128
 -- Mapping Function: acos (X)
     Compute the inverse cosine in radians for each element of X.

     See also: cos, acosd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Compute the inverse cosine in radians for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
acosh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
 -- Mapping Function: acosh (X)
     Compute the inverse hyperbolic cosine for each element of X.

     See also: cosh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Compute the inverse hyperbolic cosine for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
angle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
 -- Mapping Function: angle (Z)
     See arg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
See arg.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
arg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 219
 -- Mapping Function: arg (Z)
 -- Mapping Function: angle (Z)
     Compute the argument of Z, defined as, THETA = 'atan2 (Y, X)', in
     radians.

     For example:

          arg (3 + 4i)
               => 0.92730
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Compute the argument of Z, defined as, THETA = 'atan2 (Y, X)', in  radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
asin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
 -- Mapping Function: asin (X)
     Compute the inverse sine in radians for each element of X.

     See also: sin, asind.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Compute the inverse sine in radians for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
asinh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 121
 -- Mapping Function: asinh (X)
     Compute the inverse hyperbolic sine for each element of X.

     See also: sinh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Compute the inverse hyperbolic sine for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
atan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
 -- Mapping Function: atan (X)
     Compute the inverse tangent in radians for each element of X.

     See also: tan, atand.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Compute the inverse tangent in radians for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
atanh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
 -- Mapping Function: atanh (X)
     Compute the inverse hyperbolic tangent for each element of X.

     See also: tanh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Compute the inverse hyperbolic tangent for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cbrt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 183
 -- Mapping Function: cbrt (X)
     Compute the real cube root of each element of X.  Unlike 'X^(1/3)',
     the result will be negative if X is negative.

     See also: nthroot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Compute the real cube root of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
ceil


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 309
 -- Mapping Function: ceil (X)
     Return the smallest integer not less than X.  This is equivalent to
     rounding towards positive infinity.  If X is complex, return 'ceil
     (real (X)) + ceil (imag (X)) * I'.

          ceil ([-2.7, 2.7])
              => -2    3

     See also: floor, round, fix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return the smallest integer not less than X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
conj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
 -- Mapping Function: conj (Z)
     Return the complex conjugate of Z, defined as 'conj (Z)' = X - IY.

     See also: real, imag.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Return the complex conjugate of Z, defined as 'conj (Z)' = X - IY.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
cos


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
 -- Mapping Function: cos (X)
     Compute the cosine for each element of X in radians.

     See also: acos, cosd, cosh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute the cosine for each element of X in radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cosh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
 -- Mapping Function: cosh (X)
     Compute the hyperbolic cosine for each element of X.

     See also: acosh, sinh, tanh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute the hyperbolic cosine for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
erf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 314
 -- Mapping Function: erf (Z)
     Compute the error function,

                                  z
                        2        /
          erf (z) = --------- *  | e^(-t^2) dt
                    sqrt (pi)    /
                              t=0

     See also: erfc, erfcx, erfi, dawson, erfinv, erfcinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Compute the error function, 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
erfinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 176
 -- Mapping Function: erfinv (X)
     Compute the inverse error function, i.e., Y such that

          erf (Y) == X

     See also: erf, erfc, erfcx, erfi, dawson, erfcinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Compute the inverse error function, i.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
erfcinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 191
 -- Mapping Function: erfcinv (X)
     Compute the inverse complementary error function, i.e., Y such that

          erfc (Y) == X

     See also: erfc, erf, erfcx, erfi, dawson, erfinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute the inverse complementary error function, i.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
erfc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 155
 -- Mapping Function: erfc (Z)
     Compute the complementary error function, '1 - erf (Z)'.

     See also: erfcinv, erfcx, erfi, dawson, erf, erfinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Compute the complementary error function, '1 - erf (Z)'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
erfcx


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 179
 -- Mapping Function: erfcx (Z)
     Compute the scaled complementary error function,

          exp (z^2) * erfc (z)

     See also: erfc, erf, erfi, dawson, erfinv, erfcinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Compute the scaled complementary error function, 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
erfi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 162
 -- Mapping Function: erfi (Z)
     Compute the imaginary error function,

          -i * erf (i*z)

     See also: erfc, erf, erfcx, dawson, erfinv, erfcinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Compute the imaginary error function, 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dawson


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 203
 -- Mapping Function: dawson (Z)
     Compute the Dawson (scaled imaginary error) function,

          (sqrt (pi) / 2) * exp (-z^2) * erfi (z)

     See also: erfc, erf, erfcx, erfi, erfinv, erfcinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Compute the Dawson (scaled imaginary error) function, 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
exp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 165
 -- Mapping Function: exp (X)
     Compute 'e^x' for each element of X.  To compute the matrix
     exponential, see *note Linear Algebra::.

     See also: log.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Compute 'e^x' for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
expm1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
 -- Mapping Function: expm1 (X)
     Compute 'exp (X) - 1' accurately in the neighborhood of zero.

     See also: exp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Compute 'exp (X) - 1' accurately in the neighborhood of zero.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isfinite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 312
 -- Mapping Function: isfinite (X)
 -- Mapping Function: finite (X)
     Return a logical array which is true where the elements of X are
     finite values and false where they are not.  For example:

          finite ([13, Inf, NA, NaN])
               => [ 1, 0, 0, 0 ]

     See also: isinf, isnan, isna.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
Return a logical array which is true where the elements of X are  finite values and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
fix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 311
 -- Mapping Function: fix (X)
     Truncate fractional portion of X and return the integer portion.
     This is equivalent to rounding towards zero.  If X is complex,
     return 'fix (real (X)) + fix (imag (X)) * I'.

          fix ([-2.7, 2.7])
             => -2    2

     See also: ceil, floor, round.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Truncate fractional portion of X and return the integer portion.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
floor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 315
 -- Mapping Function: floor (X)
     Return the largest integer not greater than X.  This is equivalent
     to rounding towards negative infinity.  If X is complex, return
     'floor (real (X)) + floor (imag (X)) * I'.

          floor ([-2.7, 2.7])
               => -3    2

     See also: ceil, round, fix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Return the largest integer not greater than X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
gamma


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 251
 -- Mapping Function: gamma (Z)
     Compute the Gamma function,

                       infinity
                      /
          gamma (z) = | t^(z-1) exp (-t) dt.
                      /
                   t=0

     See also: gammainc, lgamma.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Compute the Gamma function, 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
imag


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
 -- Mapping Function: imag (Z)
     Return the imaginary part of Z as a real number.

     See also: real, conj.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the imaginary part of Z as a real number.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isalnum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 280
 -- Mapping Function: isalnum (S)
     Return a logical array which is true where the elements of S are
     letters or digits and false where they are not.  This is equivalent
     to ('isalpha (S) | isdigit (S)').

     See also: isalpha, isdigit, ispunct, isspace, iscntrl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
Return a logical array which is true where the elements of S are  letters or digits and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isalpha


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 293
 -- Mapping Function: isalpha (S)
     Return a logical array which is true where the elements of S are
     letters and false where they are not.  This is equivalent to
     ('islower (S) | isupper (S)').

     See also: isdigit, ispunct, isspace, iscntrl, isalnum, islower,
     isupper.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Return a logical array which is true where the elements of S are  letters and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isascii


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 196
 -- Mapping Function: isascii (S)
     Return a logical array which is true where the elements of S are
     ASCII characters (in the range 0 to 127 decimal) and false where
     they are not.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 145
Return a logical array which is true where the elements of S are  ASCII characters (in the range 0 to 127 decimal) and false where  they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
iscntrl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 213
 -- Mapping Function: iscntrl (S)
     Return a logical array which is true where the elements of S are
     control characters and false where they are not.

     See also: ispunct, isspace, isalpha, isdigit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
Return a logical array which is true where the elements of S are  control characters and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isdigit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 235
 -- Mapping Function: isdigit (S)
     Return a logical array which is true where the elements of S are
     decimal digits (0-9) and false where they are not.

     See also: isxdigit, isalpha, isletter, ispunct, isspace, iscntrl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
Return a logical array which is true where the elements of S are  decimal digits (0-9) and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
isinf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 278
 -- Mapping Function: isinf (X)
     Return a logical array which is true where the elements of X are
     are infinite and false where they are not.  For example:

          isinf ([13, Inf, NA, NaN])
                => [ 0, 1, 0, 0 ]

     See also: isfinite, isnan, isna.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
Return a logical array which is true where the elements of X are  are infinite and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isgraph


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 223
 -- Mapping Function: isgraph (S)
     Return a logical array which is true where the elements of S are
     printable characters (but not the space character) and false where
     they are not.

     See also: isprint.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 147
Return a logical array which is true where the elements of S are  printable characters (but not the space character) and false where  they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
islower


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 213
 -- Mapping Function: islower (S)
     Return a logical array which is true where the elements of S are
     lowercase letters and false where they are not.

     See also: isupper, isalpha, isletter, isalnum.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
Return a logical array which is true where the elements of S are  lowercase letters and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
isna


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 283
 -- Mapping Function: isna (X)
     Return a logical array which is true where the elements of X are NA
     (missing) values and false where they are not.  For example:

          isna ([13, Inf, NA, NaN])
               => [ 0, 0, 1, 0 ]

     See also: isnan, isinf, isfinite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
Return a logical array which is true where the elements of X are NA  (missing) values and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
isnan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 324
 -- Mapping Function: isnan (X)
     Return a logical array which is true where the elements of X are
     NaN values and false where they are not.  NA values are also
     considered NaN values.  For example:

          isnan ([13, Inf, NA, NaN])
                => [ 0, 0, 1, 1 ]

     See also: isna, isinf, isfinite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 106
Return a logical array which is true where the elements of X are  NaN values and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isprint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 225
 -- Mapping Function: isprint (S)
     Return a logical array which is true where the elements of S are
     printable characters (including the space character) and false
     where they are not.

     See also: isgraph.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 149
Return a logical array which is true where the elements of S are  printable characters (including the space character) and false  where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ispunct


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 217
 -- Mapping Function: ispunct (S)
     Return a logical array which is true where the elements of S are
     punctuation characters and false where they are not.

     See also: isalpha, isdigit, isspace, iscntrl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 118
Return a logical array which is true where the elements of S are  punctuation characters and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isspace


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 288
 -- Mapping Function: isspace (S)
     Return a logical array which is true where the elements of S are
     whitespace characters (space, formfeed, newline, carriage return,
     tab, and vertical tab) and false where they are not.

     See also: iscntrl, ispunct, isalpha, isdigit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 185
Return a logical array which is true where the elements of S are  whitespace characters (space, formfeed, newline, carriage return,  tab, and vertical tab) and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isupper


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 213
 -- Mapping Function: isupper (S)
     Return a logical array which is true where the elements of S are
     uppercase letters and false where they are not.

     See also: islower, isalpha, isletter, isalnum.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
Return a logical array which is true where the elements of S are  uppercase letters and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isxdigit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 175
 -- Mapping Function: isxdigit (S)
     Return a logical array which is true where the elements of S are
     hexadecimal digits (0-9 and a-fA-F).

     See also: isdigit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
Return a logical array which is true where the elements of S are  hexadecimal digits (0-9 and a-fA-F).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
lgamma


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 165
 -- Mapping Function: lgamma (X)
 -- Mapping Function: gammaln (X)
     Return the natural logarithm of the gamma function of X.

     See also: gamma, gammainc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Return the natural logarithm of the gamma function of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
log


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 220
 -- Mapping Function: log (X)
     Compute the natural logarithm, 'ln (X)', for each element of X.  To
     compute the matrix logarithm, see *note Linear Algebra::.

     See also: exp, log1p, log2, log10, logspace.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Compute the natural logarithm, 'ln (X)', for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
log10


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
 -- Mapping Function: log10 (X)
     Compute the base-10 logarithm of each element of X.

     See also: log, log2, logspace, exp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Compute the base-10 logarithm of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
log1p


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
 -- Mapping Function: log1p (X)
     Compute 'log (1 + X)' accurately in the neighborhood of zero.

     See also: log, exp, expm1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Compute 'log (1 + X)' accurately in the neighborhood of zero.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
real


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 94
 -- Mapping Function: real (Z)
     Return the real part of Z.

     See also: imag, conj.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Return the real part of Z.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
round


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 325
 -- Mapping Function: round (X)
     Return the integer nearest to X.  If X is complex, return 'round
     (real (X)) + round (imag (X)) * I'.  If there are two nearest
     integers, return the one further away from zero.

          round ([-2.7, 2.7])
               => -3    3

     See also: ceil, floor, fix, roundb.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Return the integer nearest to X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
roundb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 254
 -- Mapping Function: roundb (X)
     Return the integer nearest to X.  If there are two nearest
     integers, return the even one (banker's rounding).  If X is
     complex, return 'roundb (real (X)) + roundb (imag (X)) * I'.

     See also: round.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Return the integer nearest to X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sign


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 476
 -- Mapping Function: sign (X)
     Compute the "signum" function, which is defined as

                     -1, x < 0;
          sign (x) =  0, x = 0;
                      1, x > 0.

     For complex arguments, 'sign' returns 'x ./ abs (X)'.

     Note that 'sign (-0.0)' is 0.  Although IEEE 754 floating point
     allows zero to be signed, 0.0 and -0.0 compare equal.  If you must
     test whether zero is signed, use the 'signbit' function.

     See also: signbit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Compute the "signum" function, which is defined as 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
signbit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 563
 -- Mapping Function: signbit (X)
     Return logical true if the value of X has its sign bit set.
     Otherwise return logical false.  This behavior is consistent with
     the other logical functions.  See*note Logical Values::.  The
     behavior differs from the C language function which returns
     non-zero if the sign bit is set.

     This is not the same as 'x < 0.0', because IEEE 754 floating point
     allows zero to be signed.  The comparison '-0.0 < 0.0' is false,
     but 'signbit (-0.0)' will return a nonzero value.

     See also: sign.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Return logical true if the value of X has its sign bit set.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
sin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
 -- Mapping Function: sin (X)
     Compute the sine for each element of X in radians.

     See also: asin, sind, sinh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute the sine for each element of X in radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sinh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
 -- Mapping Function: sinh (X)
     Compute the hyperbolic sine for each element of X.

     See also: asinh, cosh, tanh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute the hyperbolic sine for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sqrt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 243
 -- Mapping Function: sqrt (X)
     Compute the square root of each element of X.  If X is negative, a
     complex result is returned.  To compute the matrix square root, see
     *note Linear Algebra::.

     See also: realsqrt, nthroot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Compute the square root of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
tan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
 -- Mapping Function: tan (Z)
     Compute the tangent for each element of X in radians.

     See also: atan, tand, tanh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute the tangent for each element of X in radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
tanh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
 -- Mapping Function: tanh (X)
     Compute hyperbolic tangent for each element of X.

     See also: atanh, sinh, cosh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Compute hyperbolic tangent for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
toascii


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 195
 -- Mapping Function: toascii (S)
     Return ASCII representation of S in a matrix.  For example:

          toascii ("ASCII")
               => [ 65, 83, 67, 73, 73 ]


     See also: char.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Return ASCII representation of S in a matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
tolower


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 364
 -- Mapping Function: tolower (S)
 -- Mapping Function: lower (S)
     Return a copy of the string or cell string S, with each uppercase
     character replaced by the corresponding lowercase one;
     non-alphabetic characters are left unchanged.  For example:

          tolower ("MiXeD cAsE 123")
                => "mixed case 123"

     See also: toupper.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 168
Return a copy of the string or cell string S, with each uppercase  character replaced by the corresponding lowercase one;  non-alphabetic characters are left unchanged.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
toupper


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 364
 -- Mapping Function: toupper (S)
 -- Mapping Function: upper (S)
     Return a copy of the string or cell string S, with each lowercase
     character replaced by the corresponding uppercase one;
     non-alphabetic characters are left unchanged.  For example:

          toupper ("MiXeD cAsE 123")
                => "MIXED CASE 123"

     See also: tolower.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 168
Return a copy of the string or cell string S, with each lowercase  character replaced by the corresponding uppercase one;  non-alphabetic characters are left unchanged.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
matrix_type


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3366
 -- Built-in Function: TYPE = matrix_type (A)
 -- Built-in Function: TYPE = matrix_type (A, "nocompute")
 -- Built-in Function: A = matrix_type (A, TYPE)
 -- Built-in Function: A = matrix_type (A, "upper", PERM)
 -- Built-in Function: A = matrix_type (A, "lower", PERM)
 -- Built-in Function: A = matrix_type (A, "banded", NL, NU)
     Identify the matrix type or mark a matrix as a particular type.
     This allows more rapid solutions of linear equations involving A to
     be performed.  Called with a single argument, 'matrix_type' returns
     the type of the matrix and caches it for future use.  Called with
     more than one argument, 'matrix_type' allows the type of the matrix
     to be defined.

     If the option "nocompute" is given, the function will not attempt
     to guess the type if it is still unknown.  This is useful for
     debugging purposes.

     The possible matrix types depend on whether the matrix is full or
     sparse, and can be one of the following

     "unknown"
          Remove any previously cached matrix type, and mark type as
          unknown.

     "full"
          Mark the matrix as full.

     "positive definite"
          Probable full positive definite matrix.

     "diagonal"
          Diagonal matrix.  (Sparse matrices only)

     "permuted diagonal"
          Permuted Diagonal matrix.  The permutation does not need to be
          specifically indicated, as the structure of the matrix
          explicitly gives this.  (Sparse matrices only)

     "upper"
          Upper triangular.  If the optional third argument PERM is
          given, the matrix is assumed to be a permuted upper triangular
          with the permutations defined by the vector PERM.

     "lower"
          Lower triangular.  If the optional third argument PERM is
          given, the matrix is assumed to be a permuted lower triangular
          with the permutations defined by the vector PERM.

     "banded"
     "banded positive definite"
          Banded matrix with the band size of NL below the diagonal and
          NU above it.  If NL and NU are 1, then the matrix is
          tridiagonal and treated with specialized code.  In addition
          the matrix can be marked as probably a positive definite.
          (Sparse matrices only)

     "singular"
          The matrix is assumed to be singular and will be treated with
          a minimum norm solution.

     Note that the matrix type will be discovered automatically on the
     first attempt to solve a linear equation involving A.  Therefore
     'matrix_type' is only useful to give Octave hints of the matrix
     type.  Incorrectly defining the matrix type will result in
     incorrect results from solutions of linear equations; it is
     entirely *the responsibility of the user* to correctly identify the
     matrix type.

     Also, the test for positive definiteness is a low-cost test for a
     Hermitian matrix with a real positive diagonal.  This does not
     guarantee that the matrix is positive definite, but only that it is
     a probable candidate.  When such a matrix is factorized, a
     Cholesky factorization is first attempted, and if that fails the
     matrix is then treated with an LU factorization.  Once the matrix
     has been factorized, 'matrix_type' will return the correct
     classification of the matrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Identify the matrix type or mark a matrix as a particular type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
min


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1148
 -- Built-in Function: min (X)
 -- Built-in Function: min (X, Y)
 -- Built-in Function: min (X, [], DIM)
 -- Built-in Function: min (X, Y, DIM)
 -- Built-in Function: [W, IW] = min (X)
     For a vector argument, return the minimum value.  For a matrix
     argument, return the minimum value from each column, as a row
     vector, or over the dimension DIM if defined, in which case Y
     should be set to the empty matrix (it's ignored otherwise).  For
     two matrices (or a matrix and scalar), return the pair-wise
     minimum.  Thus,

          min (min (X))

     returns the smallest element of X, and

          min (2:5, pi)
              =>  2.0000  3.0000  3.1416  3.1416

     compares each element of the range '2:5' with 'pi', and returns a
     row vector of the minimum values.

     For complex arguments, the magnitude of the elements are used for
     comparison.

     If called with one input and two output arguments, 'min' also
     returns the first index of the minimum value(s).  Thus,

          [x, ix] = min ([1, 3, 0, 2, 0])
              =>  x = 0
                  ix = 3

     See also: max, cummin, cummax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
For a vector argument, return the minimum value.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
max


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1158
 -- Built-in Function: max (X)
 -- Built-in Function: max (X, Y)
 -- Built-in Function: max (X, [], DIM)
 -- Built-in Function: max (X, Y, DIM)
 -- Built-in Function: [W, IW] = max (X)
     For a vector argument, return the maximum value.  For a matrix
     argument, return the maximum value from each column, as a row
     vector, or over the dimension DIM if defined, in which case Y
     should be set to the empty matrix (it's ignored otherwise).  For
     two matrices (or a matrix and scalar), return the pair-wise
     maximum.  Thus,

          max (max (X))

     returns the largest element of the matrix X, and

          max (2:5, pi)
              =>  3.1416  3.1416  4.0000  5.0000

     compares each element of the range '2:5' with 'pi', and returns a
     row vector of the maximum values.

     For complex arguments, the magnitude of the elements are used for
     comparison.

     If called with one input and two output arguments, 'max' also
     returns the first index of the maximum value(s).  Thus,

          [x, ix] = max ([1, 3, 5, 2, 5])
              =>  x = 5
                  ix = 3

     See also: min, cummax, cummin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
For a vector argument, return the maximum value.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
cummin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 587
 -- Built-in Function: cummin (X)
 -- Built-in Function: cummin (X, DIM)
 -- Built-in Function: [W, IW] = cummin (X)
     Return the cumulative minimum values along dimension DIM.

     If DIM is unspecified it defaults to column-wise operation.  For
     example:

          cummin ([5 4 6 2 3 1])
             =>  5  4  4  2  2  1

     If called with two output arguments the index of the minimum value
     is also returned.

          [w, iw] = cummin ([5 4 6 2 3 1])
          =>
          w =  5  4  4  2  2  1
          iw = 1  2  2  4  4  6

     See also: cummax, min, max.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Return the cumulative minimum values along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
cummax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 589
 -- Built-in Function: cummax (X)
 -- Built-in Function: cummax (X, DIM)
 -- Built-in Function: [W, IW] = cummax (...)
     Return the cumulative maximum values along dimension DIM.

     If DIM is unspecified it defaults to column-wise operation.  For
     example:

          cummax ([1 3 2 6 4 5])
             =>  1  3  3  6  6  6

     If called with two output arguments the index of the maximum value
     is also returned.

          [w, iw] = cummax ([1 3 2 6 4 5])
          =>
          w =  1  3  3  6  6  6
          iw = 1  2  2  4  4  4

     See also: cummin, max, min.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Return the cumulative maximum values along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
md5sum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 231
 -- Built-in Function: md5sum (FILE)
 -- Built-in Function: md5sum (STR, OPT)
     Calculate the MD5 sum of the file FILE.  If the second parameter
     OPT exists and is true, then calculate the MD5 sum of the string
     STR.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Calculate the MD5 sum of the file FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mgorth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 331
 -- Built-in Function: [Y, H] = mgorth (X, V)
     Orthogonalize a given column vector X with respect to a set of
     orthonormal vectors comprising the columns of V using the modified
     Gram-Schmidt method.  On exit, Y is a unit vector such that:

            norm (Y) = 1
            V' * Y = 0
            X = [V, Y]*H'

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
Orthogonalize a given column vector X with respect to a set of  orthonormal vectors comprising the columns of V using the modified  Gram-Schmidt method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
nproc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 468
 -- Built-in Function: nproc ()
 -- Built-in Function: nproc (QUERY)
     Return the current number of available processors.

     If called with the optional argument QUERY, modify how processors
     are counted as follows:

     'all'
          total number of processors.

     'current'
          processors available to the current process.

     'overridable'
          likewise, but overridable through the 'OMP_NUM_THREADS'
          environment variable.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return the current number of available processors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
edit_history


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1347
 -- Command: edit_history
 -- Command: edit_history CMD_NUMBER
 -- Command: edit_history FIRST LAST
     Edit the history list using the editor named by the variable
     'EDITOR'.

     The commands to be edited are first copied to a temporary file.
     When you exit the editor, Octave executes the commands that remain
     in the file.  It is often more convenient to use 'edit_history' to
     define functions rather than attempting to enter them directly on
     the command line.  The block of commands is executed as soon as you
     exit the editor.  To avoid executing any commands, simply delete
     all the lines from the buffer before leaving the editor.

     When invoked with no arguments, edit the previously executed
     command; With one argument, edit the specified command CMD_NUMBER;
     With two arguments, edit the list of commands between FIRST and
     LAST.  Command number specifiers may also be negative where -1
     refers to the most recently executed command.  The following are
     equivalent and edit the most recently executed command.

          edit_history
          edit_history -1

     When using ranges, specifying a larger number for the first command
     than the last command reverses the list of commands before they are
     placed in the buffer to be edited.

     See also: run_history.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Edit the history list using the editor named by the variable  'EDITOR'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
history


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1213
 -- Command: history
 -- Command: history OPT1 ...
 -- Built-in Function: H = history ()
 -- Built-in Function: H = history (OPT1, ...)
     If invoked with no arguments, 'history' displays a list of commands
     that you have executed.  Valid options are:

     'N'
     '-N'
          Display only the most recent N lines of history.

     '-c'
          Clear the history list.

     '-q'
          Don't number the displayed lines of history.  This is useful
          for cutting and pasting commands using the X Window System.

     '-r FILE'
          Read the file FILE, appending its contents to the current
          history list.  If the name is omitted, use the default history
          file (normally '~/.octave_hist').

     '-w FILE'
          Write the current history to the file FILE.  If the name is
          omitted, use the default history file (normally
          '~/.octave_hist').

     For example, to display the five most recent commands that you have
     typed without displaying line numbers, use the command 'history -q
     5'.

     If invoked with a single output argument, the history will be saved
     to that argument as a cell string and will not be output to screen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
If invoked with no arguments, 'history' displays a list of commands  that you have executed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
run_history


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 981
 -- Command: run_history
 -- Command: run_history CMD_NUMBER
 -- Command: run_history FIRST LAST
     Run commands from the history list.

     When invoked with no arguments, run the previously executed
     command; With one argument, run the specified command CMD_NUMBER;
     With two arguments, run the list of commands between FIRST and
     LAST.  Command number specifiers may also be negative where -1
     refers to the most recently executed command.  For example, the
     command

          run_history
               OR
          run_history -1

     executes the most recent command again.  The command

          run_history 13 169

     executes commands 13 through 169.

     Specifying a larger number for the first command than the last
     command reverses the list of commands before executing them.  For
     example:

          disp (1)
          disp (2)
          run_history -1 -2
          =>
           2
           1

     See also: edit_history.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Run commands from the history list.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
history_control


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1224
 -- Built-in Function: VAL = history_control ()
 -- Built-in Function: OLD_VAL = history_control (NEW_VAL)
     Query or set the internal variable that specifies how commands are
     saved to the history list.  The default value is an empty character
     string, but may be overridden by the environment variable
     'OCTAVE_HISTCONTROL'.

     The value of 'history_control' is a colon-separated list of values
     controlling how commands are saved on the history list.  If the
     list of values includes 'ignorespace', lines which begin with a
     space character are not saved in the history list.  A value of
     'ignoredups' causes lines matching the previous history entry to
     not be saved.  A value of 'ignoreboth' is shorthand for
     'ignorespace' and 'ignoredups'.  A value of 'erasedups' causes all
     previous lines matching the current line to be removed from the
     history list before that line is saved.  Any value not in the above
     list is ignored.  If 'history_control' is the empty string, all
     commands are saved on the history list, subject to the value of
     'history_save'.

     See also: history_file, history_size,
     history_timestamp_format_string, history_save.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 94
Query or set the internal variable that specifies how commands are  saved to the history list.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
history_size


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 397
 -- Built-in Function: VAL = history_size ()
 -- Built-in Function: OLD_VAL = history_size (NEW_VAL)
     Query or set the internal variable that specifies how many entries
     to store in the history file.  The default value is '1000', but may
     be overridden by the environment variable 'OCTAVE_HISTSIZE'.

     See also: history_file, history_timestamp_format_string,
     history_save.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Query or set the internal variable that specifies how many entries  to store in the history file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
history_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 417
 -- Built-in Function: VAL = history_file ()
 -- Built-in Function: OLD_VAL = history_file (NEW_VAL)
     Query or set the internal variable that specifies the name of the
     file used to store command history.  The default value is
     '~/.octave_hist', but may be overridden by the environment variable
     'OCTAVE_HISTFILE'.

     See also: history_size, history_save,
     history_timestamp_format_string.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
Query or set the internal variable that specifies the name of the  file used to store command history.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
history_timestamp_format_string


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 829
 -- Built-in Function: VAL = history_timestamp_format_string ()
 -- Built-in Function: OLD_VAL = history_timestamp_format_string
          (NEW_VAL)
 -- Built-in Function: history_timestamp_format_string (NEW_VAL,
          "local")
     Query or set the internal variable that specifies the format string
     for the comment line that is written to the history file when
     Octave exits.  The format string is passed to 'strftime'.  The
     default value is

          "# Octave VERSION, %a %b %d %H:%M:%S %Y %Z <USER@HOST>"

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: strftime, history_file, history_size, history_save.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 166
(NEW_VAL)  "local")  Query or set the internal variable that specifies the format string  for the comment line that is written to the history file when  Octave exits.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
history_save


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 621
 -- Built-in Function: VAL = history_save ()
 -- Built-in Function: OLD_VAL = history_save (NEW_VAL)
 -- Built-in Function: history_save (NEW_VAL, "local")
     Query or set the internal variable that controls whether commands
     entered on the command line are saved in the history file.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: history_control, history_file, history_size,
     history_timestamp_format_string.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
Query or set the internal variable that controls whether commands  entered on the command line are saved in the history file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
diary


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 586
 -- Command: diary
 -- Command: diary on
 -- Command: diary off
 -- Command: diary FILENAME
     Record a list of all commands _and_ the output they produce, mixed
     together just as they appear on the terminal.

     Valid options are:

     on
          Start recording a session in a file called 'diary' in the
          current working directory.

     off
          Stop recording the session in the diary file.

     FILENAME
          Record the session in the file named FILENAME.

     With no arguments, 'diary' toggles the current diary state.

     See also: history.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
Record a list of all commands _and_ the output they produce, mixed  together just as they appear on the terminal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
more


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 318
 -- Command: more
 -- Command: more on
 -- Command: more off
     Turn output pagination on or off.  Without an argument, 'more'
     toggles the current state.  The current state can be determined via
     'page_screen_output'.

     See also: page_screen_output, page_output_immediately, PAGER,
     PAGER_FLAGS.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Turn output pagination on or off.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
terminal_size


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 203
 -- Built-in Function: terminal_size ()
     Return a two-element row vector containing the current size of the
     terminal window in characters (rows and columns).

     See also: list_in_columns.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
Return a two-element row vector containing the current size of the  terminal window in characters (rows and columns).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
page_output_immediately


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 734
 -- Built-in Function: VAL = page_output_immediately ()
 -- Built-in Function: OLD_VAL = page_output_immediately (NEW_VAL)
 -- Built-in Function: page_output_immediately (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     sends output to the pager as soon as it is available.  Otherwise,
     Octave buffers its output and waits until just before the prompt is
     printed to flush it to the pager.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: page_screen_output, more, PAGER, PAGER_FLAGS.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 118
Query or set the internal variable that controls whether Octave  sends output to the pager as soon as it is available.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
page_screen_output


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 805
 -- Built-in Function: VAL = page_screen_output ()
 -- Built-in Function: OLD_VAL = page_screen_output (NEW_VAL)
 -- Built-in Function: page_screen_output (NEW_VAL, "local")
     Query or set the internal variable that controls whether output
     intended for the terminal window that is longer than one page is
     sent through a pager.  This allows you to view one screenful at a
     time.  Some pagers (such as 'less'--see *note Installation::) are
     also capable of moving backward on the output.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: more, page_output_immediately, PAGER, PAGER_FLAGS.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
Query or set the internal variable that controls whether output  intended for the terminal window that is longer than one page is  sent through a pager.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
PAGER


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 719
 -- Built-in Function: VAL = PAGER ()
 -- Built-in Function: OLD_VAL = PAGER (NEW_VAL)
 -- Built-in Function: PAGER (NEW_VAL, "local")
     Query or set the internal variable that specifies the program to
     use to display terminal output on your system.  The default value
     is normally "less", "more", or "pg", depending on what programs are
     installed on your system.  *Note Installation::.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: PAGER_FLAGS, page_output_immediately, more,
     page_screen_output.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Query or set the internal variable that specifies the program to  use to display terminal output on your system.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
PAGER_FLAGS


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 552
 -- Built-in Function: VAL = PAGER_FLAGS ()
 -- Built-in Function: OLD_VAL = PAGER_FLAGS (NEW_VAL)
 -- Built-in Function: PAGER_FLAGS (NEW_VAL, "local")
     Query or set the internal variable that specifies the options to
     pass to the pager.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: PAGER, more, page_screen_output, page_output_immediately.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Query or set the internal variable that specifies the options to  pass to the pager.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
pinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 335
 -- Built-in Function: pinv (X)
 -- Built-in Function: pinv (X, TOL)
     Return the pseudoinverse of X.  Singular values less than TOL are
     ignored.

     If the second argument is omitted, it is taken to be

          tol = max (size (X)) * sigma_max (X) * eps,

     where 'sigma_max (X)' is the maximal singular value of X.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Return the pseudoinverse of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
rats


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 395
 -- Built-in Function: rats (X, LEN)
     Convert X into a rational approximation represented as a string.
     You can convert the string back into a matrix as follows:

          r = rats (hilb (4));
          x = str2num (r)

     The optional second argument defines the maximum length of the
     string representing the elements of X.  By default LEN is 9.

     See also: format, rat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Convert X into a rational approximation represented as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
disp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 395
 -- Built-in Function: disp (X)
     Display the value of X.  For example:

          disp ("The value of pi is:"), disp (pi)

               -| the value of pi is:
               -| 3.1416

     Note that the output from 'disp' always ends with a newline.

     If an output value is requested, 'disp' prints nothing and returns
     the formatted output in a string.

     See also: fdisp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Display the value of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fdisp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 325
 -- Built-in Function: fdisp (FID, X)
     Display the value of X on the stream FID.  For example:

          fdisp (stdout, "The value of pi is:"), fdisp (stdout, pi)

               -| the value of pi is:
               -| 3.1416

     Note that the output from 'fdisp' always ends with a newline.

     See also: disp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Display the value of X on the stream FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
format


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5670
 -- Command: format
 -- Command: format options
     Reset or specify the format of the output produced by 'disp' and
     Octave's normal echoing mechanism.  This command only affects the
     display of numbers but not how they are stored or computed.  To
     change the internal representation from the default double use one
     of the conversion functions such as 'single', 'uint8', 'int64',
     etc.

     By default, Octave displays 5 significant digits in a human
     readable form (option 'short' paired with 'loose' format for
     matrices).  If 'format' is invoked without any options, this
     default format is restored.

     Valid formats for floating point numbers are listed in the
     following table.

     'short'
          Fixed point format with 5 significant figures in a field that
          is a maximum of 10 characters wide.  (default).

          If Octave is unable to format a matrix so that columns line up
          on the decimal point and all numbers fit within the maximum
          field width then it switches to an exponential 'e' format.

     'long'
          Fixed point format with 15 significant figures in a field that
          is a maximum of 20 characters wide.

          As with the 'short' format, Octave will switch to an
          exponential 'e' format if it is unable to format a matrix
          properly using the current format.

     'short e'
     'long e'
          Exponential format.  The number to be represented is split
          between a mantissa and an exponent (power of 10).  The
          mantissa has 5 significant digits in the short format and 15
          digits in the long format.  For example, with the 'short e'
          format, 'pi' is displayed as '3.1416e+00'.

     'short E'
     'long E'
          Identical to 'short e' or 'long e' but displays an uppercase
          'E' to indicate the exponent.  For example, with the 'long E'
          format, 'pi' is displayed as '3.14159265358979E+00'.

     'short g'
     'long g'
          Optimally choose between fixed point and exponential format
          based on the magnitude of the number.  For example, with the
          'short g' format, 'pi .^ [2; 4; 8; 16; 32]' is displayed as

               ans =

                     9.8696
                     97.409
                     9488.5
                 9.0032e+07
                 8.1058e+15

     'short eng'
     'long eng'
          Identical to 'short e' or 'long e' but displays the value
          using an engineering format, where the exponent is divisible
          by 3.  For example, with the 'short eng' format, '10 * pi' is
          displayed as '31.4159e+00'.

     'long G'
     'short G'
          Identical to 'short g' or 'long g' but displays an uppercase
          'E' to indicate the exponent.

     'free'
     'none'
          Print output in free format, without trying to line up columns
          of matrices on the decimal point.  This also causes complex
          numbers to be formatted as numeric pairs like this '(0.60419,
          0.60709)' instead of like this '0.60419 + 0.60709i'.

     The following formats affect all numeric output (floating point and
     integer types).

     '+'
     '+ CHARS'
     'plus'
     'plus CHARS'
          Print a '+' symbol for nonzero matrix elements and a space for
          zero matrix elements.  This format can be very useful for
          examining the structure of a large sparse matrix.

          The optional argument CHARS specifies a list of 3 characters
          to use for printing values greater than zero, less than zero
          and equal to zero.  For example, with the '+ "+-."' format,
          '[1, 0, -1; -1, 0, 1]' is displayed as

               ans =

               +.-
               -.+

     'bank'
          Print in a fixed format with two digits to the right of the
          decimal point.

     'native-hex'
          Print the hexadecimal representation of numbers as they are
          stored in memory.  For example, on a workstation which stores
          8 byte real values in IEEE format with the least significant
          byte first, the value of 'pi' when printed in 'native-hex'
          format is '400921fb54442d18'.

     'hex'
          The same as 'native-hex', but always print the most
          significant byte first.

     'native-bit'
          Print the bit representation of numbers as stored in memory.
          For example, the value of 'pi' is

               01000000000010010010000111111011
               01010100010001000010110100011000

          (shown here in two 32 bit sections for typesetting purposes)
          when printed in native-bit format on a workstation which
          stores 8 byte real values in IEEE format with the least
          significant byte first.

     'bit'
          The same as 'native-bit', but always print the most
          significant bits first.

     'rat'
          Print a rational approximation, i.e., values are approximated
          as the ratio of small integers.  For example, with the 'rat'
          format, 'pi' is displayed as '355/113'.

     The following two options affect the display of all matrices.

     'compact'
          Remove blank lines around column number labels and between
          matrices producing more compact output with more data per
          page.

     'loose'
          Insert blank lines above and below column number labels and
          between matrices to produce a more readable output with less
          data per page.  (default).

     See also: fixed_point_format, output_max_field_width,
     output_precision, split_long_rows, rats.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
Reset or specify the format of the output produced by 'disp' and  Octave's normal echoing mechanism.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
fixed_point_format


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1136
 -- Built-in Function: VAL = fixed_point_format ()
 -- Built-in Function: OLD_VAL = fixed_point_format (NEW_VAL)
 -- Built-in Function: fixed_point_format (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     will use a scaled format to print matrix values.

     The scaled format prints a scaling factor on the first line of
     output chosen such that the largest matrix element can be written
     with a single leading digit.  For example:

          logspace (1, 7, 5)'
          ans =

            1.0e+07  *

            0.00000
            0.00003
            0.00100
            0.03162
            1.00000

     Notice that the first value appears to be 0 when it is actually 1.
     Because of the possibilty for confusion you should be careful about
     enabling 'fixed_point_format'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: format, output_max_field_width, output_precision.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
Query or set the internal variable that controls whether Octave  will use a scaled format to print matrix values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
print_empty_dimensions


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 695
 -- Built-in Function: VAL = print_empty_dimensions ()
 -- Built-in Function: OLD_VAL = print_empty_dimensions (NEW_VAL)
 -- Built-in Function: print_empty_dimensions (NEW_VAL, "local")
     Query or set the internal variable that controls whether the
     dimensions of empty matrices are printed along with the empty
     matrix symbol, '[]'.  For example, the expression

          zeros (3, 0)

     will print

          ans = [](3x0)

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: format.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 145
Query or set the internal variable that controls whether the  dimensions of empty matrices are printed along with the empty  matrix symbol, '[]'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
split_long_rows


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1189
 -- Built-in Function: VAL = split_long_rows ()
 -- Built-in Function: OLD_VAL = split_long_rows (NEW_VAL)
 -- Built-in Function: split_long_rows (NEW_VAL, "local")
     Query or set the internal variable that controls whether rows of a
     matrix may be split when displayed to a terminal window.  If the
     rows are split, Octave will display the matrix in a series of
     smaller pieces, each of which can fit within the limits of your
     terminal width and each set of rows is labeled so that you can
     easily see which columns are currently being displayed.  For
     example:

          octave:13> rand (2,10)
          ans =

           Columns 1 through 6:

            0.75883  0.93290  0.40064  0.43818  0.94958  0.16467
            0.75697  0.51942  0.40031  0.61784  0.92309  0.40201

           Columns 7 through 10:

            0.90174  0.11854  0.72313  0.73326
            0.44672  0.94303  0.56564  0.82150

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: format.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
Query or set the internal variable that controls whether rows of a  matrix may be split when displayed to a terminal window.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
output_max_field_width


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 584
 -- Built-in Function: VAL = output_max_field_width ()
 -- Built-in Function: OLD_VAL = output_max_field_width (NEW_VAL)
 -- Built-in Function: output_max_field_width (NEW_VAL, "local")
     Query or set the internal variable that specifies the maximum width
     of a numeric output field.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: format, fixed_point_format, output_precision.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Query or set the internal variable that specifies the maximum width  of a numeric output field.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
output_precision


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 600
 -- Built-in Function: VAL = output_precision ()
 -- Built-in Function: OLD_VAL = output_precision (NEW_VAL)
 -- Built-in Function: output_precision (NEW_VAL, "local")
     Query or set the internal variable that specifies the minimum
     number of significant figures to display for numeric output.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: format, fixed_point_format, output_max_field_width.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
Query or set the internal variable that specifies the minimum  number of significant figures to display for numeric output.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
quad_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1191
 -- Built-in Function: quad_options ()
 -- Built-in Function: val = quad_options (OPT)
 -- Built-in Function: quad_options (OPT, VAL)
     Query or set options for the function 'quad'.  When called with no
     arguments, the names of all available options and their current
     values are displayed.  Given one argument, return the value of the
     corresponding option.  When called with two arguments,
     'quad_options' set the option OPT to value VAL.

     Options include

     '"absolute tolerance"'
          Absolute tolerance; may be zero for pure relative error test.

     '"relative tolerance"'
          Non-negative relative tolerance.  If the absolute tolerance is
          zero, the relative tolerance must be greater than or equal to
          'max (50*eps, 0.5e-28)'.

     '"single precision absolute tolerance"'
          Absolute tolerance for single precision; may be zero for pure
          relative error test.

     '"single precision relative tolerance"'
          Non-negative relative tolerance for single precision.  If the
          absolute tolerance is zero, the relative tolerance must be
          greater than or equal to 'max (50*eps, 0.5e-28)'.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Query or set options for the function 'quad'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
quad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1798
 -- Built-in Function: Q = quad (F, A, B)
 -- Built-in Function: Q = quad (F, A, B, TOL)
 -- Built-in Function: Q = quad (F, A, B, TOL, SING)
 -- Built-in Function: [Q, IER, NFUN, ERR] = quad (...)
     Numerically evaluate the integral of F from A to B using Fortran
     routines from QUADPACK.  F is a function handle, inline function,
     or a string containing the name of the function to evaluate.  The
     function must have the form 'y = f (x)' where Y and X are scalars.

     A and B are the lower and upper limits of integration.  Either or
     both may be infinite.

     The optional argument TOL is a vector that specifies the desired
     accuracy of the result.  The first element of the vector is the
     desired absolute tolerance, and the second element is the desired
     relative tolerance.  To choose a relative test only, set the
     absolute tolerance to zero.  To choose an absolute test only, set
     the relative tolerance to zero.  Both tolerances default to 'sqrt
     (eps)' or approximately 1.5e^{-8}.

     The optional argument SING is a vector of values at which the
     integrand is known to be singular.

     The result of the integration is returned in Q.  IER contains an
     integer error code (0 indicates a successful integration).  NFUN
     indicates the number of function evaluations that were made, and
     ERR contains an estimate of the error in the solution.

     The function 'quad_options' can set other optional parameters for
     'quad'.

     Note: because 'quad' is written in Fortran it cannot be called
     recursively.  This prevents its use in integrating over more than
     one variable by routines 'dblquad' and 'triplequad'.

     See also: quad_options, quadv, quadl, quadgk, quadcc, trapz,
     dblquad, triplequad.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
Numerically evaluate the integral of F from A to B using Fortran  routines from QUADPACK.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
quadcc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3019
 -- Function File: Q = quadcc (F, A, B)
 -- Function File: Q = quadcc (F, A, B, TOL)
 -- Function File: Q = quadcc (F, A, B, TOL, SING)
 -- Function File: [Q, ERR, NR_POINTS] = quadcc (...)
     Numerically evaluate the integral of F from A to B using the
     doubly-adaptive Clenshaw-Curtis quadrature described by P. Gonnet
     in 'Increasing the Reliability of Adaptive Quadrature Using
     Explicit Interpolants'.  F is a function handle, inline function,
     or string containing the name of the function to evaluate.  The
     function F must be vectorized and must return a vector of output
     values if given a vector of input values.  For example,

          f = @(x) x .* sin (1./x) .* sqrt (abs (1 - x));

     which uses the element-by-element "dot" form for all operators.

     A and B are the lower and upper limits of integration.  Either or
     both limits may be infinite.  'quadcc' handles an inifinite limit
     by substituting the variable of integration with 'x = tan
     (pi/2*u)'.

     The optional argument TOL defines the relative tolerance used to
     stop the integration procedure.  The default value is 1e^{-6}.

     The optional argument SING contains a list of points where the
     integrand has known singularities, or discontinuities in any of its
     derivatives, inside the integration interval.  For the example
     above, which has a discontinuity at x=1, the call to 'quadcc' would
     be as follows

          int = quadcc (f, a, b, 1.0e-6, [ 1 ]);

     The result of the integration is returned in Q.  ERR is an estimate
     of the absolute integration error and NR_POINTS is the number of
     points at which the integrand was evaluated.  If the adaptive
     integration did not converge, the value of ERR will be larger than
     the requested tolerance.  Therefore, it is recommended to verify
     this value for difficult integrands.

     'quadcc' is capable of dealing with non-numeric values of the
     integrand such as 'NaN' or 'Inf'.  If the integral diverges, and
     'quadcc' detects this, then a warning is issued and 'Inf' or '-Inf'
     is returned.

     Note: 'quadcc' is a general purpose quadrature algorithm and, as
     such, may be less efficient for a smooth or otherwise well-behaved
     integrand than other methods such as 'quadgk'.

     The algorithm uses Clenshaw-Curtis quadrature rules of increasing
     degree in each interval and bisects the interval if either the
     function does not appear to be smooth or a rule of maximum degree
     has been reached.  The error estimate is computed from the L2-norm
     of the difference between two successive interpolations of the
     integrand over the nodes of the respective quadrature rules.

     Reference: P. Gonnet, 'Increasing the Reliability of Adaptive
     Quadrature Using Explicit Interpolants', ACM Transactions on
     Mathematical Software, Vol.  37, Issue 3, Article No.  3, 2010.

     See also: quad, quadv, quadl, quadgk, trapz, dblquad, triplequad.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 120
Numerically evaluate the integral of F from A to B using the  doubly-adaptive Clenshaw-Curtis quadrature described by P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
qz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1989
 -- Built-in Function: LAMBDA = qz (A, B)
 -- Built-in Function: LAMBDA = qz (A, B, OPT)
     QZ decomposition of the generalized eigenvalue problem (A x = s B
     x).  There are three ways to call this function:
       1. 'LAMBDA = qz (A, B)'

          Computes the generalized eigenvalues LAMBDA of (A - s B).

       2. '[AA, BB, Q, Z, V, W, LAMBDA] = qz (A, B)'

          Computes QZ decomposition, generalized eigenvectors, and
          generalized eigenvalues of (A - s B)


               A * V = B * V * diag (LAMBDA)
               W' * A = diag (LAMBDA) * W' * B
               AA = Q * A * Z, BB = Q * B * Z


          with Q and Z orthogonal (unitary)= I

       3. '[AA,BB,Z{, LAMBDA}] = qz (A, B, OPT)'

          As in form [2], but allows ordering of generalized eigenpairs
          for (e.g.)  solution of discrete time algebraic Riccati
          equations.  Form 3 is not available for complex matrices, and
          does not compute the generalized eigenvectors V, W, nor the
          orthogonal matrix Q.

          OPT
               for ordering eigenvalues of the GEP pencil.  The leading
               block of the revised pencil contains all eigenvalues that
               satisfy:

               "N"
                    = unordered (default)

               "S"
                    = small: leading block has all |lambda| <= 1

               "B"
                    = big: leading block has all |lambda| >= 1

               "-"
                    = negative real part: leading block has all
                    eigenvalues in the open left half-plane

               "+"
                    = non-negative real part: leading block has all
                    eigenvalues in the closed right half-plane

     Note: 'qz' performs permutation balancing, but not scaling (*note
     XREFbalance::).  The order of output arguments was selected for
     compatibility with MATLAB.

     See also: eig, balance, lu, chol, hess, qr, qzhess, schur, svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
QZ decomposition of the generalized eigenvalue problem (A x = s B  x).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
rand


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3321
 -- Built-in Function: rand (N)
 -- Built-in Function: rand (M, N, ...)
 -- Built-in Function: rand ([M N ...])
 -- Built-in Function: V = rand ("state")
 -- Built-in Function: rand ("state", V)
 -- Built-in Function: rand ("state", "reset")
 -- Built-in Function: V = rand ("seed")
 -- Built-in Function: rand ("seed", V)
 -- Built-in Function: rand ("seed", "reset")
 -- Built-in Function: rand (..., "single")
 -- Built-in Function: rand (..., "double")
     Return a matrix with random elements uniformly distributed on the
     interval (0, 1).  The arguments are handled the same as the
     arguments for 'eye'.

     You can query the state of the random number generator using the
     form

          v = rand ("state")

     This returns a column vector V of length 625.  Later, you can
     restore the random number generator to the state V using the form

          rand ("state", v)

     You may also initialize the state vector from an arbitrary vector
     of length <= 625 for V.  This new state will be a hash based on the
     value of V, not V itself.

     By default, the generator is initialized from '/dev/urandom' if it
     is available, otherwise from CPU time, wall clock time, and the
     current fraction of a second.  Note that this differs from MATLAB,
     which always initializes the state to the same state at startup.
     To obtain behavior comparable to MATLAB, initialize with a
     deterministic state vector in Octave's startup files (*note Startup
     Files::).

     To compute the pseudo-random sequence, 'rand' uses the Mersenne
     Twister with a period of 2^{19937}-1 (See M. Matsumoto and T.
     Nishimura, 'Mersenne Twister: A 623-dimensionally equidistributed
     uniform pseudorandom number generator', ACM Trans.  on Modeling and
     Computer Simulation Vol.  8, No.  1, pp.  3-30, January 1998,
     <http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html>).  Do
     *not* use for cryptography without securely hashing several
     returned values together, otherwise the generator state can be
     learned after reading 624 consecutive values.

     Older versions of Octave used a different random number generator.
     The new generator is used by default as it is significantly faster
     than the old generator, and produces random numbers with a
     significantly longer cycle time.  However, in some circumstances it
     might be desirable to obtain the same random sequences as used by
     the old generators.  To do this the keyword "seed" is used to
     specify that the old generators should be use, as in

          rand ("seed", val)

     which sets the seed of the generator to VAL.  The seed of the
     generator can be queried with

          s = rand ("seed")

     However, it should be noted that querying the seed will not cause
     'rand' to use the old generators, only setting the seed will.  To
     cause 'rand' to once again use the new generators, the keyword
     "state" should be used to reset the state of the 'rand'.

     The state or seed of the generator can be reset to a new random
     value using the "reset" keyword.

     The class of the value returned can be controlled by a trailing
     "double" or "single" argument.  These are the only valid classes.

     See also: randn, rande, randg, randp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
Return a matrix with random elements uniformly distributed on the  interval (0, 1).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
randn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1145
 -- Built-in Function: randn (N)
 -- Built-in Function: randn (M, N, ...)
 -- Built-in Function: randn ([M N ...])
 -- Built-in Function: V = randn ("state")
 -- Built-in Function: randn ("state", V)
 -- Built-in Function: randn ("state", "reset")
 -- Built-in Function: V = randn ("seed")
 -- Built-in Function: randn ("seed", V)
 -- Built-in Function: randn ("seed", "reset")
 -- Built-in Function: randn (..., "single")
 -- Built-in Function: randn (..., "double")
     Return a matrix with normally distributed random elements having
     zero mean and variance one.  The arguments are handled the same as
     the arguments for 'rand'.

     By default, 'randn' uses the Marsaglia and Tsang "Ziggurat
     technique" to transform from a uniform to a normal distribution.

     The class of the value returned can be controlled by a trailing
     "double" or "single" argument.  These are the only valid classes.

     Reference: G. Marsaglia and W.W. Tsang, 'Ziggurat Method for
     Generating Random Variables', J. Statistical Software, vol 5, 2000,
     <http://www.jstatsoft.org/v05/i08/>)

     See also: rand, rande, randg, randp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Return a matrix with normally distributed random elements having  zero mean and variance one.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
rande


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1121
 -- Built-in Function: rande (N)
 -- Built-in Function: rande (M, N, ...)
 -- Built-in Function: rande ([M N ...])
 -- Built-in Function: V = rande ("state")
 -- Built-in Function: rande ("state", V)
 -- Built-in Function: rande ("state", "reset")
 -- Built-in Function: V = rande ("seed")
 -- Built-in Function: rande ("seed", V)
 -- Built-in Function: rande ("seed", "reset")
 -- Built-in Function: rande (..., "single")
 -- Built-in Function: rande (..., "double")
     Return a matrix with exponentially distributed random elements.
     The arguments are handled the same as the arguments for 'rand'.

     By default, 'randn' uses the Marsaglia and Tsang "Ziggurat
     technique" to transform from a uniform to an exponential
     distribution.

     The class of the value returned can be controlled by a trailing
     "double" or "single" argument.  These are the only valid classes.

     Reference: G. Marsaglia and W.W. Tsang, 'Ziggurat Method for
     Generating Random Variables', J. Statistical Software, vol 5, 2000,
     <http://www.jstatsoft.org/v05/i08/>)

     See also: rand, randn, randg, randp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return a matrix with exponentially distributed random elements.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
randg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2037
 -- Built-in Function: randg (N)
 -- Built-in Function: randg (M, N, ...)
 -- Built-in Function: randg ([M N ...])
 -- Built-in Function: V = randg ("state")
 -- Built-in Function: randg ("state", V)
 -- Built-in Function: randg ("state", "reset")
 -- Built-in Function: V = randg ("seed")
 -- Built-in Function: randg ("seed", V)
 -- Built-in Function: randg ("seed", "reset")
 -- Built-in Function: randg (..., "single")
 -- Built-in Function: randg (..., "double")
     Return a matrix with 'gamma (A,1)' distributed random elements.
     The arguments are handled the same as the arguments for 'rand',
     except for the argument A.

     This can be used to generate many distributions:

     'gamma (a, b)' for 'a > -1', 'b > 0'

               r = b * randg (a)

     'beta (a, b)' for 'a > -1', 'b > -1'

               r1 = randg (a, 1)
               r = r1 / (r1 + randg (b, 1))

     'Erlang (a, n)'

               r = a * randg (n)

     'chisq (df)' for 'df > 0'

               r = 2 * randg (df / 2)

     't (df)' for '0 < df < inf' (use randn if df is infinite)

               r = randn () / sqrt (2 * randg (df / 2) / df)

     'F (n1, n2)' for '0 < n1', '0 < n2'

               ## r1 equals 1 if n1 is infinite
               r1 = 2 * randg (n1 / 2) / n1
               ## r2 equals 1 if n2 is infinite
               r2 = 2 * randg (n2 / 2) / n2
               r = r1 / r2


     negative 'binomial (n, p)' for 'n > 0', '0 < p <= 1'

               r = randp ((1 - p) / p * randg (n))

     non-central 'chisq (df, L)', for 'df >= 0' and 'L > 0'
          (use chisq if 'L = 0')

               r = randp (L / 2)
               r(r > 0) = 2 * randg (r(r > 0))
               r(df > 0) += 2 * randg (df(df > 0)/2)

     'Dirichlet (a1, ... ak)'

               r = (randg (a1), ..., randg (ak))
               r = r / sum (r)

     The class of the value returned can be controlled by a trailing
     "double" or "single" argument.  These are the only valid classes.

     See also: rand, randn, rande, randp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return a matrix with 'gamma (A,1)' distributed random elements.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
randp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1903
 -- Built-in Function: randp (L, N)
 -- Built-in Function: randp (L, M, N, ...)
 -- Built-in Function: randp (L, [M N ...])
 -- Built-in Function: V = randp ("state")
 -- Built-in Function: randp ("state", V)
 -- Built-in Function: randp ("state", "reset")
 -- Built-in Function: V = randp ("seed")
 -- Built-in Function: randp ("seed", V)
 -- Built-in Function: randp ("seed", "reset")
 -- Built-in Function: randp (..., "single")
 -- Built-in Function: randp (..., "double")
     Return a matrix with Poisson distributed random elements with mean
     value parameter given by the first argument, L.  The arguments are
     handled the same as the arguments for 'rand', except for the
     argument L.

     Five different algorithms are used depending on the range of L and
     whether or not L is a scalar or a matrix.

     For scalar L <= 12, use direct method.
          W.H. Press, et al., 'Numerical Recipes in C', Cambridge
          University Press, 1992.

     For scalar L > 12, use rejection method.[1]
          W.H. Press, et al., 'Numerical Recipes in C', Cambridge
          University Press, 1992.

     For matrix L <= 10, use inversion method.[2]
          E. Stadlober, et al., WinRand source code, available via FTP.

     For matrix L > 10, use patchwork rejection method.
          E. Stadlober, et al., WinRand source code, available via FTP,
          or H. Zechner, 'Efficient sampling from continuous and
          discrete unimodal distributions', Doctoral Dissertation,
          156pp., Technical University Graz, Austria, 1994.

     For L > 1e8, use normal approximation.
          L. Montanet, et al., 'Review of Particle Properties', Physical
          Review D 50 p1284, 1994.

     The class of the value returned can be controlled by a trailing
     "double" or "single" argument.  These are the only valid classes.

     See also: rand, randn, rande, randg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
Return a matrix with Poisson distributed random elements with mean  value parameter given by the first argument, L.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
randperm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 472
 -- Built-in Function: randperm (N)
 -- Built-in Function: randperm (N, M)
     Return a row vector containing a random permutation of '1:N'.  If M
     is supplied, return M unique entries, sampled without replacement
     from '1:N'.  The complexity is O(N) in memory and O(M) in time,
     unless M < N/5, in which case O(M) memory is used as well.  The
     randomization is performed using rand().  All permutations are
     equally likely.

     See also: perms.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Return a row vector containing a random permutation of '1:N'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
rcond


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 434
 -- Built-in Function: C = rcond (A)
     Compute the 1-norm estimate of the reciprocal condition number as
     returned by LAPACK.  If the matrix is well-conditioned then C will
     be near 1 and if the matrix is poorly conditioned it will be close
     to zero.

     The matrix A must not be sparse.  If the matrix is sparse then
     'condest (A)' or 'rcond (full (A))' should be used instead.

     See also: cond, condest.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Compute the 1-norm estimate of the reciprocal condition number as  returned by LAPACK.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
regexp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5577
 -- Built-in Function: [S, E, TE, M, T, NM, SP] = regexp (STR, PAT)
 -- Built-in Function: [...] = regexp (STR, PAT, "OPT1", ...)
     Regular expression string matching.  Search for PAT in STR and
     return the positions and substrings of any matches, or empty values
     if there are none.

     The matched pattern PAT can include any of the standard regex
     operators, including:

     '.'
          Match any character

     '* + ? {}'
          Repetition operators, representing

          '*'
               Match zero or more times

          '+'
               Match one or more times

          '?'
               Match zero or one times

          '{N}'
               Match exactly N times

          '{N,}'
               Match N or more times

          '{M,N}'
               Match between M and N times

     '[...] [^...]'

          List operators.  The pattern will match any character listed
          between "[" and "]".  If the first character is "^" then the
          pattern is inverted and any character except those listed
          between brackets will match.

          Escape sequences defined below can also be used inside list
          operators.  For example, a template for a floating point
          number might be '[-+.\d]+'.

     '() (?:)'
          Grouping operator.  The first form, parentheses only, also
          creates a token.

     '|'
          Alternation operator.  Match one of a choice of regular
          expressions.  The alternatives must be delimited by the
          grouping operator '()' above.

     '^ $'
          Anchoring operators.  Requires pattern to occur at the start
          ('^') or end ('$') of the string.

     In addition, the following escaped characters have special meaning.

     '\d'
          Match any digit

     '\D'
          Match any non-digit

     '\s'
          Match any whitespace character

     '\S'
          Match any non-whitespace character

     '\w'
          Match any word character

     '\W'
          Match any non-word character

     '\<'
          Match the beginning of a word

     '\>'
          Match the end of a word

     '\B'
          Match within a word

     Implementation Note: For compatibility with MATLAB, ordinary escape
     sequences (e.g., "\n" => newline) are processed in PAT regardless
     of whether PAT has been defined within single quotes.  Use a second
     backslash to stop interpolation of the escape sequence (e.g.,
     "\\n") or use the 'regexptranslate' function.

     The outputs of 'regexp' default to the order given below

     S
          The start indices of each matching substring

     E
          The end indices of each matching substring

     TE
          The extents of each matched token surrounded by '(...)' in PAT

     M
          A cell array of the text of each match

     T
          A cell array of the text of each token matched

     NM
          A structure containing the text of each matched named token,
          with the name being used as the fieldname.  A named token is
          denoted by '(?<name>...)'.

     SP
          A cell array of the text not returned by match, i.e., what
          remains if you split the string based on PAT.

     Particular output arguments, or the order of the output arguments,
     can be selected by additional OPT arguments.  These are strings and
     the correspondence between the output arguments and the optional
     argument are

                    'start'                S
                    'end'                  E
                    'tokenExtents'         TE
                    'match'                M
                    'tokens'               T
                    'names'                NM
                    'split'                SP

     Additional arguments are summarized below.

     'once'
          Return only the first occurrence of the pattern.

     'matchcase'
          Make the matching case sensitive.  (default)

          Alternatively, use (?-i) in the pattern.

     'ignorecase'
          Ignore case when matching the pattern to the string.

          Alternatively, use (?i) in the pattern.

     'stringanchors'
          Match the anchor characters at the beginning and end of the
          string.  (default)

          Alternatively, use (?-m) in the pattern.

     'lineanchors'
          Match the anchor characters at the beginning and end of the
          line.

          Alternatively, use (?m) in the pattern.

     'dotall'
          The pattern '.' matches all characters including the newline
          character.  (default)

          Alternatively, use (?s) in the pattern.

     'dotexceptnewline'
          The pattern '.' matches all characters except the newline
          character.

          Alternatively, use (?-s) in the pattern.

     'literalspacing'
          All characters in the pattern, including whitespace, are
          significant and are used in pattern matching.  (default)

          Alternatively, use (?-x) in the pattern.

     'freespacing'
          The pattern may include arbitrary whitespace and also comments
          beginning with the character '#'.

          Alternatively, use (?x) in the pattern.

     'noemptymatch'
          Zero-length matches are not returned.  (default)

     'emptymatch'
          Return zero-length matches.

          'regexp ('a', 'b*', 'emptymatch')' returns '[1 2]' because
          there are zero or more 'b' characters at positions 1 and
          end-of-string.

     See also: regexpi, strfind, regexprep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Regular expression string matching.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
regexpi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 423
 -- Built-in Function: [S, E, TE, M, T, NM, SP] = regexpi (STR, PAT)
 -- Built-in Function: [...] = regexpi (STR, PAT, "OPT1", ...)

     Case insensitive regular expression string matching.  Search for
     PAT in STR and return the positions and substrings of any matches,
     or empty values if there are none.  *Note regexp: XREFregexp, for
     details on the syntax of the search pattern.

     See also: regexp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Case insensitive regular expression string matching.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
regexprep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1145
 -- Built-in Function: OUTSTR = regexprep (STRING, PAT, REPSTR)
 -- Built-in Function: OUTSTR = regexprep (STRING, PAT, REPSTR, "OPT1",
          ...)
     Replace occurrences of pattern PAT in STRING with REPSTR.

     The pattern is a regular expression as documented for 'regexp'.
     *Note regexp: XREFregexp.

     The replacement string may contain '$i', which substitutes for the
     ith set of parentheses in the match string.  For example,

          regexprep ("Bill Dunn", '(\w+) (\w+)', '$2, $1')

     returns "Dunn, Bill"

     Options in addition to those of 'regexp' are

     'once'
          Replace only the first occurrence of PAT in the result.

     'warnings'
          This option is present for compatibility but is ignored.

     Implementation Note: For compatibility with MATLAB, ordinary escape
     sequences (e.g., "\n" => newline) are processed in both PAT and
     REPSTR regardless of whether they were defined within single
     quotes.  Use a second backslash to stop interpolation of the escape
     sequence (e.g., "\\n") or use the 'regexptranslate' function.

     See also: regexp, regexpi, strrep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
schur


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1768
 -- Built-in Function: S = schur (A)
 -- Built-in Function: S = schur (A, "real")
 -- Built-in Function: S = schur (A, "complex")
 -- Built-in Function: S = schur (A, OPT)
 -- Built-in Function: [U, S] = schur (A, ...)
     Compute the Schur decomposition of A

          S = U' * A * U

     where U is a unitary matrix ('U'* U' is identity) and S is upper
     triangular.  The eigenvalues of A (and S) are the diagonal elements
     of S.  If the matrix A is real, then the real Schur decomposition
     is computed, in which the matrix U is orthogonal and S is block
     upper triangular with blocks of size at most '2 x 2' along the
     diagonal.  The diagonal elements of S (or the eigenvalues of the '2
     x 2' blocks, when appropriate) are the eigenvalues of A and S.

     The default for real matrices is a real Schur decomposition.  A
     complex decomposition may be forced by passing the flag "complex".

     The eigenvalues are optionally ordered along the diagonal according
     to the value of OPT.  'OPT = "a"' indicates that all eigenvalues
     with negative real parts should be moved to the leading block of S
     (used in 'are'), 'OPT = "d"' indicates that all eigenvalues with
     magnitude less than one should be moved to the leading block of S
     (used in 'dare'), and 'OPT = "u"', the default, indicates that no
     ordering of eigenvalues should occur.  The leading K columns of U
     always span the A-invariant subspace corresponding to the K leading
     eigenvalues of S.

     The Schur decomposition is used to compute eigenvalues of a square
     matrix, and has applications in the solution of algebraic Riccati
     equations in control (see 'are' and 'dare').

     See also: rsf2csf, lu, chol, hess, qr, qz, svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Compute the Schur decomposition of A 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rsf2csf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 342
 -- Function File: [U, T] = rsf2csf (UR, TR)
     Convert a real, upper quasi-triangular Schur form TR to a complex,
     upper triangular Schur form T.

     Note that the following relations hold:

     UR * TR * UR' = U * T * U' and 'U' * U' is the identity matrix I.

     Note also that U and T are not unique.

     See also: schur.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Convert a real, upper quasi-triangular Schur form TR to a complex,  upper triangular Schur form T.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
SIG


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
 -- Built-in Function: SIG ()
     Return a structure containing Unix signal names and their defined
     values.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Return a structure containing Unix signal names and their defined  values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
debug_on_interrupt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 757
 -- Built-in Function: VAL = debug_on_interrupt ()
 -- Built-in Function: OLD_VAL = debug_on_interrupt (NEW_VAL)
 -- Built-in Function: debug_on_interrupt (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     will try to enter debugging mode when it receives an interrupt
     signal (typically generated with 'C-c').  If a second interrupt
     signal is received before reaching the debugging mode, a normal
     interrupt will occur.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: debug_on_error, debug_on_warning.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 169
Query or set the internal variable that controls whether Octave  will try to enter debugging mode when it receives an interrupt  signal (typically generated with 'C-c').



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
sighup_dumps_octave_core


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 601
 -- Built-in Function: VAL = sighup_dumps_octave_core ()
 -- Built-in Function: OLD_VAL = sighup_dumps_octave_core (NEW_VAL)
 -- Built-in Function: sighup_dumps_octave_core (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     tries to save all current variables to the file 'octave-workspace'
     if it receives a hangup signal.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
Query or set the internal variable that controls whether Octave  tries to save all current variables to the file 'octave-workspace'  if it receives a hangup signal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
sigterm_dumps_octave_core


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 607
 -- Built-in Function: VAL = sigterm_dumps_octave_core ()
 -- Built-in Function: OLD_VAL = sigterm_dumps_octave_core (NEW_VAL)
 -- Built-in Function: sigterm_dumps_octave_core (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     tries to save all current variables to the file 'octave-workspace'
     if it receives a terminate signal.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 167
Query or set the internal variable that controls whether Octave  tries to save all current variables to the file 'octave-workspace'  if it receives a terminate signal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
issparse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 107
 -- Built-in Function: issparse (X)
     Return true if X is a sparse matrix.

     See also: ismatrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Return true if X is a sparse matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
sparse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2220
 -- Built-in Function: S = sparse (A)
 -- Built-in Function: S = sparse (I, J, SV, M, N)
 -- Built-in Function: S = sparse (I, J, SV)
 -- Built-in Function: S = sparse (M, N)
 -- Built-in Function: S = sparse (I, J, S, M, N, "unique")
 -- Built-in Function: S = sparse (I, J, SV, M, N, NZMAX)
     Create a sparse matrix from a full matrix or row, column, value
     triplets.

     If A is a full matrix, convert it to a sparse matrix
     representation, removing all zero values in the process.

     Given the integer index vectors I and J, and a 1-by-'nnz' vector of
     real or complex values SV, construct the sparse matrix
     'S(I(K),J(K)) = SV(K)' with overall dimensions M and N.  If any of
     SV, I or J are scalars, they are expanded to have a common size.

     If M or N are not specified their values are derived from the
     maximum index in the vectors I and J as given by 'M = max (I)', 'N
     = max (J)'.

     *Note*: if multiple values are specified with the same I, J
     indices, the corresponding value in S will be the sum of the values
     at the repeated location.  See 'accumarray' for an example of how
     to produce different behavior, such as taking the minimum instead.

     If the option "unique" is given, and more than one value is
     specified at the same I, J indices, then the last specified value
     will be used.

     'sparse (M, N)' will create an empty MxN sparse matrix and is
     equivalent to 'sparse ([], [], [], M, N)'

     The argument 'nzmax' is ignored but accepted for compatibility with
     MATLAB.

     Example 1 (sum at repeated indices):

          I = [1 1 2]; J = [1 1 2]; SV = [3 4 5];
          sparse (I, J, SV, 3, 4)
          =>
          Compressed Column Sparse (rows = 3, cols = 4, nnz = 2 [17%])

            (1, 1) ->  7
            (2, 2) ->  5

     Example 2 ("unique" option):

          I = [1 1 2]; J = [1 1 2]; SV = [3 4 5];
          sparse (I, J, SV, 3, 4, "unique")
          =>
          Compressed Column Sparse (rows = 3, cols = 4, nnz = 2 [17%])

            (1, 1) ->  4
            (2, 2) ->  5

     See also: full, accumarray, spalloc, spdiags, speye, spones,
     sprand, sprandn, sprandsym, spconvert, spfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Create a sparse matrix from a full matrix or row, column, value  triplets.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
spalloc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1083
 -- Built-in Function: S = spalloc (M, N, NZ)
     Create an M-by-N sparse matrix with pre-allocated space for at most
     NZ nonzero elements.

     This is useful for building a matrix incrementally by a sequence of
     indexed assignments.  Subsequent indexed assignments after
     'spalloc' will reuse the pre-allocated memory, provided they are of
     one of the simple forms

        * 'S(I:J) = X'

        * 'S(:,I:J) = X'

        * 'S(K:L,I:J) = X'

     and that the following conditions are met:

        * the assignment does not decrease nnz (S).

        * after the assignment, nnz (S) does not exceed NZ.

        * no index is out of bounds.

     Partial movement of data may still occur, but in general the
     assignment will be more memory and time efficient under these
     circumstances.  In particular, it is possible to efficiently build
     a pre-allocated sparse matrix from a contiguous block of columns.

     The amount of pre-allocated memory for a given matrix may be
     queried using the function 'nzmax'.

     See also: nzmax, sparse.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
Create an M-by-N sparse matrix with pre-allocated space for at most  NZ nonzero elements.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
spparms


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2439
 -- Built-in Function: spparms ()
 -- Built-in Function: VALS = spparms ()
 -- Built-in Function: [KEYS, VALS] = spparms ()
 -- Built-in Function: VAL = spparms (KEY)
 -- Built-in Function: spparms (VALS)
 -- Built-in Function: spparms ("defaults")
 -- Built-in Function: spparms ("tight")
 -- Built-in Function: spparms (KEY, VAL)
     Query or set the parameters used by the sparse solvers and
     factorization functions.  The first four calls above get
     information about the current settings, while the others change the
     current settings.  The parameters are stored as pairs of keys and
     values, where the values are all floats and the keys are one of the
     following strings:

     'spumoni'
          Printing level of debugging information of the solvers
          (default 0)

     'ths_rel'
          Included for compatibility.  Not used.  (default 1)

     'ths_abs'
          Included for compatibility.  Not used.  (default 1)

     'exact_d'
          Included for compatibility.  Not used.  (default 0)

     'supernd'
          Included for compatibility.  Not used.  (default 3)

     'rreduce'
          Included for compatibility.  Not used.  (default 3)

     'wh_frac'
          Included for compatibility.  Not used.  (default 0.5)

     'autommd'
          Flag whether the LU/QR and the '\' and '/' operators will
          automatically use the sparsity preserving mmd functions
          (default 1)

     'autoamd'
          Flag whether the LU and the '\' and '/' operators will
          automatically use the sparsity preserving amd functions
          (default 1)

     'piv_tol'
          The pivot tolerance of the UMFPACK solvers (default 0.1)

     'sym_tol'
          The pivot tolerance of the UMFPACK symmetric solvers (default
          0.001)

     'bandden'
          The density of non-zero elements in a banded matrix before it
          is treated by the LAPACK banded solvers (default 0.5)

     'umfpack'
          Flag whether the UMFPACK or mmd solvers are used for the LU,
          '\' and '/' operations (default 1)

     The value of individual keys can be set with 'spparms (KEY, VAL)'.
     The default values can be restored with the special keyword
     "defaults".  The special keyword "tight" can be used to set the mmd
     solvers to attempt a sparser solution at the potential cost of
     longer running time.

     See also: chol, colamd, lu, qr, symamd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Query or set the parameters used by the sparse solvers and  factorization functions.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
sqrtm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 365
 -- Built-in Function: S = sqrtm (A)
 -- Built-in Function: [S, ERROR_ESTIMATE] = sqrtm (A)
     Compute the matrix square root of the square matrix A.

     Ref: N.J. Higham.  'A New sqrtm for MATLAB'.  Numerical Analysis
     Report No.  336, Manchester Centre for Computational Mathematics,
     Manchester, England, January 1999.

     See also: expm, logm.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Compute the matrix square root of the square matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
str2double


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1571
 -- Built-in Function: str2double (S)
     Convert a string to a real or complex number.

     The string must be in one of the following formats where a and b
     are real numbers and the complex unit is 'i' or 'j':

        * a + bi

        * a + b*i

        * a + i*b

        * bi + a

        * b*i + a

        * i*b + a

     If present, a and/or b are of the form [+-]d[,.]d[[eE][+-]d] where
     the brackets indicate optional arguments and 'd' indicates zero or
     more digits.  The special input values 'Inf', 'NaN', and 'NA' are
     also accepted.

     S may be a character string, character matrix, or cell array.  For
     character arrays the conversion is repeated for every row, and a
     double or complex array is returned.  Empty rows in S are deleted
     and not returned in the numeric array.  For cell arrays each
     character string element is processed and a double or complex array
     of the same dimensions as S is returned.

     For unconvertible scalar or character string input 'str2double'
     returns a NaN.  Similarly, for character array input 'str2double'
     returns a NaN for any row of S that could not be converted.  For a
     cell array, 'str2double' returns a NaN for any element of S for
     which conversion fails.  Note that numeric elements in a mixed
     string/numeric cell array are not strings and the conversion will
     fail for these elements and return NaN.

     'str2double' can replace 'str2num', and it avoids the security risk
     of using 'eval' on unknown data.

     See also: str2num.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Convert a string to a real or complex number.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strfind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1199
 -- Built-in Function: IDX = strfind (STR, PATTERN)
 -- Built-in Function: IDX = strfind (CELLSTR, PATTERN)
 -- Built-in Function: IDX = strfind (..., "overlaps", VAL)
     Search for PATTERN in the string STR and return the starting index
     of every such occurrence in the vector IDX.

     If there is no such occurrence, or if PATTERN is longer than STR,
     then IDX is the empty array '[]'.  The optional argument "overlaps"
     determines whether the pattern can match at every position in STR
     (true), or only for unique occurrences of the complete pattern
     (false).  The default is true.

     If a cell array of strings CELLSTR is specified then IDX is a cell
     array of vectors, as specified above.

     Examples:

          strfind ("abababa", "aba")
               => [1, 3, 5]

          strfind ("abababa", "aba", "overlaps", false)
               => [1, 5]

          strfind ({"abababa", "bebebe", "ab"}, "aba")
               =>
                  {
                    [1,1] =

                       1   3   5

                    [1,2] = [](1x0)
                    [1,3] = [](1x0)
                  }

     See also: findstr, strmatch, regexp, regexpi, find.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
Search for PATTERN in the string STR and return the starting index  of every such occurrence in the vector IDX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
strrep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 798
 -- Built-in Function: NEWSTR = strrep (STR, PTN, REP)
 -- Built-in Function: NEWSTR = strrep (CELLSTR, PTN, REP)
 -- Built-in Function: NEWSTR = strrep (..., "overlaps", VAL)
     Replace all occurrences of the pattern PTN in the string STR with
     the string REP and return the result.

     The optional argument "overlaps" determines whether the pattern can
     match at every position in STR (true), or only for unique
     occurrences of the complete pattern (false).  The default is true.

     S may also be a cell array of strings, in which case the
     replacement is done for each element and a cell array is returned.

     Example:

          strrep ("This is a test string", "is", "&%$")
              =>  "Th&%$ &%$ a test string"

     See also: regexprep, strfind, findstr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
Replace all occurrences of the pattern PTN in the string STR with  the string REP and return the result.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
char


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1142
 -- Built-in Function: char (X)
 -- Built-in Function: char (X, ...)
 -- Built-in Function: char (S1, S2, ...)
 -- Built-in Function: char (CELL_ARRAY)
     Create a string array from one or more numeric matrices, character
     matrices, or cell arrays.  Arguments are concatenated vertically.
     The returned values are padded with blanks as needed to make each
     row of the string array have the same length.  Empty input strings
     are significant and will concatenated in the output.

     For numerical input, each element is converted to the corresponding
     ASCII character.  A range error results if an input is outside the
     ASCII range (0-255).

     For cell arrays, each element is concatenated separately.  Cell
     arrays converted through 'char' can mostly be converted back with
     'cellstr'.  For example:

          char ([97, 98, 99], "", {"98", "99", 100}, "str1", ["ha", "lf"])
             => ["abc    "
                 "       "
                 "98     "
                 "99     "
                 "d      "
                 "str1   "
                 "half   "]

     See also: strvcat, cellstr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Create a string array from one or more numeric matrices, character  matrices, or cell arrays.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strvcat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1168
 -- Built-in Function: strvcat (X)
 -- Built-in Function: strvcat (X, ...)
 -- Built-in Function: strvcat (S1, S2, ...)
 -- Built-in Function: strvcat (CELL_ARRAY)
     Create a character array from one or more numeric matrices,
     character matrices, or cell arrays.  Arguments are concatenated
     vertically.  The returned values are padded with blanks as needed
     to make each row of the string array have the same length.  Unlike
     'char', empty strings are removed and will not appear in the
     output.

     For numerical input, each element is converted to the corresponding
     ASCII character.  A range error results if an input is outside the
     ASCII range (0-255).

     For cell arrays, each element is concatenated separately.  Cell
     arrays converted through 'strvcat' can mostly be converted back
     with 'cellstr'.  For example:

          strvcat ([97, 98, 99], "", {"98", "99", 100}, "str1", ["ha", "lf"])
                => ["abc    "
                    "98     "
                    "99     "
                    "d      "
                    "str1   "
                    "half   "]

     See also: char, strcat, cstrcat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Create a character array from one or more numeric matrices,  character matrices, or cell arrays.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ischar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 155
 -- Built-in Function: ischar (X)
     Return true if X is a character array.

     See also: isfloat, isinteger, islogical, isnumeric, iscellstr, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return true if X is a character array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
strcmp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 709
 -- Built-in Function: strcmp (S1, S2)
     Return 1 if the character strings S1 and S2 are the same, and 0
     otherwise.

     If either S1 or S2 is a cell array of strings, then an array of the
     same size is returned, containing the values described above for
     every member of the cell array.  The other argument may also be a
     cell array of strings (of the same size or with only one element),
     char matrix or character string.

     *Caution:* For compatibility with MATLAB, Octave's strcmp function
     returns 1 if the character strings are equal, and 0 otherwise.
     This is just the opposite of the corresponding C library function.

     See also: strcmpi, strncmp, strncmpi.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return 1 if the character strings S1 and S2 are the same, and 0  otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strncmp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 868
 -- Built-in Function: strncmp (S1, S2, N)
     Return 1 if the first N characters of strings S1 and S2 are the
     same, and 0 otherwise.

          strncmp ("abce", "abcd", 3)
                => 1

     If either S1 or S2 is a cell array of strings, then an array of the
     same size is returned, containing the values described above for
     every member of the cell array.  The other argument may also be a
     cell array of strings (of the same size or with only one element),
     char matrix or character string.

          strncmp ("abce", {"abcd", "bca", "abc"}, 3)
               => [1, 0, 1]

     *Caution:* For compatibility with MATLAB, Octave's strncmp function
     returns 1 if the character strings are equal, and 0 otherwise.
     This is just the opposite of the corresponding C library function.

     See also: strncmpi, strcmp, strcmpi.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Return 1 if the first N characters of strings S1 and S2 are the  same, and 0 otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strcmpi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 808
 -- Built-in Function: strcmpi (S1, S2)
     Return 1 if the character strings S1 and S2 are the same,
     disregarding case of alphabetic characters, and 0 otherwise.

     If either S1 or S2 is a cell array of strings, then an array of the
     same size is returned, containing the values described above for
     every member of the cell array.  The other argument may also be a
     cell array of strings (of the same size or with only one element),
     char matrix or character string.

     *Caution:* For compatibility with MATLAB, Octave's strcmp function
     returns 1 if the character strings are equal, and 0 otherwise.
     This is just the opposite of the corresponding C library function.

     *Caution:* National alphabets are not supported.

     See also: strcmp, strncmp, strncmpi.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 119
Return 1 if the character strings S1 and S2 are the same,  disregarding case of alphabetic characters, and 0 otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
strncmpi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 822
 -- Built-in Function: strncmpi (S1, S2, N)
     Return 1 if the first N character of S1 and S2 are the same,
     disregarding case of alphabetic characters, and 0 otherwise.

     If either S1 or S2 is a cell array of strings, then an array of the
     same size is returned, containing the values described above for
     every member of the cell array.  The other argument may also be a
     cell array of strings (of the same size or with only one element),
     char matrix or character string.

     *Caution:* For compatibility with MATLAB, Octave's strncmpi
     function returns 1 if the character strings are equal, and 0
     otherwise.  This is just the opposite of the corresponding C
     library function.

     *Caution:* National alphabets are not supported.

     See also: strncmp, strcmp, strcmpi.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 122
Return 1 if the first N character of S1 and S2 are the same,  disregarding case of alphabetic characters, and 0 otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
list_in_columns


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1073
 -- Built-in Function: list_in_columns (ARG, WIDTH, PREFIX)
     Return a string containing the elements of ARG listed in columns
     with an overall maximum width of WIDTH and optional prefix PREFIX.
     The argument ARG must be a cell array of character strings or a
     character array.  If WIDTH is not specified or is an empty matrix,
     or less than or equal to zero, the width of the terminal screen is
     used.  Newline characters are used to break the lines in the output
     string.  For example:

          list_in_columns ({"abc", "def", "ghijkl", "mnop", "qrs", "tuv"}, 20)
               => abc     mnop
                  def     qrs
                  ghijkl  tuv

          whos ans
               =>
               Variables in the current scope:

                 Attr Name        Size                     Bytes  Class
                 ==== ====        ====                     =====  =====
                      ans         1x37                        37  char

               Total is 37 elements using 37 bytes

     See also: terminal_size.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
Return a string containing the elements of ARG listed in columns  with an overall maximum width of WIDTH and optional prefix PREFIX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
sub2ind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 474
 -- Function File: IND = sub2ind (DIMS, I, J)
 -- Function File: IND = sub2ind (DIMS, S1, S2, ..., SN)
     Convert subscripts to a linear index.

     The following example shows how to convert the two-dimensional
     index '(2,3)' of a 3-by-3 matrix to a linear index.  The matrix is
     linearly indexed moving from one column to next, filling up all
     rows in each column.

          linear_index = sub2ind ([3, 3], 2, 3)
          => 8

     See also: ind2sub.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Convert subscripts to a linear index.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ind2sub


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 435
 -- Function File: [S1, S2, ..., SN] = ind2sub (DIMS, IND)
     Convert a linear index to subscripts.

     The following example shows how to convert the linear index '8' in
     a 3-by-3 matrix into a subscript.  The matrix is linearly indexed
     moving from one column to next, filling up all rows in each column.

          [r, c] = ind2sub ([3, 3], 8)
              => r =  2
              => c =  3

     See also: sub2ind.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Convert a linear index to subscripts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
svd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1171
 -- Built-in Function: S = svd (A)
 -- Built-in Function: [U, S, V] = svd (A)
 -- Built-in Function: [U, S, V] = svd (A, ECON)
     Compute the singular value decomposition of A

          A = U*S*V'

     The function 'svd' normally returns only the vector of singular
     values.  When called with three return values, it computes U, S,
     and V.  For example,

          svd (hilb (3))

     returns

          ans =

            1.4083189
            0.1223271
            0.0026873

     and

          [u, s, v] = svd (hilb (3))

     returns

          u =

            -0.82704   0.54745   0.12766
            -0.45986  -0.52829  -0.71375
            -0.32330  -0.64901   0.68867

          s =

            1.40832  0.00000  0.00000
            0.00000  0.12233  0.00000
            0.00000  0.00000  0.00269

          v =

            -0.82704   0.54745   0.12766
            -0.45986  -0.52829  -0.71375
            -0.32330  -0.64901   0.68867

     If given a second argument, 'svd' returns an economy-sized
     decomposition, eliminating the unnecessary rows or columns of U or
     V.

     See also: svd_driver, svds, eig, lu, chol, hess, qr, qz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Compute the singular value decomposition of A 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
svd_driver


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 548
 -- Built-in Function: VAL = svd_driver ()
 -- Built-in Function: OLD_VAL = svd_driver (NEW_VAL)
 -- Built-in Function: svd_driver (NEW_VAL, "local")
     Query or set the underlying LAPACK driver used by 'svd'.  Currently
     recognized values are "gesvd" and "gesdd".  The default is "gesvd".

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Query or set the underlying LAPACK driver used by 'svd'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
syl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 282
 -- Built-in Function: X = syl (A, B, C)
     Solve the Sylvester equation

          A X + X B + C = 0

     using standard LAPACK subroutines.  For example:

          syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12])
             => [ -0.50000, -0.66667; -0.66667, -0.50000 ]
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Solve the Sylvester equation 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
ignore_function_time_stamp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 872
 -- Built-in Function: VAL = ignore_function_time_stamp ()
 -- Built-in Function: OLD_VAL = ignore_function_time_stamp (NEW_VAL)
     Query or set the internal variable that controls whether Octave
     checks the time stamp on files each time it looks up functions
     defined in function files.  If the internal variable is set to
     "system", Octave will not automatically recompile function files in
     subdirectories of 'OCTAVE-HOME/lib/VERSION' if they have changed
     since they were last compiled, but will recompile other function
     files in the search path if they change.  If set to "all", Octave
     will not recompile any function files unless their definitions are
     removed with 'clear'.  If set to "none", Octave will always check
     time stamps on files to determine whether functions defined in
     function files need to recompiled.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 155
Query or set the internal variable that controls whether Octave  checks the time stamp on files each time it looks up functions  defined in function files.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
dup2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 254
 -- Built-in Function: [FID, MSG] = dup2 (OLD, NEW)
     Duplicate a file descriptor.

     If successful, FID is greater than zero and contains the new file
     ID.  Otherwise, FID is negative and MSG contains a system-dependent
     error message.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Duplicate a file descriptor.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
exec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 505
 -- Built-in Function: [ERR, MSG] = exec (FILE, ARGS)
     Replace current process with a new process.  Calling 'exec' without
     first calling 'fork' will terminate your current Octave process and
     replace it with the program named by FILE.  For example,

          exec ("ls" "-l")

     will run 'ls' and return you to your shell prompt.

     If successful, 'exec' does not return.  If 'exec' does return, ERR
     will be nonzero, and MSG will contain a system-dependent error
     message.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Replace current process with a new process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
popen2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1315
 -- Built-in Function: [IN, OUT, PID] = popen2 (COMMAND, ARGS)
     Start a subprocess with two-way communication.  The name of the
     process is given by COMMAND, and ARGS is an array of strings
     containing options for the command.  The file identifiers for the
     input and output streams of the subprocess are returned in IN and
     OUT.  If execution of the command is successful, PID contains the
     process ID of the subprocess.  Otherwise, PID is -1.

     For example:

          [in, out, pid] = popen2 ("sort", "-r");
          fputs (in, "these\nare\nsome\nstrings\n");
          fclose (in);
          EAGAIN = errno ("EAGAIN");
          done = false;
          do
            s = fgets (out);
            if (ischar (s))
              fputs (stdout, s);
            elseif (errno () == EAGAIN)
              sleep (0.1);
              fclear (out);
            else
              done = true;
            endif
          until (done)
          fclose (out);
          waitpid (pid);

             -| these
             -| strings
             -| some
             -| are

     Note that 'popen2', unlike 'popen', will not "reap" the child
     process.  If you don't use 'waitpid' to check the child's exit
     status, it will linger until Octave exits.

     See also: popen, waitpid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Start a subprocess with two-way communication.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fcntl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1352
 -- Built-in Function: [ERR, MSG] = fcntl (FID, REQUEST, ARG)
     Change the properties of the open file FID.  The following values
     may be passed as REQUEST:

     'F_DUPFD'
          Return a duplicate file descriptor.

     'F_GETFD'
          Return the file descriptor flags for FID.

     'F_SETFD'
          Set the file descriptor flags for FID.

     'F_GETFL'
          Return the file status flags for FID.  The following codes may
          be returned (some of the flags may be undefined on some
          systems).

          'O_RDONLY'
               Open for reading only.

          'O_WRONLY'
               Open for writing only.

          'O_RDWR'
               Open for reading and writing.

          'O_APPEND'
               Append on each write.

          'O_CREAT'
               Create the file if it does not exist.

          'O_NONBLOCK'
               Non-blocking mode.

          'O_SYNC'
               Wait for writes to complete.

          'O_ASYNC'
               Asynchronous I/O.

     'F_SETFL'
          Set the file status flags for FID to the value specified by
          ARG.  The only flags that can be changed are 'O_APPEND' and
          'O_NONBLOCK'.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR
     is nonzero and MSG contains a system-dependent error message.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Change the properties of the open file FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fork


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 690
 -- Built-in Function: [PID, MSG] = fork ()
     Create a copy of the current process.

     Fork can return one of the following values:

     > 0
          You are in the parent process.  The value returned from 'fork'
          is the process id of the child process.  You should probably
          arrange to wait for any child processes to exit.

     0
          You are in the child process.  You can call 'exec' to start
          another process.  If that fails, you should probably call
          'exit'.

     < 0
          The call to 'fork' failed for some reason.  You must take
          evasive action.  A system dependent error message will be
          waiting in MSG.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Create a copy of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
getpgrp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
 -- Built-in Function: pgid = getpgrp ()
     Return the process group id of the current process.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return the process group id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
getpid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
 -- Built-in Function: pid = getpid ()
     Return the process id of the current process.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Return the process id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
getppid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
 -- Built-in Function: pid = getppid ()
     Return the process id of the parent process.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return the process id of the parent process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
getegid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
 -- Built-in Function: egid = getegid ()
     Return the effective group id of the current process.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return the effective group id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
getgid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
 -- Built-in Function: gid = getgid ()
     Return the real group id of the current process.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the real group id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
geteuid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
 -- Built-in Function: euid = geteuid ()
     Return the effective user id of the current process.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return the effective user id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
getuid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
 -- Built-in Function: uid = getuid ()
     Return the real user id of the current process.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return the real user id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
kill


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 585
 -- Built-in Function: [ERR, MSG] = kill (PID, SIG)
     Send signal SIG to process PID.

     If PID is positive, then signal SIG is sent to PID.

     If PID is 0, then signal SIG is sent to every process in the
     process group of the current process.

     If PID is -1, then signal SIG is sent to every process except
     process 1.

     If PID is less than -1, then signal SIG is sent to every process in
     the process group -PID.

     If SIG is 0, then no signal is sent, but error checking is still
     performed.

     Return 0 if successful, otherwise return -1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Send signal SIG to process PID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
lstat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 302
 -- Built-in Function: INFO = lstat (SYMLINK)
 -- Built-in Function: [INFO, ERR, MSG] = lstat (SYMLINK)
     Return a structure INFO containing information about the symbolic
     link SYMLINK.

     The function outputs are described in the documentation for 'stat'.

     See also: stat, symlink.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a structure INFO containing information about the symbolic  link SYMLINK.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mkfifo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 328
 -- Built-in Function: mkfifo (NAME, MODE)
 -- Built-in Function: [ERR, MSG] = mkfifo (NAME, MODE)
     Create a FIFO special file named NAME with file mode MODE

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR
     is nonzero and MSG contains a system-dependent error message.

     See also: pipe.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Create a FIFO special file named NAME with file mode MODE 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
pipe


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 347
 -- Built-in Function: [READ_FD, WRITE_FD, ERR, MSG] = pipe ()
     Create a pipe and return the reading and writing ends of the pipe
     into READ_FD and WRITE_FD respectively.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR
     is nonzero and MSG contains a system-dependent error message.

     See also: mkfifo.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 106
Create a pipe and return the reading and writing ends of the pipe  into READ_FD and WRITE_FD respectively.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
stat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2625
 -- Built-in Function: [INFO, ERR, MSG] = stat (FILE)
 -- Built-in Function: [INFO, ERR, MSG] = stat (FID)
 -- Built-in Function: [INFO, ERR, MSG] = lstat (FILE)
 -- Built-in Function: [INFO, ERR, MSG] = lstat (FID)
     Return a structure INFO containing the following information about
     FILE or file identifier FID.

     'dev'
          ID of device containing a directory entry for this file.

     'ino'
          File number of the file.

     'mode'
          File mode, as an integer.  Use the functions 'S_ISREG',
          'S_ISDIR', 'S_ISCHR', 'S_ISBLK', 'S_ISFIFO', 'S_ISLNK', or 'S_ISSOCK'
          to extract information from this value.

     'modestr'
          File mode, as a string of ten letters or dashes as would be
          returned by 'ls -l'.

     'nlink'
          Number of links.

     'uid'
          User ID of file's owner.

     'gid'
          Group ID of file's group.

     'rdev'
          ID of device for block or character special files.

     'size'
          Size in bytes.

     'atime'
          Time of last access in the same form as time values returned
          from 'time'.  *Note Timing Utilities::.

     'mtime'
          Time of last modification in the same form as time values
          returned from 'time'.  *Note Timing Utilities::.

     'ctime'
          Time of last file status change in the same form as time
          values returned from 'time'.  *Note Timing Utilities::.

     'blksize'
          Size of blocks in the file.

     'blocks'
          Number of blocks allocated for file.

     If the call is successful ERR is 0 and MSG is an empty string.  If
     the file does not exist, or some other error occurs, INFO is an
     empty matrix, ERR is -1, and MSG contains the corresponding system
     error message.

     If FILE is a symbolic link, 'stat' will return information about
     the actual file that is referenced by the link.  Use 'lstat' if you
     want information about the symbolic link itself.

     For example:

          [info, err, msg] = stat ("/vmlinuz")
            => info =
               {
                 atime = 855399756
                 rdev = 0
                 ctime = 847219094
                 uid = 0
                 size = 389218
                 blksize = 4096
                 mtime = 847219094
                 gid = 6
                 nlink = 1
                 blocks = 768
                 mode = -rw-r--r--
                 modestr = -rw-r--r--
                 ino = 9316
                 dev = 2049
               }
            => err = 0
            => msg =

     See also: lstat, ls, dir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Return a structure INFO containing the following information about  FILE or file identifier FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
S_ISREG


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 199
 -- Built-in Function: S_ISREG (MODE)
     Return true if MODE corresponds to a regular file.

     The value of MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return true if MODE corresponds to a regular file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
S_ISDIR


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 196
 -- Built-in Function: S_ISDIR (MODE)
     Return true if MODE corresponds to a directory.

     The value of MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return true if MODE corresponds to a directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
S_ISCHR


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 203
 -- Built-in Function: S_ISCHR (MODE)
     Return true if MODE corresponds to a character device.

     The value of MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Return true if MODE corresponds to a character device.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
S_ISBLK


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 199
 -- Built-in Function: S_ISBLK (MODE)
     Return true if MODE corresponds to a block device.

     The value of MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return true if MODE corresponds to a block device.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
S_ISFIFO


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 192
 -- Built-in Function: S_ISFIFO (MODE)
     Return true if MODE corresponds to a fifo.

     The value of MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Return true if MODE corresponds to a fifo.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
S_ISLNK


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 200
 -- Built-in Function: S_ISLNK (MODE)
     Return true if MODE corresponds to a symbolic link.

     The value of MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return true if MODE corresponds to a symbolic link.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
S_ISSOCK


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 194
 -- Built-in Function: S_ISSOCK (MODE)
     Return true if MODE corresponds to a socket.

     The value of MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return true if MODE corresponds to a socket.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
gethostname


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
 -- Built-in Function: gethostname ()
     Return the hostname of the system where Octave is running.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Return the hostname of the system where Octave is running.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
uname


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 539
 -- Built-in Function: [UTS, ERR, MSG] = uname ()
     Return system information in the structure.  For example:

          uname ()
             => {
                   sysname = x86_64
                   nodename = segfault
                   release = 2.6.15-1-amd64-k8-smp
                   version = Linux
                   machine = #2 SMP Thu Feb 23 04:57:49 UTC 2006
                }

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR
     is nonzero and MSG contains a system-dependent error message.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Return system information in the structure.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
unlink


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 227
 -- Built-in Function: [ERR, MSG] = unlink (FILE)
     Delete the file named FILE.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR
     is nonzero and MSG contains a system-dependent error message.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Delete the file named FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
waitpid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1493
 -- Built-in Function: [PID, STATUS, MSG] = waitpid (PID, OPTIONS)
     Wait for process PID to terminate.  The PID argument can be:

     -1
          Wait for any child process.

     0
          Wait for any child process whose process group ID is equal to
          that of the Octave interpreter process.

     > 0
          Wait for termination of the child process with ID PID.

     The OPTIONS argument can be a bitwise OR of zero or more of the
     following constants:

     '0'
          Wait until signal is received or a child process exits (this
          is the default if the OPTIONS argument is missing).

     'WNOHANG'
          Do not hang if status is not immediately available.

     'WUNTRACED'
          Report the status of any child processes that are stopped, and
          whose status has not yet been reported since they stopped.

     'WCONTINUE'
          Return if a stopped child has been resumed by delivery of
          'SIGCONT'.  This value may not be meaningful on all systems.

     If the returned value of PID is greater than 0, it is the process
     ID of the child process that exited.  If an error occurs, PID will
     be less than zero and MSG will contain a system-dependent error
     message.  The value of STATUS contains additional system-dependent
     information about the subprocess that exited.

     See also: WCONTINUE, WCOREDUMP, WEXITSTATUS, WIFCONTINUED,
     WIFSIGNALED, WIFSTOPPED, WNOHANG, WSTOPSIG, WTERMSIG, WUNTRACED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Wait for process PID to terminate.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
WIFEXITED


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 253
 -- Built-in Function: WIFEXITED (STATUS)
     Given STATUS from a call to 'waitpid', return true if the child
     terminated normally.

     See also: waitpid, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
Given STATUS from a call to 'waitpid', return true if the child  terminated normally.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
WEXITSTATUS


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 318
 -- Built-in Function: WEXITSTATUS (STATUS)
     Given STATUS from a call to 'waitpid', return the exit status of
     the child.  This function should only be employed if 'WIFEXITED'
     returned true.

     See also: waitpid, WIFEXITED, WIFSIGNALED, WTERMSIG, WCOREDUMP,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Given STATUS from a call to 'waitpid', return the exit status of  the child.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
WIFSIGNALED


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 268
 -- Built-in Function: WIFSIGNALED (STATUS)
     Given STATUS from a call to 'waitpid', return true if the child
     process was terminated by a signal.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WTERMSIG, WCOREDUMP,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
Given STATUS from a call to 'waitpid', return true if the child  process was terminated by a signal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
WTERMSIG


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 359
 -- Built-in Function: WTERMSIG (STATUS)
     Given STATUS from a call to 'waitpid', return the number of the
     signal that caused the child process to terminate.  This function
     should only be employed if 'WIFSIGNALED' returned true.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WCOREDUMP,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
Given STATUS from a call to 'waitpid', return the number of the  signal that caused the child process to terminate.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
WCOREDUMP


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 486
 -- Built-in Function: WCOREDUMP (STATUS)
     Given STATUS from a call to 'waitpid', return true if the child
     produced a core dump.  This function should only be employed if
     'WIFSIGNALED' returned true.  The macro used to implement this
     function is not specified in POSIX.1-2001 and is not available on
     some Unix implementations (e.g., AIX, SunOS).

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Given STATUS from a call to 'waitpid', return true if the child  produced a core dump.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
WIFSTOPPED


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 399
 -- Built-in Function: WIFSTOPPED (STATUS)
     Given STATUS from a call to 'waitpid', return true if the child
     process was stopped by delivery of a signal; this is only possible
     if the call was done using 'WUNTRACED' or when the child is being
     traced (see ptrace(2)).

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG,
     WCOREDUMP, WSTOPSIG, WIFCONTINUED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 223
Given STATUS from a call to 'waitpid', return true if the child  process was stopped by delivery of a signal; this is only possible  if the call was done using 'WUNTRACED' or when the child is being  traced (see ptrace(2)).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
WSTOPSIG


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 346
 -- Built-in Function: WSTOPSIG (STATUS)
     Given STATUS from a call to 'waitpid', return the number of the
     signal which caused the child to stop.  This function should only
     be employed if 'WIFSTOPPED' returned true.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG,
     WCOREDUMP, WIFSTOPPED, WIFCONTINUED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Given STATUS from a call to 'waitpid', return the number of the  signal which caused the child to stop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
WIFCONTINUED


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 278
 -- Built-in Function: WIFCONTINUED (STATUS)
     Given STATUS from a call to 'waitpid', return true if the child
     process was resumed by delivery of 'SIGCONT'.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG,
     WCOREDUMP, WIFSTOPPED, WSTOPSIG.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
Given STATUS from a call to 'waitpid', return true if the child  process was resumed by delivery of 'SIGCONT'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
canonicalize_file_name


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 300
 -- Built-in Function: [CNAME, STATUS, MSG] = canonicalize_file_name
          (FNAME)
     Return the canonical name of file FNAME.  If the file does not
     exist the empty string ("") is returned.

     See also: make_absolute_filename, is_absolute_filename,
     is_rooted_relative_filename.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
(FNAME)  Return the canonical name of file FNAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
F_DUPFD


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 191
 -- Built-in Function: F_DUPFD ()
     Return the numerical value to pass to 'fcntl' to return a duplicate
     file descriptor.

     See also: fcntl, F_GETFD, F_GETFL, F_SETFD, F_SETFL.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
Return the numerical value to pass to 'fcntl' to return a duplicate  file descriptor.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
F_GETFD


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 189
 -- Built-in Function: F_GETFD ()
     Return the numerical value to pass to 'fcntl' to return the file
     descriptor flags.

     See also: fcntl, F_DUPFD, F_GETFL, F_SETFD, F_SETFL.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
Return the numerical value to pass to 'fcntl' to return the file  descriptor flags.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
F_GETFL


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 185
 -- Built-in Function: F_GETFL ()
     Return the numerical value to pass to 'fcntl' to return the file
     status flags.

     See also: fcntl, F_DUPFD, F_GETFD, F_SETFD, F_SETFL.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Return the numerical value to pass to 'fcntl' to return the file  status flags.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
F_SETFD


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 186
 -- Built-in Function: F_SETFD ()
     Return the numerical value to pass to 'fcntl' to set the file
     descriptor flags.

     See also: fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFL.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value to pass to 'fcntl' to set the file  descriptor flags.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
F_SETFL


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 182
 -- Built-in Function: F_SETFL ()
     Return the numerical value to pass to 'fcntl' to set the file
     status flags.

     See also: fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFD.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Return the numerical value to pass to 'fcntl' to set the file  status flags.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
O_APPEND


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 355
 -- Built-in Function: O_APPEND ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate each write operation appends, or
     that may be passed to 'fcntl' to set the write mode to append.

     See also: fcntl, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 192
Return the numerical value of the file status flag that may be  returned by 'fcntl' to indicate each write operation appends, or  that may be passed to 'fcntl' to set the write mode to append.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
O_ASYNC


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 272
 -- Built-in Function: O_ASYNC ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate asynchronous I/O.

     See also: fcntl, O_APPEND, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
Return the numerical value of the file status flag that may be  returned by 'fcntl' to indicate asynchronous I/O.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
O_CREAT


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 311
 -- Built-in Function: O_CREAT ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate that a file should be created if it
     does not exist.

     See also: fcntl, O_APPEND, O_ASYNC, O_EXCL, O_NONBLOCK, O_RDONLY,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 148
Return the numerical value of the file status flag that may be  returned by 'fcntl' to indicate that a file should be created if it  does not exist.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
O_EXCL


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 281
 -- Built-in Function: O_EXCL ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate that file locking is used.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_NONBLOCK, O_RDONLY,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 122
Return the numerical value of the file status flag that may be  returned by 'fcntl' to indicate that file locking is used.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
O_NONBLOCK


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 351
 -- Built-in Function: O_NONBLOCK ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate that non-blocking I/O is in use, or
     that may be passsed to 'fcntl' to set non-blocking I/O.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_RDONLY,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 188
Return the numerical value of the file status flag that may be  returned by 'fcntl' to indicate that non-blocking I/O is in use, or  that may be passsed to 'fcntl' to set non-blocking I/O.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
O_RDONLY


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 297
 -- Built-in Function: O_RDONLY ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate that a file is open for reading
     only.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
Return the numerical value of the file status flag that may be  returned by 'fcntl' to indicate that a file is open for reading  only.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
O_RDWR


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 309
 -- Built-in Function: O_RDWR ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate that a file is open for both
     reading and writing.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK,
     O_RDONLY, O_SYNC, O_TRUNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 146
Return the numerical value of the file status flag that may be  returned by 'fcntl' to indicate that a file is open for both  reading and writing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
O_SYNC


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 300
 -- Built-in Function: O_SYNC ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate that a file is open for synchronous
     I/O.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK,
     O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 137
Return the numerical value of the file status flag that may be  returned by 'fcntl' to indicate that a file is open for synchronous  I/O.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
O_TRUNC


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 317
 -- Built-in Function: O_TRUNC ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate that if file exists, it should be
     truncated when writing.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK,
     O_RDONLY, O_RDWR, O_SYNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 154
Return the numerical value of the file status flag that may be  returned by 'fcntl' to indicate that if file exists, it should be  truncated when writing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
O_WRONLY


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 297
 -- Built-in Function: O_WRONLY ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate that a file is open for writing
     only.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK,
     O_RDONLY, O_RDWR, O_SYNC, O_TRUNC.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
Return the numerical value of the file status flag that may be  returned by 'fcntl' to indicate that a file is open for writing  only.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
WNOHANG


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 280
 -- Built-in Function: WNOHANG ()
     Return the numerical value of the option argument that may be
     passed to 'waitpid' to indicate that it should return its status
     immediately instead of waiting for a process to exit.

     See also: waitpid, WUNTRACED, WCONTINUE.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 182
Return the numerical value of the option argument that may be  passed to 'waitpid' to indicate that it should return its status  immediately instead of waiting for a process to exit.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
WUNTRACED


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 305
 -- Built-in Function: WUNTRACED ()
     Return the numerical value of the option argument that may be
     passed to 'waitpid' to indicate that it should also return if the
     child process has stopped but is not traced via the 'ptrace' system
     call

     See also: waitpid, WNOHANG, WCONTINUE.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 204
Return the numerical value of the option argument that may be  passed to 'waitpid' to indicate that it should also return if the  child process has stopped but is not traced via the 'ptrace' system  call 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
WCONTINUE


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 291
 -- Built-in Function: WCONTINUE ()
     Return the numerical value of the option argument that may be
     passed to 'waitpid' to indicate that it should also return if a
     stopped child has been resumed by delivery of a 'SIGCONT' signal.

     See also: waitpid, WNOHANG, WUNTRACED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 193
Return the numerical value of the option argument that may be  passed to 'waitpid' to indicate that it should also return if a  stopped child has been resumed by delivery of a 'SIGCONT' signal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
clc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 146
 -- Built-in Function: clc ()
 -- Built-in Function: home ()
     Clear the terminal screen and move the cursor to the upper left
     corner.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Clear the terminal screen and move the cursor to the upper left  corner.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
getenv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 193
 -- Built-in Function: getenv (VAR)
     Return the value of the environment variable VAR.  For example,

          getenv ("PATH")

     returns a string containing the value of your path.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Return the value of the environment variable VAR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
putenv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
 -- Built-in Function: putenv (VAR, VALUE)
 -- Built-in Function: setenv (VAR, VALUE)
     Set the value of the environment variable VAR to VALUE.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Set the value of the environment variable VAR to VALUE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
kbhit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 492
 -- Built-in Function: kbhit ()
 -- Built-in Function: kbhit (1)
     Read a single keystroke from the keyboard.  If called with an
     argument, don't wait for a keypress.  For example,

          x = kbhit ();

     will set X to the next character typed at the keyboard as soon as
     it is typed.

          x = kbhit (1);

     is identical to the above example, but doesn't wait for a keypress,
     returning the empty string if no key is available.

     See also: input, pause.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Read a single keystroke from the keyboard.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
pause


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 518
 -- Built-in Function: pause ()
 -- Built-in Function: pause (N)
     Suspend the execution of the program for N seconds.

     N is a positive real value and may be a fraction of a second.  If
     invoked without an input arguments then the program is suspended
     until a character is typed.

     The following example prints a message and then waits 5 seconds
     before clearing the screen.

          fprintf (stderr, "wait please...\n");
          pause (5);
          clc;

     See also: kbhit, sleep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Suspend the execution of the program for N seconds.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
sleep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
 -- Built-in Function: sleep (SECONDS)
     Suspend the execution of the program for the given number of
     seconds.

     See also: usleep, pause.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Suspend the execution of the program for the given number of  seconds.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
usleep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 337
 -- Built-in Function: usleep (MICROSECONDS)
     Suspend the execution of the program for the given number of
     microseconds.  On systems where it is not possible to sleep for
     periods of time less than one second, 'usleep' will pause the
     execution for 'round (MICROSECONDS / 1e6)' seconds.

     See also: sleep, pause.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Suspend the execution of the program for the given number of  microseconds.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isieee


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 186
 -- Built-in Function: isieee ()
     Return true if your computer _claims_ to conform to the IEEE
     standard for floating point calculations.  No actual tests are
     performed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Return true if your computer _claims_ to conform to the IEEE  standard for floating point calculations.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
native_float_format


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 106
 -- Built-in Function: native_float_format ()
     Return the native floating point format as a string
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return the native floating point format as a string  



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
tilde_expand


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 689
 -- Built-in Function: tilde_expand (STRING)
     Perform tilde expansion on STRING.  If STRING begins with a tilde
     character, ('~'), all of the characters preceding the first slash
     (or all characters, if there is no slash) are treated as a possible
     user name, and the tilde and the following characters up to the
     slash are replaced by the home directory of the named user.  If the
     tilde is followed immediately by a slash, the tilde is replaced by
     the home directory of the user running Octave.  For example:

          tilde_expand ("~joeuser/bin")
               => "/home/joeuser/bin"
          tilde_expand ("~/bin")
               => "/home/jwe/bin"
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Perform tilde expansion on STRING.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
have_window_system


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
 -- Built-in Function: have_window_system ()
     Return true if a window system is available (X11, Windows, or Apple
     OS X) and false otherwise.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Return true if a window system is available (X11, Windows, or Apple  OS X) and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
time


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 446
 -- Built-in Function: SECONDS = time ()
     Return the current time as the number of seconds since the epoch.
     The epoch is referenced to 00:00:00 CUT (Coordinated Universal
     Time) 1 Jan 1970.  For example, on Monday February 17, 1997 at
     07:15:06 CUT, the value returned by 'time' was 856163706.

     See also: strftime, strptime, localtime, gmtime, mktime, now, date,
     clock, datenum, datestr, datevec, calendar, weekday.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return the current time as the number of seconds since the epoch.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gmtime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 750
 -- Built-in Function: TM_STRUCT = gmtime (T)
     Given a value returned from 'time', or any non-negative integer,
     return a time structure corresponding to CUT (Coordinated Universal
     Time).  For example:

          gmtime (time ())
               => {
                     usec = 0
                     sec = 6
                     min = 15
                     hour = 7
                     mday = 17
                     mon = 1
                     year = 97
                     wday = 1
                     yday = 47
                     isdst = 0
                     zone = CST
                  }

     See also: strftime, strptime, localtime, mktime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 141
Given a value returned from 'time', or any non-negative integer,  return a time structure corresponding to CUT (Coordinated Universal  Time).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
localtime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 721
 -- Built-in Function: TM_STRUCT = localtime (T)
     Given a value returned from 'time', or any non-negative integer,
     return a time structure corresponding to the local time zone.

          localtime (time ())
               => {
                     usec = 0
                     sec = 6
                     min = 15
                     hour = 1
                     mday = 17
                     mon = 1
                     year = 97
                     wday = 1
                     yday = 47
                     isdst = 0
                     zone = CST
                  }

     See also: strftime, strptime, gmtime, mktime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
Given a value returned from 'time', or any non-negative integer,  return a time structure corresponding to the local time zone.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mktime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 376
 -- Built-in Function: SECONDS = mktime (TM_STRUCT)
     Convert a time structure corresponding to the local time to the
     number of seconds since the epoch.  For example:

          mktime (localtime (time ()))
               => 856163706

     See also: strftime, strptime, localtime, gmtime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
Convert a time structure corresponding to the local time to the  number of seconds since the epoch.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
strftime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2987
 -- Built-in Function: strftime (FMT, TM_STRUCT)
     Format the time structure TM_STRUCT in a flexible way using the
     format string FMT that contains '%' substitutions similar to those
     in 'printf'.  Except where noted, substituted fields have a fixed
     size; numeric fields are padded if necessary.  Padding is with
     zeros by default; for fields that display a single number, padding
     can be changed or inhibited by following the '%' with one of the
     modifiers described below.  Unknown field specifiers are copied as
     normal characters.  All other characters are copied to the output
     without change.  For example:

          strftime ("%r (%Z) %A %e %B %Y", localtime (time ()))
                => "01:15:06 AM (CST) Monday 17 February 1997"

     Octave's 'strftime' function supports a superset of the ANSI C
     field specifiers.

     Literal character fields:

     '%%'
          % character.

     '%n'
          Newline character.

     '%t'
          Tab character.

     Numeric modifiers (a nonstandard extension):

     '- (dash)'
          Do not pad the field.

     '_ (underscore)'
          Pad the field with spaces.

     Time fields:

     '%H'
          Hour (00-23).

     '%I'
          Hour (01-12).

     '%k'
          Hour (0-23).

     '%l'
          Hour (1-12).

     '%M'
          Minute (00-59).

     '%p'
          Locale's AM or PM.

     '%r'
          Time, 12-hour (hh:mm:ss [AP]M).

     '%R'
          Time, 24-hour (hh:mm).

     '%s'
          Time in seconds since 00:00:00, Jan 1, 1970 (a nonstandard
          extension).

     '%S'
          Second (00-61).

     '%T'
          Time, 24-hour (hh:mm:ss).

     '%X'
          Locale's time representation (%H:%M:%S).

     '%Z'
          Time zone (EDT), or nothing if no time zone is determinable.

     Date fields:

     '%a'
          Locale's abbreviated weekday name (Sun-Sat).

     '%A'
          Locale's full weekday name, variable length (Sunday-Saturday).

     '%b'
          Locale's abbreviated month name (Jan-Dec).

     '%B'
          Locale's full month name, variable length (January-December).

     '%c'
          Locale's date and time (Sat Nov 04 12:02:33 EST 1989).

     '%C'
          Century (00-99).

     '%d'
          Day of month (01-31).

     '%e'
          Day of month ( 1-31).

     '%D'
          Date (mm/dd/yy).

     '%h'
          Same as %b.

     '%j'
          Day of year (001-366).

     '%m'
          Month (01-12).

     '%U'
          Week number of year with Sunday as first day of week (00-53).

     '%w'
          Day of week (0-6).

     '%W'
          Week number of year with Monday as first day of week (00-53).

     '%x'
          Locale's date representation (mm/dd/yy).

     '%y'
          Last two digits of year (00-99).

     '%Y'
          Year (1970-).

     See also: strptime, localtime, gmtime, mktime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 145
Format the time structure TM_STRUCT in a flexible way using the  format string FMT that contains '%' substitutions similar to those  in 'printf'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
strptime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 528
 -- Built-in Function: [TM_STRUCT, NCHARS] = strptime (STR, FMT)
     Convert the string STR to the time structure TM_STRUCT under the
     control of the format string FMT.

     If FMT fails to match, NCHARS is 0; otherwise, it is set to the
     position of last matched character plus 1.  Always check for this
     unless you're absolutely sure the date string will be parsed
     correctly.

     See also: strftime, localtime, gmtime, mktime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
Convert the string STR to the time structure TM_STRUCT under the  control of the format string FMT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
quit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 273
 -- Built-in Function: exit (STATUS)
 -- Built-in Function: quit (STATUS)
     Exit the current Octave session.  If the optional integer value
     STATUS is supplied, pass that value to the operating system as the
     Octave's exit status.  The default value is zero.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Exit the current Octave session.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
warranty


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
 -- Built-in Function: warranty ()
     Describe the conditions for copying and distributing Octave.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Describe the conditions for copying and distributing Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
system


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1692
 -- Built-in Function: system ("STRING")
 -- Built-in Function: system ("STRING", RETURN_OUTPUT)
 -- Built-in Function: system ("STRING", RETURN_OUTPUT, TYPE)
 -- Built-in Function: [STATUS, OUTPUT] = system (...)
     Execute a shell command specified by STRING.  If the optional
     argument TYPE is "async", the process is started in the background
     and the process ID of the child process is returned immediately.
     Otherwise, the child process is started and Octave waits until it
     exits.  If the TYPE argument is omitted, it defaults to the value
     "sync".

     If SYSTEM is called with one or more output arguments, or if the
     optional argument RETURN_OUTPUT is true and the subprocess is
     started synchronously, then the output from the command is returned
     as a variable.  Otherwise, if the subprocess is executed
     synchronously, its output is sent to the standard output.  To send
     the output of a command executed with 'system' through the pager,
     use a command like

          [output, text] = system ("cmd");
          disp (text);

     or

          printf ("%s\n", nthargout (2, "system", "cmd"));

     The 'system' function can return two values.  The first is the exit
     status of the command and the second is any output from the command
     that was written to the standard output stream.  For example,

          [status, output] = system ("echo foo; exit 2");

     will set the variable 'output' to the string 'foo', and the
     variable 'status' to the integer '2'.

     For commands run asynchronously, STATUS is the process id of the
     command shell that is started to run the command.

     See also: unix, dos.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Execute a shell command specified by STRING.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
atexit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 999
 -- Built-in Function: atexit (FCN)
 -- Built-in Function: atexit (FCN, FLAG)
     Register a function to be called when Octave exits.  For example,

          function last_words ()
            disp ("Bye bye");
          endfunction
          atexit ("last_words");

     will print the message "Bye bye" when Octave exits.

     The additional argument FLAG will register or unregister FCN from
     the list of functions to be called when Octave exits.  If FLAG is
     true, the function is registered, and if FLAG is false, it is
     unregistered.  For example, after registering the function
     'last_words' above,

          atexit ("last_words", false);

     will remove the function from the list and Octave will not call
     'last_words' when it exits.

     Note that 'atexit' only removes the first occurrence of a function
     from the list, so if a function was placed in the list multiple
     times with 'atexit', it must also be removed from the list multiple
     times.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Register a function to be called when Octave exits.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
octave_config_info


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 292
 -- Built-in Function: octave_config_info ()
 -- Built-in Function: octave_config_info (OPTION)
     Return a structure containing configuration and installation
     information for Octave.

     If OPTION is a string, return the configuration information for the
     specified option.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
Return a structure containing configuration and installation  information for Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
tril


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1372
 -- Function File: tril (A)
 -- Function File: tril (A, K)
 -- Function File: tril (A, K, PACK)
 -- Function File: triu (A)
 -- Function File: triu (A, K)
 -- Function File: triu (A, K, PACK)
     Return a new matrix formed by extracting the lower ('tril') or
     upper ('triu') triangular part of the matrix A, and setting all
     other elements to zero.  The second argument is optional, and
     specifies how many diagonals above or below the main diagonal
     should also be set to zero.

     The default value of K is zero, so that 'triu' and 'tril' normally
     include the main diagonal as part of the result.

     If the value of K is nonzero integer, the selection of elements
     starts at an offset of K diagonals above or below the main
     diagonal; above for positive K and below for negative K.

     The absolute value of K must not be greater than the number of
     sub-diagonals or super-diagonals.

     For example:

          tril (ones (3), -1)
               =>  0  0  0
                   1  0  0
                   1  1  0

     and

          tril (ones (3), 1)
               =>  1  1  0
                   1  1  1
                   1  1  1

     If the option "pack" is given as third argument, the extracted
     elements are not inserted into a matrix, but rather stacked
     column-wise one above other.

     See also: diag.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
Return a new matrix formed by extracting the lower ('tril') or  upper ('triu') triangular part of the matrix A, and setting all  other elements to zero.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
triu


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 166
 -- Function File: triu (A)
 -- Function File: triu (A, K)
 -- Function File: triu (A, K, PACK)
     See the documentation for the 'tril' function (*note tril::).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
See the documentation for the 'tril' function (*note tril::).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
typecast


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1433
 -- Built-in Function: typecast (X, CLASS)
     Return a new array Y resulting from interpreting the data of X in
     memory as data of the numeric class CLASS.  Both the class of X and
     CLASS must be one of the built-in numeric classes:

          "logical"
          "char"
          "int8"
          "int16"
          "int32"
          "int64"
          "uint8"
          "uint16"
          "uint32"
          "uint64"
          "double"
          "single"
          "double complex"
          "single complex"

     the last two are reserved for CLASS; they indicate that a
     complex-valued result is requested.  Complex arrays are stored in
     memory as consecutive pairs of real numbers.  The sizes of integer
     types are given by their bit counts.  Both logical and char are
     typically one byte wide; however, this is not guaranteed by C++.
     If your system is IEEE conformant, single and double should be 4
     bytes and 8 bytes wide, respectively.  "logical" is not allowed for
     CLASS.  If the input is a row vector, the return value is a row
     vector, otherwise it is a column vector.  If the bit length of X is
     not divisible by that of CLASS, an error occurs.

     An example of the use of typecast on a little-endian machine is

          X = uint16 ([1, 65535]);
          typecast (X, "uint8")
          => [   1,   0, 255, 255]

     See also: cast, bitunpack, bitpack, swapbytes.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
Return a new array Y resulting from interpreting the data of X in  memory as data of the numeric class CLASS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bitpack


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 792
 -- Built-in Function: Y = bitpack (X, CLASS)
     Return a new array Y resulting from interpreting an array X as raw
     bit patterns for data of the numeric class CLASS.  CLASS must be
     one of the built-in numeric classes:

          "char"
          "int8"
          "int16"
          "int32"
          "int64"
          "uint8"
          "uint16"
          "uint32"
          "uint64"
          "double"
          "single"

     The number of elements of X should be divisible by the bit length
     of CLASS.  If it is not, excess bits are discarded.  Bits come in
     increasing order of significance, i.e., 'x(1)' is bit 0, 'x(2)' is
     bit 1, etc.  The result is a row vector if X is a row vector,
     otherwise it is a column vector.

     See also: bitunpack, typecast.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
Return a new array Y resulting from interpreting an array X as raw  bit patterns for data of the numeric class CLASS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
bitunpack


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 502
 -- Built-in Function: Y = bitunpack (X)
     Return an array Y corresponding to the raw bit patterns of X.  X
     must belong to one of the built-in numeric classes:

          "char"
          "int8"
          "int16"
          "int32"
          "int64"
          "uint8"
          "uint16"
          "uint32"
          "uint64"
          "double"
          "single"

     The result is a row vector if X is a row vector; otherwise, it is a
     column vector.

     See also: bitpack, typecast.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Return an array Y corresponding to the raw bit patterns of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
urlwrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1380
 -- Loadable Function: urlwrite (URL, LOCALFILE)
 -- Loadable Function: F = urlwrite (URL, LOCALFILE)
 -- Loadable Function: [F, SUCCESS] = urlwrite (URL, LOCALFILE)
 -- Loadable Function: [F, SUCCESS, MESSAGE] = urlwrite (URL, LOCALFILE)
     Download a remote file specified by its URL and save it as
     LOCALFILE.  For example:

          urlwrite ("ftp://ftp.octave.org/pub/octave/README",
                    "README.txt");

     The full path of the downloaded file is returned in F.  The
     variable SUCCESS is 1 if the download was successful, otherwise it
     is 0 in which case MESSAGE contains an error message.  If no output
     argument is specified and an error occurs, then the error is
     signaled through Octave's error handling mechanism.

     This function uses libcurl.  Curl supports, among others, the HTTP,
     FTP and FILE protocols.  Username and password may be specified in
     the URL, for example:

          urlwrite ("http://username:password@example.com/file.txt",
                    "file.txt");

     GET and POST requests can be specified by METHOD and PARAM.  The
     parameter METHOD is either 'get' or 'post' and PARAM is a cell
     array of parameter and value pairs.  For example:

          urlwrite ("http://www.google.com/search", "search.html",
                    "get", {"query", "octave"});

     See also: urlread.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Download a remote file specified by its URL and save it as  LOCALFILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
urlread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1232
 -- Loadable Function: S = urlread (URL)
 -- Loadable Function: [S, SUCCESS] = urlread (URL)
 -- Loadable Function: [S, SUCCESS, MESSAGE] = urlread (URL)
 -- Loadable Function: [...] = urlread (URL, METHOD, PARAM)
     Download a remote file specified by its URL and return its content
     in string S.  For example:

          s = urlread ("ftp://ftp.octave.org/pub/octave/README");

     The variable SUCCESS is 1 if the download was successful, otherwise
     it is 0 in which case MESSAGE contains an error message.  If no
     output argument is specified and an error occurs, then the error is
     signaled through Octave's error handling mechanism.

     This function uses libcurl.  Curl supports, among others, the HTTP,
     FTP and FILE protocols.  Username and password may be specified in
     the URL.  For example:

          s = urlread ("http://user:password@example.com/file.txt");

     GET and POST requests can be specified by METHOD and PARAM.  The
     parameter METHOD is either 'get' or 'post' and PARAM is a cell
     array of parameter and value pairs.  For example:

          s = urlread ("http://www.google.com/search", "get",
                      {"query", "octave"});

     See also: urlwrite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Download a remote file specified by its URL and return its content  in string S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
isvarname


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 133
 -- Built-in Function: isvarname (NAME)
     Return true if NAME is a valid variable name.

     See also: iskeyword, exist, who.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Return true if NAME is a valid variable name.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
file_in_loadpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 708
 -- Built-in Function: file_in_loadpath (FILE)
 -- Built-in Function: file_in_loadpath (FILE, "all")

     Return the absolute name of FILE if it can be found in the list of
     directories specified by 'path'.  If no file is found, return an
     empty character string.

     If the first argument is a cell array of strings, search each
     directory of the loadpath for element of the cell array and return
     the first that matches.

     If the second optional argument "all" is supplied, return a cell
     array containing the list of all files that have the same name in
     the path.  If no files are found, return an empty cell array.

     See also: file_in_path, find_dir_in_path, path.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
Return the absolute name of FILE if it can be found in the list of  directories specified by 'path'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
file_in_path


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 864
 -- Built-in Function: file_in_path (PATH, FILE)
 -- Built-in Function: file_in_path (PATH, FILE, "all")
     Return the absolute name of FILE if it can be found in PATH.  The
     value of PATH should be a colon-separated list of directories in
     the format described for 'path'.  If no file is found, return an
     empty character string.  For example:

          file_in_path (EXEC_PATH, "sh")
               => "/bin/sh"

     If the second argument is a cell array of strings, search each
     directory of the path for element of the cell array and return the
     first that matches.

     If the third optional argument "all" is supplied, return a cell
     array containing the list of all files that have the same name in
     the path.  If no files are found, return an empty cell array.

     See also: file_in_loadpath, find_dir_in_path, path.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Return the absolute name of FILE if it can be found in PATH.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
do_string_escapes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 119
 -- Built-in Function: do_string_escapes (STRING)
     Convert special characters in STRING to their escaped forms.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Convert special characters in STRING to their escaped forms.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
undo_string_escapes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 769
 -- Built-in Function: undo_string_escapes (S)
     Convert special characters in strings back to their escaped forms.
     For example, the expression

          bell = "\a";

     assigns the value of the alert character (control-g, ASCII code 7)
     to the string variable 'bell'.  If this string is printed, the
     system will ring the terminal bell (if it is possible).  This is
     normally the desired outcome.  However, sometimes it is useful to
     be able to print the original representation of the string, with
     the special characters replaced by their escape sequences.  For
     example,

          octave:13> undo_string_escapes (bell)
          ans = \a

     replaces the unprintable alert character with its printable
     representation.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Convert special characters in strings back to their escaped forms.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
is_absolute_filename


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 185
 -- Built-in Function: is_absolute_filename (FILE)
     Return true if FILE is an absolute filename.

     See also: is_rooted_relative_filename, make_absolute_filename,
     isdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return true if FILE is an absolute filename.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
is_rooted_relative_filename


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 186
 -- Built-in Function: is_rooted_relative_filename (FILE)
     Return true if FILE is a rooted-relative filename.

     See also: is_absolute_filename, make_absolute_filename, isdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return true if FILE is a rooted-relative filename.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
make_absolute_filename


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 287
 -- Built-in Function: make_absolute_filename (FILE)
     Return the full name of FILE beginning from the root of the file
     system.  No check is done for the existence of FILE.

     See also: canonicalize_file_name, is_absolute_filename,
     is_rooted_relative_filename, isdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Return the full name of FILE beginning from the root of the file  system.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
find_dir_in_path


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 568
 -- Built-in Function: find_dir_in_path (DIR)
 -- Built-in Function: find_dir_in_path (DIR, "all")
     Return the full name of the path element matching DIR.  The match
     is performed at the end of each path element.  For example, if DIR
     is "foo/bar", it matches the path element "/some/dir/foo/bar", but
     not "/some/dir/foo/bar/baz" "/some/dir/allfoo/bar".

     The second argument is optional.  If it is supplied, return a cell
     array containing all name matches rather than just the first.

     See also: file_in_path, file_in_loadpath, path.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Return the full name of the path element matching DIR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
errno


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 354
 -- Built-in Function: ERR = errno ()
 -- Built-in Function: ERR = errno (VAL)
 -- Built-in Function: ERR = errno (NAME)
     Return the current value of the system-dependent variable errno,
     set its value to VAL and return the previous value, or return the
     named error code given NAME as a character string, or -1 if NAME is
     not found.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 212
Return the current value of the system-dependent variable errno,  set its value to VAL and return the previous value, or return the  named error code given NAME as a character string, or -1 if NAME is  not found.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
errno_list


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
 -- Built-in Function: errno_list ()
     Return a structure containing the system-dependent errno values.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return a structure containing the system-dependent errno values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isindex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 442
 -- Built-in Function: isindex (IND)
 -- Built-in Function: isindex (IND, N)
     Return true if IND is a valid index.  Valid indices are either
     positive integers (although possibly of real data type), or logical
     arrays.  If present, N specifies the maximum extent of the
     dimension to be indexed.  When possible the internal result is
     cached so that subsequent indexing using IND will not perform the
     check again.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Return true if IND is a valid index.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isglobal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 210
 -- Built-in Function: isglobal (NAME)
     Return true if NAME is a globally visible variable.  For example:

          global x
          isglobal ("x")
             => 1

     See also: isvarname, exist.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return true if NAME is a globally visible variable.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
exist


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1167
 -- Built-in Function: exist (NAME, TYPE)
     Return 1 if the name exists as a variable, 2 if the name is an
     absolute file name, an ordinary file in Octave's 'path', or (after
     appending '.m') a function file in Octave's 'path', 3 if the name
     is a '.oct' or '.mex' file in Octave's 'path', 5 if the name is a
     built-in function, 7 if the name is a directory, or 103 if the name
     is a function not associated with a file (entered on the command
     line).

     Otherwise, return 0.

     This function also returns 2 if a regular file called NAME exists
     in Octave's search path.  If you want information about other types
     of files, you should use some combination of the functions
     'file_in_path' and 'stat' instead.

     If the optional argument TYPE is supplied, check only for symbols
     of the specified type.  Valid types are

     "var"
          Check only for variables.

     "builtin"
          Check only for built-in functions.

     "file"
          Check only for files and directories.

     "dir"
          Check only for directories.

     See also: file_in_loadpath, file_in_path, find_dir_in_path, stat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 144
Return 1 if the name exists as a variable, 2 if the name is an  absolute file name, an ordinary file in Octave's 'path', or (after  appending '.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
who


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1156
 -- Command: who
 -- Command: who pattern ...
 -- Command: who option pattern ...
 -- Command: C = who ("pattern", ...)
     List currently defined variables matching the given patterns.
     Valid pattern syntax is the same as described for the 'clear'
     command.  If no patterns are supplied, all variables are listed.
     By default, only variables visible in the local scope are
     displayed.

     The following are valid options but may not be combined.

     'global'
          List variables in the global scope rather than the current
          scope.

     '-regexp'
          The patterns are considered to be regular expressions when
          matching the variables to display.  The same pattern syntax
          accepted by the 'regexp' function is used.

     '-file'
          The next argument is treated as a filename.  All variables
          found within the specified file are listed.  No patterns are
          accepted when reading variables from a file.

     If called as a function, return a cell array of defined variable
     names matching the given patterns.

     See also: whos, isglobal, isvarname, exist, regexp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
List currently defined variables matching the given patterns.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
whos


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1721
 -- Command: whos
 -- Command: whos pattern ...
 -- Command: whos option pattern ...
 -- Command: S = whos ("pattern", ...)
     Provide detailed information on currently defined variables
     matching the given patterns.  Options and pattern syntax are the
     same as for the 'who' command.  Extended information about each
     variable is summarized in a table with the following default
     entries.

     Attr
          Attributes of the listed variable.  Possible attributes are:

          blank
               Variable in local scope

          'a'
               Automatic variable.  An automatic variable is one created
               by the interpreter, for example 'argn'.

          'c'
               Variable of complex type.

          'f'
               Formal parameter (function argument).

          'g'
               Variable with global scope.

          'p'
               Persistent variable.

     Name
          The name of the variable.

     Size
          The logical size of the variable.  A scalar is 1x1, a vector
          is 1xN or Nx1, a 2-D matrix is MxN.

     Bytes
          The amount of memory currently used to store the variable.

     Class
          The class of the variable.  Examples include double, single,
          char, uint16, cell, and struct.

     The table can be customized to display more or less information
     through the function 'whos_line_format'.

     If 'whos' is called as a function, return a struct array of defined
     variable names matching the given patterns.  Fields in the
     structure describing each variable are: name, size, bytes, class,
     global, sparse, complex, nesting, persistent.

     See also: who, whos_line_format.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
Provide detailed information on currently defined variables  matching the given patterns.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
mlock


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 155
 -- Built-in Function: mlock ()
     Lock the current function into memory so that it can't be cleared.

     See also: munlock, mislocked, persistent.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Lock the current function into memory so that it can't be cleared.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
munlock


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 220
 -- Built-in Function: munlock ()
 -- Built-in Function: munlock (FCN)
     Unlock the named function FCN.  If no function is named then unlock
     the current function.

     See also: mlock, mislocked, persistent.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Unlock the named function FCN.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
mislocked


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 258
 -- Built-in Function: mislocked ()
 -- Built-in Function: mislocked (FCN)
     Return true if the named function FCN is locked.  If no function is
     named then return true if the current function is locked.

     See also: mlock, munlock, persistent.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return true if the named function FCN is locked.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
clear


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2168
 -- Command: clear [options] pattern ...
     Delete the names matching the given patterns from the symbol table.
     The pattern may contain the following special characters:

     '?'
          Match any single character.

     '*'
          Match zero or more characters.

     '[ LIST ]'
          Match the list of characters specified by LIST.  If the first
          character is '!' or '^', match all characters except those
          specified by LIST.  For example, the pattern '[a-zA-Z]' will
          match all lowercase and uppercase alphabetic characters.

     For example, the command

          clear foo b*r

     clears the name 'foo' and all names that begin with the letter 'b'
     and end with the letter 'r'.

     If 'clear' is called without any arguments, all user-defined
     variables (local and global) are cleared from the symbol table.  If
     'clear' is called with at least one argument, only the visible
     names matching the arguments are cleared.  For example, suppose you
     have defined a function 'foo', and then hidden it by performing the
     assignment 'foo = 2'.  Executing the command 'clear foo' once will
     clear the variable definition and restore the definition of 'foo'
     as a function.  Executing 'clear foo' a second time will clear the
     function definition.

     The following options are available in both long and short form

     '-all, -a'
          Clears all local and global user-defined variables and all
          functions from the symbol table.

     '-exclusive, -x'
          Clears the variables that don't match the following pattern.

     '-functions, -f'
          Clears the function names and the built-in symbols names.

     '-global, -g'
          Clears the global symbol names.

     '-variables, -v'
          Clears the local variable names.

     '-classes, -c'
          Clears the class structure table and clears all objects.

     '-regexp, -r'
          The arguments are treated as regular expressions as any
          variables that match will be cleared.

     With the exception of 'exclusive', all long options can be used
     without the dash as well.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Delete the names matching the given patterns from the symbol table.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
whos_line_format


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1969
 -- Built-in Function: VAL = whos_line_format ()
 -- Built-in Function: OLD_VAL = whos_line_format (NEW_VAL)
 -- Built-in Function: whos_line_format (NEW_VAL, "local")
     Query or set the format string used by the command 'whos'.

     A full format string is:

          %[modifier]<command>[:width[:left-min[:balance]]];

     The following command sequences are available:

     '%a'
          Prints attributes of variables (g=global, p=persistent,
          f=formal parameter, a=automatic variable).

     '%b'
          Prints number of bytes occupied by variables.

     '%c'
          Prints class names of variables.

     '%e'
          Prints elements held by variables.

     '%n'
          Prints variable names.

     '%s'
          Prints dimensions of variables.

     '%t'
          Prints type names of variables.

     Every command may also have an alignment modifier:

     'l'
          Left alignment.

     'r'
          Right alignment (default).

     'c'
          Column-aligned (only applicable to command %s).

     The 'width' parameter is a positive integer specifying the minimum
     number of columns used for printing.  No maximum is needed as the
     field will auto-expand as required.

     The parameters 'left-min' and 'balance' are only available when the
     column-aligned modifier is used with the command '%s'.  'balance'
     specifies the column number within the field width which will be
     aligned between entries.  Numbering starts from 0 which indicates
     the leftmost column.  'left-min' specifies the minimum field width
     to the left of the specified balance column.

     The default format is " %a:4; %ln:6; %cs:16:6:1; %rb:12;
     %lc:-1;\n".

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: whos.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Query or set the format string used by the command 'whos'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
missing_function_hook


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 576
 -- Built-in Function: VAL = missing_function_hook ()
 -- Built-in Function: OLD_VAL = missing_function_hook (NEW_VAL)
 -- Built-in Function: missing_function_hook (NEW_VAL, "local")
     Query or set the internal variable that specifies the function to
     call when an unknown identifier is requested.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: missing_component_hook.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Query or set the internal variable that specifies the function to  call when an unknown identifier is requested.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
missing_component_hook


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1065
 -- Built-in Function: VAL = missing_component_hook ()
 -- Built-in Function: OLD_VAL = missing_component_hook (NEW_VAL)
 -- Built-in Function: missing_component_hook (NEW_VAL, "local")
     Query or set the internal variable that specifies the function to
     call when a component of Octave is missing.  This can be useful for
     packagers that may split the Octave installation into multiple
     sub-packages, for example, to provide a hint to users for how to
     install the missing components.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     The hook function is expected to be of the form

          FCN (COMPONENT)

     Octave will call FCN with the name of the function that requires
     the component and a string describing the missing component.  The
     hook function should return an error message to be displayed.

     See also: missing_function_hook.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
Query or set the internal variable that specifies the function to  call when a component of Octave is missing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
debug_jit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 545
 -- Built-in Function: VAL = debug_jit ()
 -- Built-in Function: OLD_VAL = debug_jit (NEW_VAL)
 -- Built-in Function: debug_jit (NEW_VAL, "local")
     Query or set the internal variable that determines whether
     debugging/tracing is enabled for Octave's JIT compiler.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: jit_enable, jit_startcnt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
Query or set the internal variable that determines whether  debugging/tracing is enabled for Octave's JIT compiler.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
jit_enable


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 503
 -- Built-in Function: VAL = jit_enable ()
 -- Built-in Function: OLD_VAL = jit_enable (NEW_VAL)
 -- Built-in Function: jit_enable (NEW_VAL, "local")
     Query or set the internal variable that enables Octave's JIT
     compiler.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: jit_startcnt, debug_jit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Query or set the internal variable that enables Octave's JIT  compiler.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
jit_startcnt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 749
 -- Built-in Function: VAL = jit_startcnt ()
 -- Built-in Function: OLD_VAL = jit_startcnt (NEW_VAL)
 -- Built-in Function: jit_startcnt (NEW_VAL, "local")
     Query or set the internal variable that determines whether JIT
     compilation will take place for a specific loop.  Because
     compilation is a costly operation it does not make sense to employ
     JIT when the loop count is low.  By default only loops with greater
     than 1000 iterations will be accelerated.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: jit_enable, debug_jit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Query or set the internal variable that determines whether JIT  compilation will take place for a specific loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
autoload


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1256
 -- Built-in Function: AUTOLOAD_MAP = autoload ()
 -- Built-in Function: autoload (FUNCTION, FILE)
 -- Built-in Function: autoload (..., "remove")
     Define FUNCTION to autoload from FILE.

     The second argument, FILE, should be an absolute file name or a
     file name in the same directory as the function or script from
     which the autoload command was run.  FILE _should not_ depend on
     the Octave load path.

     Normally, calls to 'autoload' appear in PKG_ADD script files that
     are evaluated when a directory is added to Octave's load path.  To
     avoid having to hardcode directory names in FILE, if FILE is in the
     same directory as the PKG_ADD script then

          autoload ("foo", "bar.oct");

     will load the function 'foo' from the file 'bar.oct'.  The above
     usage when 'bar.oct' is not in the same directory, or usages such
     as

          autoload ("foo", file_in_loadpath ("bar.oct"))

     are strongly discouraged, as their behavior may be unpredictable.

     With no arguments, return a structure containing the current
     autoload map.

     If a third argument "remove" is given, the function is cleared and
     not loaded anymore during the current Octave session.

     See also: PKG_ADD.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Define FUNCTION to autoload from FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
mfilename


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 467
 -- Built-in Function: mfilename ()
 -- Built-in Function: mfilename ("fullpath")
 -- Built-in Function: mfilename ("fullpathext")
     Return the name of the currently executing file.

     When called from outside an m-file return the empty string.  Given
     the argument "fullpath", include the directory part of the file
     name, but not the extension.  Given the argument "fullpathext",
     include the directory part of the file name and the extension.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the name of the currently executing file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
source


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 231
 -- Built-in Function: source (FILE)
     Parse and execute the contents of FILE.

     This is equivalent to executing commands from a script file, but
     without requiring the file to be named 'FILE.m'.

     See also: run.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Parse and execute the contents of FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
feval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 926
 -- Built-in Function: feval (NAME, ...)
     Evaluate the function named NAME.  Any arguments after the first
     are passed as inputs to the named function.  For example,

          feval ("acos", -1)
               => 3.1416

     calls the function 'acos' with the argument '-1'.

     The function 'feval' can also be used with function handles of any
     sort (*note Function Handles::).  Historically, 'feval' was the
     only way to call user-supplied functions in strings, but function
     handles are now preferred due to the cleaner syntax they offer.
     For example,

          F = @exp;
          feval (F, 1)
              => 2.7183
          F (1)
              => 2.7183

     are equivalent ways to call the function referred to by F.  If it
     cannot be predicted beforehand whether F is a function handle,
     function name in a string, or inline function then 'feval' can be
     used instead.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Evaluate the function named NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
builtin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 642
 -- Built-in Function: [...] = builtin (F, ...)
     Call the base function F even if F is overloaded to another
     function for the given type signature.

     This is normally useful when doing object-oriented programming and
     there is a requirement to call one of Octave's base functions
     rather than the overloaded one of a new class.

     A trivial example which redefines the 'sin' function to be the
     'cos' function shows how 'builtin' works.

          sin (0)
            => 0
          function y = sin (x), y = cos (x); endfunction
          sin (0)
            => 1
          builtin ("sin", 0)
            => 0
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
Call the base function F even if F is overloaded to another  function for the given type signature.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
eval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1226
 -- Built-in Function: eval (TRY)
 -- Built-in Function: eval (TRY, CATCH)
     Parse the string TRY and evaluate it as if it were an Octave
     program.  If that fails, evaluate the optional string CATCH.  The
     string TRY is evaluated in the current context, so any results
     remain available after 'eval' returns.

     The following example creates the variable A with the approximate
     value of 3.1416 in the current workspace.

          eval ("A = acos(-1);");

     If an error occurs during the evaluation of TRY then the CATCH
     string is evaluated, as the following example shows:

          eval ('error ("This is a bad example");',
                'printf ("This error occurred:\n%s\n", lasterr ());');
               -| This error occurred:
                  This is a bad example

     Programming Note: if you are only using 'eval' as an
     error-capturing mechanism, rather than for the execution of
     arbitrary code strings, Consider using try/catch blocks or
     unwind_protect/unwind_protect_cleanup blocks instead.  These
     techniques have higher performance and don't introduce the security
     considerations that the evaluation of arbitrary code does.

     See also: evalin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Parse the string TRY and evaluate it as if it were an Octave  program.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
assignin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 179
 -- Built-in Function: assignin (CONTEXT, VARNAME, VALUE)
     Assign VALUE to VARNAME in context CONTEXT, which may be either
     "base" or "caller".

     See also: evalin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Assign VALUE to VARNAME in context CONTEXT, which may be either  "base" or "caller".



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
evalin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 261
 -- Built-in Function: evalin (CONTEXT, TRY)
 -- Built-in Function: evalin (CONTEXT, TRY, CATCH)
     Like 'eval', except that the expressions are evaluated in the
     context CONTEXT, which may be either "caller" or "base".

     See also: eval, assignin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 119
Like 'eval', except that the expressions are evaluated in the  context CONTEXT, which may be either "caller" or "base".



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
mouse_wheel_zoom


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 858
 -- Loadable Function: VAL = mouse_wheel_zoom ()
 -- Loadable Function: OLD_VAL = mouse_wheel_zoom (NEW_VAL)
 -- Loadable Function: mouse_wheel_zoom (NEW_VAL, "local")
     Query or set the mouse wheel zoom factor.

     The zoom factor is a number in the range (0,1) which is the
     percentage of the current axis limits that will be used when
     zooming.  For example, if the current x-axis limits are [0, 50] and
     'mouse_wheel_zoom' is 0.4 (40%), then a zoom operation will change
     the limits by 20.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     This function is currently implemented only for the FLTK graphics
     toolkit.

     See also: gui_mode.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Query or set the mouse wheel zoom factor.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
gui_mode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 513
 -- Built-in Function: MODE = gui_mode ()
 -- Built-in Function: gui_mode (MODE)
     Query or set the GUI mode for the current graphics toolkit.  The
     MODE argument can be one of the following strings:

     "2d"
          Allows panning and zooming of current axes.

     "3d"
          Allows rotating and zooming of current axes.

     "none"
          Mouse inputs have no effect.

     This function is currently implemented only for the FLTK graphics
     toolkit.

     See also: mouse_wheel_zoom.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Query or set the GUI mode for the current graphics toolkit.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
amd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1277
 -- Loadable Function: P = amd (S)
 -- Loadable Function: P = amd (S, OPTS)

     Return the approximate minimum degree permutation of a matrix.
     This permutation such that the Cholesky factorization of 'S (P, P)'
     tends to be sparser than the Cholesky factorization of S itself.
     'amd' is typically faster than 'symamd' but serves a similar
     purpose.

     The optional parameter OPTS is a structure that controls the
     behavior of 'amd'.  The fields of the structure are

     OPTS.dense
          Determines what 'amd' considers to be a dense row or column of
          the input matrix.  Rows or columns with more than 'max(16,
          (dense * sqrt (N)' entries, where N is the order of the matrix
          S, are ignored by 'amd' during the calculation of the
          permutation The value of dense must be a positive scalar and
          its default value is 10.0

     OPTS.aggressive
          If this value is a nonzero scalar, then 'amd' performs
          aggressive absorption.  The default is not to perform
          aggressive absorption.

     The author of the code itself is Timothy A. Davis
     <davis@cise.ufl.edu>, University of Florida (see
     <http://www.cise.ufl.edu/research/sparse/amd>).

     See also: symamd, colamd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return the approximate minimum degree permutation of a matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ccolamd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3870
 -- Loadable Function: P = ccolamd (S)
 -- Loadable Function: P = ccolamd (S, KNOBS)
 -- Loadable Function: P = ccolamd (S, KNOBS, CMEMBER)
 -- Loadable Function: [P, STATS] = ccolamd (...)

     Constrained column approximate minimum degree permutation.  'P =
     ccolamd (S)' returns the column approximate minimum degree
     permutation vector for the sparse matrix S.  For a non-symmetric
     matrix S, 'S(:, P)' tends to have sparser LU factors than S.  'chol
     (S(:, P)' * S(:, P))' also tends to be sparser than 'chol (S' *
     S)'.  'P = ccolamd (S, 1)' optimizes the ordering for 'lu (S(:,
     P))'.  The ordering is followed by a column elimination tree
     post-ordering.

     KNOBS is an optional 1-element to 5-element input vector, with a
     default value of '[0 10 10 1 0]' if not present or empty.  Entries
     not present are set to their defaults.

     'KNOBS(1)'
          if nonzero, the ordering is optimized for 'lu (S(:, p))'.  It
          will be a poor ordering for 'chol (S(:, P)' * S(:, P))'.  This
          is the most important knob for ccolamd.

     'KNOBS(2)'
          if S is m-by-n, rows with more than 'max (16, KNOBS(2) * sqrt
          (n))' entries are ignored.

     'KNOBS(3)'
          columns with more than 'max (16, KNOBS(3) * sqrt (min (M,
          N)))' entries are ignored and ordered last in the output
          permutation (subject to the cmember constraints).

     'KNOBS(4)'
          if nonzero, aggressive absorption is performed.

     'KNOBS(5)'
          if nonzero, statistics and knobs are printed.

     CMEMBER is an optional vector of length n.  It defines the
     constraints on the column ordering.  If 'CMEMBER(j) = C', then
     column J is in constraint set C (C must be in the range 1 to n).
     In the output permutation P, all columns in set 1 appear first,
     followed by all columns in set 2, and so on.  'CMEMBER = ones
     (1,n)' if not present or empty.  'ccolamd (S, [], 1 : n)' returns
     '1 : n'

     'P = ccolamd (S)' is about the same as 'P = colamd (S)'.  KNOBS and
     its default values differ.  'colamd' always does aggressive
     absorption, and it finds an ordering suitable for both 'lu (S(:,
     P))' and 'chol (S(:, P)' * S(:, P))'; it cannot optimize its
     ordering for 'lu (S(:, P))' to the extent that 'ccolamd (S, 1)'
     can.

     STATS is an optional 20-element output vector that provides data
     about the ordering and the validity of the input matrix S.
     Ordering statistics are in 'STATS(1 : 3)'.  'STATS(1)' and
     'STATS(2)' are the number of dense or empty rows and columns
     ignored by CCOLAMD and 'STATS(3)' is the number of garbage
     collections performed on the internal data structure used by
     CCOLAMD (roughly of size '2.2 * nnz (S) + 4 * M + 7 * N' integers).

     'STATS(4 : 7)' provide information if CCOLAMD was able to continue.
     The matrix is OK if 'STATS(4)' is zero, or 1 if invalid.
     'STATS(5)' is the rightmost column index that is unsorted or
     contains duplicate entries, or zero if no such column exists.
     'STATS(6)' is the last seen duplicate or out-of-order row index in
     the column index given by 'STATS(5)', or zero if no such row index
     exists.  'STATS(7)' is the number of duplicate or out-of-order row
     indices.  'STATS(8 : 20)' is always zero in the current version of
     CCOLAMD (reserved for future use).

     The authors of the code itself are S. Larimore, T. Davis (Univ.  of
     Florida) and S. Rajamanickam in collaboration with J. Bilbert and
     E. Ng.  Supported by the National Science Foundation (DMS-9504974,
     DMS-9803599, CCR-0203270), and a grant from Sandia National Lab.
     See <http://www.cise.ufl.edu/research/sparse> for ccolamd, csymamd,
     amd, colamd, symamd, and other related orderings.

     See also: colamd, csymamd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Constrained column approximate minimum degree permutation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
csymamd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2744
 -- Loadable Function: P = csymamd (S)
 -- Loadable Function: P = csymamd (S, KNOBS)
 -- Loadable Function: P = csymamd (S, KNOBS, CMEMBER)
 -- Loadable Function: [P, STATS] = csymamd (...)

     For a symmetric positive definite matrix S, returns the permutation
     vector P such that 'S(P,P)' tends to have a sparser Cholesky factor
     than S.  Sometimes 'csymamd' works well for symmetric indefinite
     matrices too.  The matrix S is assumed to be symmetric; only the
     strictly lower triangular part is referenced.  S must be square.
     The ordering is followed by an elimination tree post-ordering.

     KNOBS is an optional 1-element to 3-element input vector, with a
     default value of '[10 1 0]' if present or empty.  Entries not
     present are set to their defaults.

     'KNOBS(1)'
          If S is n-by-n, then rows and columns with more than
          'max(16,KNOBS(1)*sqrt(n))' entries are ignored, and ordered
          last in the output permutation (subject to the cmember
          constraints).

     'KNOBS(2)'
          If nonzero, aggressive absorption is performed.

     'KNOBS(3)'
          If nonzero, statistics and knobs are printed.

     CMEMBER is an optional vector of length n.  It defines the
     constraints on the ordering.  If 'CMEMBER(j) = S', then row/column
     j is in constraint set C (C must be in the range 1 to n).  In the
     output permutation P, rows/columns in set 1 appear first, followed
     by all rows/columns in set 2, and so on.  'CMEMBER = ones (1,n)' if
     not present or empty.  'csymamd (S,[],1:n)' returns '1:n'.

     'P = csymamd (S)' is about the same as 'P = symamd (S)'.  KNOBS and
     its default values differ.

     'STATS(4:7)' provide information if CCOLAMD was able to continue.
     The matrix is OK if 'STATS(4)' is zero, or 1 if invalid.
     'STATS(5)' is the rightmost column index that is unsorted or
     contains duplicate entries, or zero if no such column exists.
     'STATS(6)' is the last seen duplicate or out-of-order row index in
     the column index given by 'STATS(5)', or zero if no such row index
     exists.  'STATS(7)' is the number of duplicate or out-of-order row
     indices.  'STATS(8:20)' is always zero in the current version of
     CCOLAMD (reserved for future use).

     The authors of the code itself are S. Larimore, T. Davis (Uni of
     Florida) and S. Rajamanickam in collaboration with J. Bilbert and
     E. Ng.  Supported by the National Science Foundation (DMS-9504974,
     DMS-9803599, CCR-0203270), and a grant from Sandia National Lab.
     See <http://www.cise.ufl.edu/research/sparse> for ccolamd, csymamd,
     amd, colamd, symamd, and other related orderings.

     See also: symamd, ccolamd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 145
For a symmetric positive definite matrix S, returns the permutation  vector P such that 'S(P,P)' tends to have a sparser Cholesky factor  than S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
chol


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1744
 -- Loadable Function: R = chol (A)
 -- Loadable Function: [R, P] = chol (A)
 -- Loadable Function: [R, P, Q] = chol (S)
 -- Loadable Function: [R, P, Q] = chol (S, "vector")
 -- Loadable Function: [L, ...] = chol (..., "lower")
 -- Loadable Function: [L, ...] = chol (..., "upper")
     Compute the Cholesky factor, R, of the symmetric positive definite
     matrix A, where

          R' * R = A.

     Called with one output argument 'chol' fails if A or S is not
     positive definite.  With two or more output arguments P flags
     whether the matrix was positive definite and 'chol' does not fail.
     A zero value indicated that the matrix was positive definite and
     the R gives the factorization, and P will have a positive value
     otherwise.

     If called with 3 outputs then a sparsity preserving row/column
     permutation is applied to A prior to the factorization.  That is R
     is the factorization of 'A(Q,Q)' such that

          R' * R = Q' * A * Q.

     The sparsity preserving permutation is generally returned as a
     matrix.  However, given the flag "vector", Q will be returned as a
     vector such that

          R' * R = A(Q, Q).

     Called with either a sparse or full matrix and using the "lower"
     flag, 'chol' returns the lower triangular factorization such that

          L * L' = A.

     For full matrices, if the "lower" flag is set only the lower
     triangular part of the matrix is used for the factorization,
     otherwise the upper triangular part is used.

     In general the lower triangular factorization is significantly
     faster for sparse matrices.

     See also: hess, lu, qr, qz, schur, svd, cholinv, chol2inv,
     cholupdate, cholinsert, choldelete, cholshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Compute the Cholesky factor, R, of the symmetric positive definite  matrix A, where 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cholinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 184
 -- Loadable Function: cholinv (A)
     Use the Cholesky factorization to compute the inverse of the
     symmetric positive definite matrix A.

     See also: chol, chol2inv, inv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
Use the Cholesky factorization to compute the inverse of the  symmetric positive definite matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
chol2inv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 344
 -- Loadable Function: chol2inv (U)
     Invert a symmetric, positive definite square matrix from its
     Cholesky decomposition, U.  Note that U should be an
     upper-triangular matrix with positive diagonal elements.  'chol2inv
     (U)' provides 'inv (U'*U)' but it is much faster than using 'inv'.

     See also: chol, cholinv, inv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
Invert a symmetric, positive definite square matrix from its  Cholesky decomposition, U.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
cholupdate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 639
 -- Loadable Function: [R1, INFO] = cholupdate (R, U, OP)
     Update or downdate a Cholesky factorization.  Given an upper
     triangular matrix R and a column vector U, attempt to determine
     another upper triangular matrix R1 such that

        * R1'*R1 = R'*R + U*U' if OP is "+"

        * R1'*R1 = R'*R - U*U' if OP is "-"

     If OP is "-", INFO is set to

        * 0 if the downdate was successful,

        * 1 if R'*R - U*U' is not positive definite,

        * 2 if R is singular.

     If INFO is not present, an error message is printed in cases 1 and
     2.

     See also: chol, cholinsert, choldelete, cholshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Update or downdate a Cholesky factorization.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
cholinsert


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 682
 -- Loadable Function: R1 = cholinsert (R, J, U)
 -- Loadable Function: [R1, INFO] = cholinsert (R, J, U)
     Given a Cholesky factorization of a real symmetric or complex
     Hermitian positive definite matrix A = R'*R, R upper triangular,
     return the Cholesky factorization of A1, where A1(p,p) = A, A1(:,j) = A1(j,:)' = u
     and p = [1:j-1,j+1:n+1].  u(j) should be positive.  On return, INFO
     is set to

        * 0 if the insertion was successful,

        * 1 if A1 is not positive definite,

        * 2 if R is singular.

     If INFO is not present, an error message is printed in cases 1 and
     2.

     See also: chol, cholupdate, choldelete, cholshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 237
Given a Cholesky factorization of a real symmetric or complex  Hermitian positive definite matrix A = R'*R, R upper triangular,  return the Cholesky factorization of A1, where A1(p,p) = A, A1(:,j) = A1(j,:)' = u  and p = [1:j-1,j+1:n+1].



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
choldelete


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 325
 -- Loadable Function: R1 = choldelete (R, J)
     Given a Cholesky factorization of a real symmetric or complex
     Hermitian positive definite matrix A = R'*R, R upper triangular,
     return the Cholesky factorization of A(p,p), where
     p = [1:j-1,j+1:n+1].

     See also: chol, cholupdate, cholinsert, cholshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 201
Given a Cholesky factorization of a real symmetric or complex  Hermitian positive definite matrix A = R'*R, R upper triangular,  return the Cholesky factorization of A(p,p), where  p = [1:j-1,j+1:n+1].



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
cholshift


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 437
 -- Loadable Function: R1 = cholshift (R, I, J)
     Given a Cholesky factorization of a real symmetric or complex
     Hermitian positive definite matrix A = R'*R, R upper triangular,
     return the Cholesky factorization of A(p,p), where p is the
     permutation
     'p = [1:i-1, shift(i:j, 1), j+1:n]' if I < J
     or
     'p = [1:j-1, shift(j:i,-1), i+1:n]' if J < I.

     See also: chol, cholupdate, cholinsert, choldelete.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 298
Given a Cholesky factorization of a real symmetric or complex  Hermitian positive definite matrix A = R'*R, R upper triangular,  return the Cholesky factorization of A(p,p), where p is the  permutation  'p = [1:i-1, shift(i:j, 1), j+1:n]' if I < J  or  'p = [1:j-1, shift(j:i,-1), i+1:n]' if J < I.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
colamd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3557
 -- Loadable Function: P = colamd (S)
 -- Loadable Function: P = colamd (S, KNOBS)
 -- Loadable Function: [P, STATS] = colamd (S)
 -- Loadable Function: [P, STATS] = colamd (S, KNOBS)

     Column approximate minimum degree permutation.  'P = colamd (S)'
     returns the column approximate minimum degree permutation vector
     for the sparse matrix S.  For a non-symmetric matrix S, 'S(:,P)'
     tends to have sparser LU factors than S.  The
     Cholesky factorization of 'S(:,P)' * S(:,P)' also tends to be
     sparser than that of 'S' * S'.

     KNOBS is an optional one- to three-element input vector.  If S is
     m-by-n, then rows with more than 'max(16,KNOBS(1)*sqrt(n))' entries
     are ignored.  Columns with more than 'max
     (16,KNOBS(2)*sqrt(min(m,n)))' entries are removed prior to
     ordering, and ordered last in the output permutation P.  Only
     completely dense rows or columns are removed if 'KNOBS(1)' and
     'KNOBS(2)' are < 0, respectively.  If 'KNOBS(3)' is nonzero, STATS
     and KNOBS are printed.  The default is 'KNOBS = [10 10 0]'.  Note
     that KNOBS differs from earlier versions of colamd.

     STATS is an optional 20-element output vector that provides data
     about the ordering and the validity of the input matrix S.
     Ordering statistics are in 'STATS(1:3)'.  'STATS(1)' and 'STATS(2)'
     are the number of dense or empty rows and columns ignored by COLAMD
     and 'STATS(3)' is the number of garbage collections performed on
     the internal data structure used by COLAMD (roughly of size '2.2 *
     nnz(S) + 4 * M + 7 * N' integers).

     Octave built-in functions are intended to generate valid sparse
     matrices, with no duplicate entries, with ascending row indices of
     the nonzeros in each column, with a non-negative number of entries
     in each column (!)  and so on.  If a matrix is invalid, then COLAMD
     may or may not be able to continue.  If there are duplicate entries
     (a row index appears two or more times in the same column) or if
     the row indices in a column are out of order, then COLAMD can
     correct these errors by ignoring the duplicate entries and sorting
     each column of its internal copy of the matrix S (the input matrix
     S is not repaired, however).  If a matrix is invalid in other ways
     then COLAMD cannot continue, an error message is printed, and no
     output arguments (P or STATS) are returned.  COLAMD is thus a
     simple way to check a sparse matrix to see if it's valid.

     'STATS(4:7)' provide information if COLAMD was able to continue.
     The matrix is OK if 'STATS(4)' is zero, or 1 if invalid.
     'STATS(5)' is the rightmost column index that is unsorted or
     contains duplicate entries, or zero if no such column exists.
     'STATS(6)' is the last seen duplicate or out-of-order row index in
     the column index given by 'STATS(5)', or zero if no such row index
     exists.  'STATS(7)' is the number of duplicate or out-of-order row
     indices.  'STATS(8:20)' is always zero in the current version of
     COLAMD (reserved for future use).

     The ordering is followed by a column elimination tree
     post-ordering.

     The authors of the code itself are Stefan I. Larimore and Timothy
     A. Davis <davis@cise.ufl.edu>, University of Florida.  The
     algorithm was developed in collaboration with John Gilbert, Xerox
     PARC, and Esmond Ng, Oak Ridge National Laboratory.  (see
     <http://www.cise.ufl.edu/research/sparse/colamd>)

     See also: colperm, symamd, ccolamd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Column approximate minimum degree permutation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
symamd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3410
 -- Loadable Function: P = symamd (S)
 -- Loadable Function: P = symamd (S, KNOBS)
 -- Loadable Function: [P, STATS] = symamd (S)
 -- Loadable Function: [P, STATS] = symamd (S, KNOBS)

     For a symmetric positive definite matrix S, returns the permutation
     vector p such that 'S(P, P)' tends to have a sparser
     Cholesky factor than S.  Sometimes 'symamd' works well for
     symmetric indefinite matrices too.  The matrix S is assumed to be
     symmetric; only the strictly lower triangular part is referenced.
     S must be square.

     KNOBS is an optional one- to two-element input vector.  If S is
     n-by-n, then rows and columns with more than 'max
     (16,KNOBS(1)*sqrt(n))' entries are removed prior to ordering, and
     ordered last in the output permutation P.  No rows/columns are
     removed if 'KNOBS(1) < 0'.  If 'KNOBS (2)' is nonzero, 'stats' and
     KNOBS are printed.  The default is 'KNOBS = [10 0]'.  Note that
     KNOBS differs from earlier versions of symamd.

     STATS is an optional 20-element output vector that provides data
     about the ordering and the validity of the input matrix S.
     Ordering statistics are in 'STATS(1:3)'.  'STATS(1) = STATS(2)' is
     the number of dense or empty rows and columns ignored by SYMAMD and
     'STATS(3)' is the number of garbage collections performed on the
     internal data structure used by SYMAMD (roughly of size '8.4 * nnz
     (tril (S, -1)) + 9 * N' integers).

     Octave built-in functions are intended to generate valid sparse
     matrices, with no duplicate entries, with ascending row indices of
     the nonzeros in each column, with a non-negative number of entries
     in each column (!)  and so on.  If a matrix is invalid, then SYMAMD
     may or may not be able to continue.  If there are duplicate entries
     (a row index appears two or more times in the same column) or if
     the row indices in a column are out of order, then SYMAMD can
     correct these errors by ignoring the duplicate entries and sorting
     each column of its internal copy of the matrix S (the input matrix
     S is not repaired, however).  If a matrix is invalid in other ways
     then SYMAMD cannot continue, an error message is printed, and no
     output arguments (P or STATS) are returned.  SYMAMD is thus a
     simple way to check a sparse matrix to see if it's valid.

     'STATS(4:7)' provide information if SYMAMD was able to continue.
     The matrix is OK if 'STATS (4)' is zero, or 1 if invalid.
     'STATS(5)' is the rightmost column index that is unsorted or
     contains duplicate entries, or zero if no such column exists.
     'STATS(6)' is the last seen duplicate or out-of-order row index in
     the column index given by 'STATS(5)', or zero if no such row index
     exists.  'STATS(7)' is the number of duplicate or out-of-order row
     indices.  'STATS(8:20)' is always zero in the current version of
     SYMAMD (reserved for future use).

     The ordering is followed by a column elimination tree
     post-ordering.

     The authors of the code itself are Stefan I. Larimore and Timothy
     A. Davis <davis@cise.ufl.edu>, University of Florida.  The
     algorithm was developed in collaboration with John Gilbert, Xerox
     PARC, and Esmond Ng, Oak Ridge National Laboratory.  (see
     <http://www.cise.ufl.edu/research/sparse/colamd>)

     See also: colperm, colamd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 146
For a symmetric positive definite matrix S, returns the permutation  vector p such that 'S(P, P)' tends to have a sparser  Cholesky factor than S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
etree


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 576
 -- Loadable Function: P = etree (S)
 -- Loadable Function: P = etree (S, TYP)
 -- Loadable Function: [P, Q] = etree (S, TYP)

     Return the elimination tree for the matrix S.  By default S is
     assumed to be symmetric and the symmetric elimination tree is
     returned.  The argument TYP controls whether a symmetric or column
     elimination tree is returned.  Valid values of TYP are "sym" or
     "col", for symmetric or column elimination tree respectively.

     Called with a second argument, 'etree' also returns the postorder
     permutations on the tree.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Return the elimination tree for the matrix S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
convhulln


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1267
 -- Loadable Function: H = convhulln (PTS)
 -- Loadable Function: H = convhulln (PTS, OPTIONS)
 -- Loadable Function: [H, V] = convhulln (...)
     Compute the convex hull of the set of points PTS which is a matrix
     of size [n, dim] containing n points in a space of dimension dim.
     The hull H is an index vector into the set of points and specifies
     which points form the enclosing hull.

     An optional second argument, which must be a string or cell array
     of strings, contains options passed to the underlying qhull
     command.  See the documentation for the Qhull library for details
     <http://www.qhull.org/html/qh-quick.htm#options>.  The default
     options depend on the dimension of the input:

        * 2D, 3D, 4D: OPTIONS = '{"Qt"}'

        * 5D and higher: OPTIONS = '{"Qt", "Qx"}'

     If OPTIONS is not present or '[]' then the default arguments are
     used.  Otherwise, OPTIONS replaces the default argument list.  To
     append user options to the defaults it is necessary to repeat the
     default arguments in OPTIONS.  Use a null string to pass no
     arguments.

     If the second output V is requested the volume of the enclosing
     convex hull is calculated.

     See also: convhull, delaunayn, voronoin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 133
Compute the convex hull of the set of points PTS which is a matrix  of size [n, dim] containing n points in a space of dimension dim.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dmperm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 761
 -- Loadable Function: P = dmperm (S)
 -- Loadable Function: [P, Q, R, S] = dmperm (S)

     Perform a Dulmage-Mendelsohn permutation of the sparse matrix S.
     With a single output argument 'dmperm' performs the row
     permutations P such that 'S(P,:)' has no zero elements on the
     diagonal.

     Called with two or more output arguments, returns the row and
     column permutations, such that 'S(P, Q)' is in block triangular
     form.  The values of R and S define the boundaries of the blocks.
     If S is square then 'R == S'.

     The method used is described in: A. Pothen & C.-J. Fan.  'Computing
     the Block Triangular Form of a Sparse Matrix'.  ACM Trans.  Math.
     Software, 16(4):303-324, 1990.

     See also: colamd, ccolamd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Perform a Dulmage-Mendelsohn permutation of the sparse matrix S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
sprank


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 432
 -- Loadable Function: P = sprank (S)

     Calculate the structural rank of the sparse matrix S.  Note that
     only the structure of the matrix is used in this calculation based
     on a Dulmage-Mendelsohn permutation to block triangular form.  As
     such the numerical rank of the matrix S is bounded by 'sprank (S)
     >= rank (S)'.  Ignoring floating point errors 'sprank (S) == rank
     (S)'.

     See also: dmperm.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Calculate the structural rank of the sparse matrix S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fftw


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3360
 -- Loadable Function: METHOD = fftw ("planner")
 -- Loadable Function: fftw ("planner", METHOD)
 -- Loadable Function: WISDOM = fftw ("dwisdom")
 -- Loadable Function: fftw ("dwisdom", WISDOM)
 -- Loadable Function: fftw ("threads", NTHREADS)
 -- Loadable Function: NTHREADS = fftw ("threads")

     Manage FFTW wisdom data.  Wisdom data can be used to significantly
     accelerate the calculation of the FFTs, but implies an initial cost
     in its calculation.  When the FFTW libraries are initialized, they
     read a system wide wisdom file (typically in '/etc/fftw/wisdom'),
     allowing wisdom to be shared between applications other than
     Octave.  Alternatively, the 'fftw' function can be used to import
     wisdom.  For example,

          WISDOM = fftw ("dwisdom")

     will save the existing wisdom used by Octave to the string WISDOM.
     This string can then be saved to a file and restored using the
     'save' and 'load' commands respectively.  This existing wisdom can
     be re-imported as follows

          fftw ("dwisdom", WISDOM)

     If WISDOM is an empty string, then the wisdom used is cleared.

     During the calculation of Fourier transforms further wisdom is
     generated.  The fashion in which this wisdom is generated is also
     controlled by the 'fftw' function.  There are five different
     manners in which the wisdom can be treated:

     "estimate"
          Specifies that no run-time measurement of the optimal means of
          calculating a particular is performed, and a simple heuristic
          is used to pick a (probably sub-optimal) plan.  The advantage
          of this method is that there is little or no overhead in the
          generation of the plan, which is appropriate for a Fourier
          transform that will be calculated once.

     "measure"
          In this case a range of algorithms to perform the transform is
          considered and the best is selected based on their execution
          time.

     "patient"
          Similar to "measure", but a wider range of algorithms is
          considered.

     "exhaustive"
          Like "measure", but all possible algorithms that may be used
          to treat the transform are considered.

     "hybrid"
          As run-time measurement of the algorithm can be expensive,
          this is a compromise where "measure" is used for transforms up
          to the size of 8192 and beyond that the "estimate" method is
          used.

     The default method is "estimate".  The current method can be
     queried with

          METHOD = fftw ("planner")

     or set by using

          fftw ("planner", METHOD)

     Note that calculated wisdom will be lost when restarting Octave.
     However, the wisdom data can be reloaded if it is saved to a file
     as described above.  Saved wisdom files should not be used on
     different platforms since they will not be efficient and the point
     of calculating the wisdom is lost.

     The number of threads used for computing the plans and executing
     the transforms can be set with

          fftw ("threads", NTHREADS)

     Note that octave must be compiled with multi-threaded FFTW support
     for this feature.  The number of processors available to the
     current process is used per default.

     See also: fft, ifft, fft2, ifft2, fftn, ifftn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Manage FFTW wisdom data.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
qr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2375
 -- Loadable Function: [Q, R, P] = qr (A)
 -- Loadable Function: [Q, R, P] = qr (A, '0')
 -- Loadable Function: [C, R] = qr (A, B)
 -- Loadable Function: [C, R] = qr (A, B, '0')
     Compute the QR factorization of A, using standard LAPACK
     subroutines.  For example, given the matrix 'A = [1, 2; 3, 4]',

          [Q, R] = qr (A)

     returns

          Q =

            -0.31623  -0.94868
            -0.94868   0.31623

          R =

            -3.16228  -4.42719
             0.00000  -0.63246

     The 'qr' factorization has applications in the solution of least
     squares problems

          min norm(A x - b)

     for overdetermined systems of equations (i.e., A is a tall, thin
     matrix).  The QR factorization is 'Q * R = A' where Q is an
     orthogonal matrix and R is upper triangular.

     If given a second argument of '0', 'qr' returns an economy-sized
     QR factorization, omitting zero rows of R and the corresponding
     columns of Q.

     If the matrix A is full, the permuted QR factorization '[Q, R, P] =
     qr (A)' forms the QR factorization such that the diagonal entries
     of R are decreasing in magnitude order.  For example, given the
     matrix 'a = [1, 2; 3, 4]',

          [Q, R, P] = qr (A)

     returns

          Q =

            -0.44721  -0.89443
            -0.89443   0.44721

          R =

            -4.47214  -3.13050
             0.00000   0.44721

          P =

             0  1
             1  0

     The permuted 'qr' factorization '[Q, R, P] = qr (A)' factorization
     allows the construction of an orthogonal basis of 'span (A)'.

     If the matrix A is sparse, then compute the sparse QR factorization
     of A, using CSPARSE.  As the matrix Q is in general a full matrix,
     this function returns the Q-less factorization R of A, such that 'R
     = chol (A' * A)'.

     If the final argument is the scalar '0' and the number of rows is
     larger than the number of columns, then an economy factorization is
     returned.  That is R will have only 'size (A,1)' rows.

     If an additional matrix B is supplied, then 'qr' returns C, where
     'C = Q' * B'.  This allows the least squares approximation of 'A \
     B' to be calculated as

          [C, R] = qr (A, B)
          x = R \ C

     See also: chol, hess, lu, qz, schur, svd, qrupdate, qrinsert,
     qrdelete, qrshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Compute the QR factorization of A, using standard LAPACK  subroutines.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qrupdate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 673
 -- Loadable Function: [Q1, R1] = qrupdate (Q, R, U, V)
     Given a QR factorization of a real or complex matrix A = Q*R,
     Q unitary and R upper trapezoidal, return the QR factorization of
     A + U*V', where U and V are column vectors (rank-1 update) or
     matrices with equal number of columns (rank-k update).  Notice that
     the latter case is done as a sequence of rank-1 updates; thus, for
     k large enough, it will be both faster and more accurate to
     recompute the factorization from scratch.

     The QR factorization supplied may be either full (Q is square) or
     economized (R is square).

     See also: qr, qrinsert, qrdelete, qrshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 247
Given a QR factorization of a real or complex matrix A = Q*R,  Q unitary and R upper trapezoidal, return the QR factorization of  A + U*V', where U and V are column vectors (rank-1 update) or  matrices with equal number of columns (rank-k update).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qrinsert


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1076
 -- Loadable Function: [Q1, R1] = qrinsert (Q, R, J, X, ORIENT)
     Given a QR factorization of a real or complex matrix A = Q*R,
     Q unitary and R upper trapezoidal, return the QR factorization of
     [A(:,1:j-1) x A(:,j:n)], where U is a column vector to be inserted
     into A (if ORIENT is "col"), or the QR factorization of
     [A(1:j-1,:);x;A(:,j:n)], where X is a row vector to be inserted
     into A (if ORIENT is "row").

     The default value of ORIENT is "col".  If ORIENT is "col", U may be
     a matrix and J an index vector resulting in the QR factorization of
     a matrix B such that B(:,J) gives U and B(:,J) = [] gives A.
     Notice that the latter case is done as a sequence of k insertions;
     thus, for k large enough, it will be both faster and more accurate
     to recompute the factorization from scratch.

     If ORIENT is "col", the QR factorization supplied may be either
     full (Q is square) or economized (R is square).

     If ORIENT is "row", full factorization is needed.

     See also: qr, qrupdate, qrdelete, qrshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 348
Given a QR factorization of a real or complex matrix A = Q*R,  Q unitary and R upper trapezoidal, return the QR factorization of  [A(:,1:j-1) x A(:,j:n)], where U is a column vector to be inserted  into A (if ORIENT is "col"), or the QR factorization of  [A(1:j-1,:);x;A(:,j:n)], where X is a row vector to be inserted  into A (if ORIENT is "row").



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qrdelete


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 999
 -- Loadable Function: [Q1, R1] = qrdelete (Q, R, J, ORIENT)
     Given a QR factorization of a real or complex matrix A = Q*R,
     Q unitary and R upper trapezoidal, return the QR factorization of
     [A(:,1:j-1) A(:,j+1:n)], i.e., A with one column deleted (if ORIENT
     is "col"), or the QR factorization of [A(1:j-1,:);A(j+1:n,:)],
     i.e., A with one row deleted (if ORIENT is "row").

     The default value of ORIENT is "col".

     If ORIENT is "col", J may be an index vector resulting in the
     QR factorization of a matrix B such that A(:,J) = [] gives B.
     Notice that the latter case is done as a sequence of k deletions;
     thus, for k large enough, it will be both faster and more accurate
     to recompute the factorization from scratch.

     If ORIENT is "col", the QR factorization supplied may be either
     full (Q is square) or economized (R is square).

     If ORIENT is "row", full factorization is needed.

     See also: qr, qrupdate, qrinsert, qrshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 157
Given a QR factorization of a real or complex matrix A = Q*R,  Q unitary and R upper trapezoidal, return the QR factorization of  [A(:,1:j-1) A(:,j+1:n)], i.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
qrshift


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 395
 -- Loadable Function: [Q1, R1] = qrshift (Q, R, I, J)
     Given a QR factorization of a real or complex matrix A = Q*R,
     Q unitary and R upper trapezoidal, return the QR factorization of
     A(:,p), where p is the permutation
     'p = [1:i-1, shift(i:j, 1), j+1:n]' if I < J
     or
     'p = [1:j-1, shift(j:i,-1), i+1:n]' if J < I.

     See also: qr, qrupdate, qrinsert, qrdelete.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 261
Given a QR factorization of a real or complex matrix A = Q*R,  Q unitary and R upper trapezoidal, return the QR factorization of  A(:,p), where p is the permutation  'p = [1:i-1, shift(i:j, 1), j+1:n]' if I < J  or  'p = [1:j-1, shift(j:i,-1), i+1:n]' if J < I.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
symbfact


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1302
 -- Loadable Function: [COUNT, H, PARENT, POST, R] = symbfact (S)
 -- Loadable Function: [...] = symbfact (S, TYP)
 -- Loadable Function: [...] = symbfact (S, TYP, MODE)

     Perform a symbolic factorization analysis on the sparse matrix S.
     Where

     S
          S is a complex or real sparse matrix.

     TYP
          Is the type of the factorization and can be one of

          'sym'
               Factorize S.  This is the default.

          'col'
               Factorize 'S' * S'.

          'row'
               Factorize S * S'.

          'lo'
               Factorize S'

     MODE
          The default is to return the Cholesky factorization for R, and
          if MODE is 'L', the conjugate transpose of the
          Cholesky factorization is returned.  The conjugate transpose
          version is faster and uses less memory, but returns the same
          values for COUNT, H, PARENT and POST outputs.

     The output variables are

     COUNT
          The row counts of the Cholesky factorization as determined by
          TYP.

     H
          The height of the elimination tree.

     PARENT
          The elimination tree itself.

     POST
          A sparse boolean matrix whose structure is that of the
          Cholesky factorization as determined by TYP.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Perform a symbolic factorization analysis on the sparse matrix S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
symrcm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 978
 -- Loadable Function: P = symrcm (S)
     Return the symmetric reverse Cuthill-McKee permutation of S.  P is
     a permutation vector such that 'S(P, P)' tends to have its diagonal
     elements closer to the diagonal than S.  This is a good preordering
     for LU or Cholesky factorization of matrices that come from "long,
     skinny" problems.  It works for both symmetric and asymmetric S.

     The algorithm represents a heuristic approach to the NP-complete
     bandwidth minimization problem.  The implementation is based in the
     descriptions found in

     E. Cuthill, J. McKee.  'Reducing the Bandwidth of Sparse Symmetric
     Matrices'.  Proceedings of the 24th ACM National Conference,
     157-172 1969, Brandon Press, New Jersey.

     A. George, J.W.H. Liu.  'Computer Solution of Large Sparse Positive
     Definite Systems', Prentice Hall Series in Computational
     Mathematics, ISBN 0-13-165274-5, 1981.

     See also: colperm, colamd, symamd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Return the symmetric reverse Cuthill-McKee permutation of S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
tsearch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 288
 -- Loadable Function: IDX = tsearch (X, Y, T, XI, YI)
     Search for the enclosing Delaunay convex hull.  For 'T = delaunay
     (X, Y)', finds the index in T containing the points '(XI, YI)'.
     For points outside the convex hull, IDX is NaN.

     See also: delaunay, delaunayn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Search for the enclosing Delaunay convex hull.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
break


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
 -- Keyword: break
     Exit the innermost enclosing do, while or for loop.

     See also: do, while, for, parfor, continue.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Exit the innermost enclosing do, while or for loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
case


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 282
 -- Keyword: case VALUE
 -- Keyword: case {VALUE, ...}
     A case statement in a switch.  Octave cases are exclusive and do
     not fall-through as do C-language cases.  A switch statement must
     have at least one case.  See 'switch' for an example.

     See also: switch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
A case statement in a switch.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
catch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 118
 -- Keyword: catch
 -- Keyword: catch VALUE
     Begin the cleanup part of a try-catch block.

     See also: try.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Begin the cleanup part of a try-catch block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
continue


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
 -- Keyword: continue
     Jump to the end of the innermost enclosing do, while or for loop.

     See also: do, while, for, parfor, break.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Jump to the end of the innermost enclosing do, while or for loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
do


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 251
 -- Keyword: do
     Begin a do-until loop.  This differs from a do-while loop in that
     the body of the loop is executed at least once.

          i = 0;
          do
            i++
          until (i == 10)

     See also: for, until, while.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Begin a do-until loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
else


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 106
 -- Keyword: else
     Alternate action for an if block.  See 'if' for an example.

     See also: if.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Alternate action for an if block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
elseif


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
 -- Keyword: elseif (CONDITION)
     Alternate conditional test for an if block.  See 'if' for an
     example.

     See also: if.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Alternate conditional test for an if block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
end


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 299
 -- Built-in Function: end
     The magic index "end" refers to the last valid entry in an indexing
     operation.

     Example:

          X = [ 1 2 3
                4 5 6 ];
          X(1,end)
              => 3
          X(end,1)
              => 4
          X(end,end)
              => 6

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
The magic index "end" refers to the last valid entry in an indexing  operation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
end_try_catch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
 -- Keyword: end_try_catch
     Mark the end of an 'try-catch' block.

     See also: try, catch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Mark the end of an 'try-catch' block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
end_unwind_protect


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
 -- Keyword: end_unwind_protect
     Mark the end of an unwind_protect block.

     See also: unwind_protect.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Mark the end of an unwind_protect block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
endfor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
 -- Keyword: endfor
     Mark the end of a for loop.  See 'for' for an example.

     See also: for.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Mark the end of a for loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
endfunction


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
 -- Keyword: endfunction
     Mark the end of a function.

     See also: function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Mark the end of a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
endif


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
 -- Keyword: endif
     Mark the end of an if block.  See 'if' for an example.

     See also: if.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Mark the end of an if block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
endparfor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
 -- Keyword: endparfor
     Mark the end of a parfor loop.  See 'parfor' for an example.

     See also: parfor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Mark the end of a parfor loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
endswitch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
 -- Keyword: endswitch
     Mark the end of a switch block.  See 'switch' for an example.

     See also: switch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Mark the end of a switch block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
endwhile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
 -- Keyword: endwhile
     Mark the end of a while loop.  See 'while' for an example.

     See also: do, while.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Mark the end of a while loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
for


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
 -- Keyword: for I = RANGE
     Begin a for loop.

          for i = 1:10
            i
          endfor

     See also: do, parfor, while.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
Begin a for loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
function


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 248
 -- Keyword: function OUTPUTS = function (INPUT, ...)
 -- Keyword: function function (INPUT, ...)
 -- Keyword: function OUTPUTS = function
     Begin a function body with OUTPUTS as results and INPUTS as
     parameters.

     See also: return.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Begin a function body with OUTPUTS as results and INPUTS as  parameters.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
global


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 183
 -- Keyword: global VAR
     Declare variables to have global scope.

          global X;
          if (isempty (X))
            x = 1;
          endif

     See also: persistent.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Declare variables to have global scope.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
if


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 423
 -- Keyword: if (COND) ... endif
 -- Keyword: if (COND) ... else ... endif
 -- Keyword: if (COND) ... elseif (COND) ... endif
 -- Keyword: if (COND) ... elseif (COND) ... else ... endif
     Begin an if block.

          x = 1;
          if (x == 1)
            disp ("one");
          elseif (x == 2)
            disp ("two");
          else
            disp ("not one or two");
          endif

     See also: switch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
Begin an if block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
otherwise


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
 -- Keyword: otherwise
     The default statement in a switch block (similar to else in an if
     block).

     See also: switch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
The default statement in a switch block (similar to else in an if  block).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
parfor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 219
 -- Keyword: parfor I = RANGE
 -- Keyword: parfor (I = RANGE, MAXPROC)
     Begin a for loop that may execute in parallel.

          parfor i = 1:10
            i
          endparfor

     See also: for, do, while.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Begin a for loop that may execute in parallel.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
persistent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 434
 -- Keyword: persistent VAR
     Declare variables as persistent.  A variable that has been declared
     persistent within a function will retain its contents in memory
     between subsequent calls to the same function.  The difference
     between persistent variables and global variables is that
     persistent variables are local in scope to a particular function
     and are not visible elsewhere.

     See also: global.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Declare variables as persistent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
return


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
 -- Keyword: return
     Return from a function.

     See also: function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Return from a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
static


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
 -- Keyword: static
     This statement has been deprecated in favor of 'persistent'.

     See also: persistent.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
This statement has been deprecated in favor of 'persistent'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
switch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 364
 -- Keyword: switch STATEMENT
     Begin a switch block.

          yesno = "yes"

          switch yesno
            case {"Yes" "yes" "YES" "y" "Y"}
              value = 1;
            case {"No" "no" "NO" "n" "N"}
              value = 0;
            otherwise
              error ("invalid value");
          endswitch

     See also: if, case, otherwise.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Begin a switch block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
try


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 341
 -- Keyword: try
     Begin a try-catch block.

     If an error occurs within a try block, then the catch code will be
     run and execution will proceed after the catch block (though it is
     often recommended to use the lasterr function to re-throw the error
     after cleanup is completed).

     See also: catch, unwind_protect.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Begin a try-catch block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
until


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
 -- Keyword: until (COND)
     End a do-until loop.  See 'do' for an example.

     See also: do.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
End a do-until loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
unwind_protect


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 500
 -- Keyword: unwind_protect
     Begin an unwind_protect block.

     If an error occurs within the first part of an unwind_protect block
     the commands within the unwind_protect_cleanup block are executed
     before the error is thrown.  If an error is not thrown, then the
     unwind_protect_cleanup block is still executed (in other words, the
     unwind_protect_cleanup will be run with or without an error in the
     unwind_protect block).

     See also: unwind_protect_cleanup, try.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Begin an unwind_protect block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
unwind_protect_cleanup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 130
 -- Keyword: unwind_protect_cleanup
     Begin the cleanup section of an unwind_protect block.

     See also: unwind_protect.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Begin the cleanup section of an unwind_protect block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
varargin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
 -- Keyword: varargin
     Pass an arbitrary number of arguments into a function.

     See also: varargout, nargin, isargout, nargout, nthargout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Pass an arbitrary number of arguments into a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
varargout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
 -- Keyword: varargout
     Pass an arbitrary number of arguments out of a function.

     See also: varargin, nargin, isargout, nargout, nthargout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Pass an arbitrary number of arguments out of a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
while


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 167
 -- Keyword: while
     Begin a while loop.

          i = 0;
          while (i < 10)
            i++
          endwhile

     See also: do, endwhile, for, until.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
Begin a while loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
!


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
 -- Operator: !
     Logical 'not' operator.

     See also: ~, not.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Logical 'not' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
!=


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 -- Operator: !=
     Logical 'not equals' operator.

     See also: ~=, ne.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Logical 'not equals' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
"


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
 -- Operator: "
     String delimiter.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
String delimiter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
#


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
 -- Operator: #
     Begin comment character.

     See also: %, #{.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Begin comment character.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
#{


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 216
 -- Operator: # {
     Begin block comment.  There must be nothing else, other than
     whitespace, in the line both before and after '#{'.  It is possible
     to nest block comments.

     See also: %{, #}, #.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Begin block comment.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
#}


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 216
 -- Operator: # }
     Close block comment.  There must be nothing else, other than
     whitespace, in the line both before and after '#}'.  It is possible
     to nest block comments.

     See also: %}, #{, #.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Close block comment.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
%


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
 -- Operator: %
     Begin comment character.

     See also: #, %{.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Begin comment character.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
%{


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 216
 -- Operator: % {
     Begin block comment.  There must be nothing else, other than
     whitespace, in the line both before and after '%{'.  It is possible
     to nest block comments.

     See also: #{, %}, %.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Begin block comment.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
%}


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 216
 -- Operator: % }
     Close block comment.  There must be nothing else, other than
     whitespace, in the line both before and after '%}'.  It is possible
     to nest block comments.

     See also: #}, %{, %.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Close block comment.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
&


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
 -- Operator: &
     Element by element logical 'and' operator.

     See also: &&, and.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Element by element logical 'and' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
&&


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
 -- Operator: &&
     Logical 'and' operator (with short-circuit evaluation).

     See also: &, and.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Logical 'and' operator (with short-circuit evaluation).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
'


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 327
 -- Operator: '
     Matrix transpose operator.  For complex matrices, computes the
     complex conjugate (Hermitian) transpose.

     The single quote character may also be used to delimit strings, but
     it is better to use the double quote character, since that is never
     ambiguous.

     See also: .', transpose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Matrix transpose operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
(


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
 -- Operator: (
     Array index or function argument delimiter.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Array index or function argument delimiter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
)


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
 -- Operator: )
     Array index or function argument delimiter.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Array index or function argument delimiter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
*


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
 -- Operator: *
     Multiplication operator.

     See also: .*, times.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Multiplication operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
**


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 257
 -- Operator: **
     Power operator.  This may return complex results for real inputs.
     Use 'realsqrt', 'cbrt', 'nthroot', or 'realroot' to obtain real
     results when possible.

     See also: power, ^, .**, .^, realpow, realsqrt, cbrt, nthroot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
Power operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
+


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
 -- Operator: +
     Addition operator.

     See also: plus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
Addition operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
++


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
 -- Operator: ++
     Increment operator.  As in C, may be applied as a prefix or postfix
     operator.

     See also: -.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
Increment operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
,


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
 -- Operator: ,
     Array index, function argument, or command separator.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Array index, function argument, or command separator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
-


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
 -- Operator: -
     Subtraction or unary negation operator.

     See also: minus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Subtraction or unary negation operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
-


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 128
 -- Operator: --
     Decrement operator.  As in C, may be applied as a prefix or postfix
     operator.

     See also: ++.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
Decrement operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
.'


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 173
 -- Operator: .'
     Matrix transpose operator.  For complex matrices, computes the
     transpose, _not_ the complex conjugate transpose.

     See also: ', transpose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Matrix transpose operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
.*


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
 -- Operator: .*
     Element by element multiplication operator.

     See also: *, times.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Element by element multiplication operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
.**


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 326
 -- Operator: .*
     Element by element power operator.  If several complex results are
     possible, returns the one with smallest non-negative argument
     (angle).  Use 'realpow', 'realsqrt', 'cbrt', or 'nthroot' if a real
     result is preferred.

     See also: **, ^, .^, power, realpow, realsqrt, cbrt, nthroot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Element by element power operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
...


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
 -- Operator: ...
     Continuation marker.  Joins current line with following line.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Continuation marker.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
./


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
 -- Operator: ./
     Element by element right division operator.

     See also: /, ., rdivide, mrdivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Element by element right division operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
.\


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
 -- Operator: .\
     Element by element left division operator.

     See also: , ./, rdivide, mrdivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Element by element left division operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
.^


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 327
 -- Operator: .^
     Element by element power operator.  If several complex results are
     possible, returns the one with smallest non-negative argument
     (angle).  Use 'realpow', 'realsqrt', 'cbrt', or 'nthroot' if a real
     result is preferred.

     See also: .**, ^, **, power, realpow, realsqrt, cbrt, nthroot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Element by element power operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
/


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
 -- Operator: /
     Right division operator.

     See also: ./, , rdivide, mrdivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Right division operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
:


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
 -- Operator: :
     Select entire rows or columns of matrices.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Select entire rows or columns of matrices.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
;


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
 -- Operator: ;
     Array row or command separator.

     See also: ,.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Array row or command separator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
<


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
 -- Operator: <
     'Less than' operator.

     See also: lt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
'Less than' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
<=


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
 -- Operator: <=
     'Less than' or 'equals' operator.

     See also: le.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
'Less than' or 'equals' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
=


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
 -- Operator: =
     Assignment operator.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Assignment operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
==


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
 -- Operator: ==
     Equality test operator.

     See also: eq.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Equality test operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
>


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
 -- Operator: >
     'Greater than' operator.

     See also: gt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
'Greater than' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
>=


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 82
 -- Operator: >=
     'Greater than' or 'equals' operator.

     See also: ge.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
'Greater than' or 'equals' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
[


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
 -- Operator: [
     Return list delimiter.

     See also: ].
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Return list delimiter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
\


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
 -- Operator: \
     Left division operator.

     See also: ., /, ldivide, mldivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Left division operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
]


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
 -- Operator: ]
     Return list delimiter.

     See also: [.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Return list delimiter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
^


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 257
 -- Operator: ^
     Power operator.  This may return complex results for real inputs.
     Use 'realsqrt', 'cbrt', 'nthroot', or 'realroot' to obtain real
     results when possible.

     See also: power, **, .^, .**, realpow, realsqrt, cbrt, nthroot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
Power operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
|


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
 -- Operator: |
     Element by element logical 'or' operator.

     See also: ||, or.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Element by element logical 'or' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
||


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
 -- Operator: ||
     Logical 'or' (with short-circuit evaluation) operator.

     See also: |, or.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Logical 'or' (with short-circuit evaluation) operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
~


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
 -- Operator: ~
     Logical 'not' operator.

     See also: !, not.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Logical 'not' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
~=


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 -- Operator: ~=
     Logical 'not equals' operator.

     See also: !=, ne.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Logical 'not equals' operator.





